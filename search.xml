<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[字节跳动提前批面经]]></title>
    <url>%2F2020%2F07%2F02%2F%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E6%8F%90%E5%89%8D%E6%89%B9%E9%9D%A2%E7%BB%8F%2F</url>
    <content type="text"><![CDATA[一面 和腾讯公司出题很大的不同，也可能是秋招提前批的原因 手写ES6的class继承 继承在前端逻辑操作中是比较常见的，今天我们就从零开始写一个js的继承方式 在es5中继承实质上是先创建子类的实例对象，然后再将父类的方法添加到this上Parent.call(this)，在es6中则是先创建父类的实例对象this调用父类的super()，然后再用子类的构造函数修改this 12345678910111213141516171819202122// 手写继承 自己封装函数// 如childClass = extends(parentClass)// 这个方式创建的子类会互相影响var extendsFun = function (obj) &#123; var child = function () &#123;&#125; child.prototype = new obj return new child()&#125;//这个就很完美 newPros为自定义的属性var extendsFun = function (obj, newPros = &#123;&#125;) &#123; var child = Object.create(obj, newPros) return child&#125;// 构造函数的方式var extendsFun = function (parentClass) &#123; var child = function () &#123; parentClass(this) &#125; return new child()&#125; 手写promise封装回调函数手写数组去重，根据过滤参数实现12345678910111213141516//要去重的数组是第一个参数，第二个参数是过滤信息[ &#123; id: 1, name: 'zhangsan' &#125;, &#123; id: 1, name: 'wangwu' &#125;, &#123; id: 2, name: 'zhangsan' &#125;] 请封装一个方法，实现对数组的去重 123456789101112131415161718192021222324252627var myfun = (arr, arg) =&gt; &#123; // 把重复的index序列记下来 let result = [] for (let j = 0, len = arr.length; j &lt;len; j++) &#123; //遍历每一项 记为objItem let objItem = arr[j] //初始化 为没有重复 let repeated = false for (let i = 0, len2 = arg.length; i &lt; len2; i++)) &#123; var obj = &#123;&#125; let filterKey = arg[i] if (obj[objItem[filterKey]])&#123; // 一旦发现有重复就吧repeated置为true repeated = true &#125;else &#123; obj[objItem[filterKey]] = 1 &#125; &#125; //根据查找结果输出结果 if (repeated === false) &#123; result.push(objItem) &#125; &#125; return result&#125;]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>字节跳动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端知识点总结——JavaScript(4)]]></title>
    <url>%2F2020%2F07%2F01%2F%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94JavaScript-4%2F</url>
    <content type="text"><![CDATA[ajax和axios、fetch的区别ajax传统 Ajax 指的是 XMLHttpRequest（XHR）， 最早出现的发送后端请求技术，隶属于原始js中，核心使用XMLHttpRequest对象，多个请求之间如果有先后关系的话，就会出现回调地狱。 fetchfetch是一个低层次的API，你可以把它考虑成原生的XHR，所以使用起来并不是那么舒服，需要进行封装。 fetch号称是AJAX的替代品，是在ES6出现的，使用了ES6中的promise对象。Fetch是基于promise设计的。Fetch的代码结构比起ajax简单多了，参数有点像jQuery ajax。但是，一定记住fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象。 fetch的优点：1.符合关注分离，没有将输入、输出和用事件来跟踪的状态混杂在一个对象里2.更好更方便的写法坦白说，上面的理由对我来说完全没有什么说服力，因为不管是Jquery还是Axios都已经帮我们把xhr封装的足够好，使用起来也足够方便，为什么我们还要花费大力气去学习fetch？ 123451. 语法简洁，更加语义化2. 基于标准 Promise 实现，支持 async/await3. 同构方便，使用 [isomorphic-fetch](https://github.com/matthew-andrews/isomorphic-fetch)4.更加底层，提供的API丰富（request, response）5.脱离了XHR，是ES规范里新的实现方式 axioVue2.0之后，尤雨溪推荐大家用axios替换JQuery ajax，想必让axios进入了很多人的目光中。axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，本质上也是对原生XHR的封装，只不过它是Promise的实现版本，符合最新的ES规范，它本身具有以下特征：1.从浏览器中创建 XMLHttpRequest2.支持 Promise API3.客户端支持防止CSRF4.提供了一些并发请求的接口（重要，方便了很多的操作）5.从 node.js 创建 http 请求6.拦截请求和响应7.转换请求和响应数据8.取消请求9.自动转换JSON数据 总结：axios既提供了并发的封装，也没有fetch的各种问题，而且体积也较小，当之无愧现在最应该选用的请求的方式。 babel的工作原理babel是一个转译器，感觉相对于编译器compiler，叫转译器transpiler更准确，因为它只是把同种语言的高版本规则翻译成低版本规则，而不像编译器那样，输出的是另一种更低级的语言代码。 但是和编译器类似，babel的转译过程也分为三个阶段：parsing、transforming、generating，以ES6代码转译为ES5代码为例，babel转译的具体过程如下： ES6代码输入 ==》 babylon进行解析 ==》 得到AST ==》 plugin用babel-traverse对AST树进行遍历转译 ==》 得到新的AST树 ==》 用babel-generator通过AST树生成ES5代码 此外，还要注意很重要的一点就是，babel只是转译新标准引入的语法，比如ES6的箭头函数转译成ES5的函数；而新标准引入的新的原生对象，部分原生对象新增的原型方法，新增的API等（如Proxy、Set等），这些babel是不会转译的。需要用户自行引入polyfill来解决]]></content>
      <categories>
        <category>前端知识点总结</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中移物联网一面面经]]></title>
    <url>%2F2020%2F06%2F30%2F%E4%B8%AD%E7%A7%BB%E7%89%A9%E8%81%94%E7%BD%91%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F%2F</url>
    <content type="text"><![CDATA[js闭包 闭包就是能够读取其他函数内部变量的函数。例如在javascript中，只有函数内部的子函数才能读取局部变量，所以闭包可以理解成“定义在一个函数内部的函数“。在本质上，闭包是将函数内部和函数外部连接起来的桥梁。 作用：1.一个函数可以访问另一个函数作用域下的变量；2. 参数和变量不会被垃圾回收机制回收 闭包的应用：模仿块级作用域。2、保存外部函数的变量。3、封装私有变量 跨域 jsonp cors nginx document.domain window.name 页面渲染重绘重排原型链_proto_和prototype vue中methods和computed区别见官网地址：https://cn.vuejs.org/v2/api/#methods 参考文章：https://blog.csdn.net/u011565547/article/details/104875919 垃圾回收机制 引用计数 标记清除]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>中移物联网面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[腾讯暑期实习面经]]></title>
    <url>%2F2020%2F06%2F29%2F%E8%85%BE%E8%AE%AF%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E9%9D%A2%E7%BB%8F%2F</url>
    <content type="text"><![CDATA[一面 小引 面试官问了我问什么网站和博客这些都是用的lanxiangc2，我说这是我的网名兰香川川，他以为我和那个蓝翔有啥关系，O(∩_∩)O哈哈~，被面试官关注到了我的个人网站和作品 真的超开心，努力没白费，继续加油哦~ 深拷贝和浅拷贝问题 答得不太好，之前没有好好总结，反思ing 123456789101112131415161718192021222324252627282930313233343536373839404142//写一下深拷贝吧//对象var obj = &#123; a: '1', b: '2', c: &#123; name: 'hlc', age: 23 &#125;&#125;//使用拓展运算符 不能复制第二层var newObj = [...obj]//使用JSON对象 不能复制对象里边的方法var newObj2 = JSON.parse(JSON.stingify(obj))//使用assign() 经过试验方法可以深拷贝，对象不行，只能拷贝到第一层var newObj3 = Object.assign(&#123;&#125;, obj)// 直接使用var newObj = Object.create(oldObj)，也不能解决多层深拷贝var newObj4 = Object.create(obj)//数组var arr = [1,3,4,5,6]//slice() 多层嵌套时为浅拷贝//concat() 多层嵌套时为浅拷贝//JSON.stringify JSON.parse//Object.assign([], arr) 多层嵌套时为浅拷贝//for in 递归实现深层的深拷贝var deepCopy = function (obj) &#123; if (typeof obj !== 'object') return; var newobj = obj instanceof Array ? []: &#123;&#125;; for (var key in obj)&#123; if (obj.hasOwnProperty(key))&#123; newobj[key] = typeof obj[key] === 'object' ? deepCopy(obj[key]) : obj[key] &#125; &#125; return newobj&#125; 性能优化 打开你的个人博客 有些页面会很卡这是什么原因？ 我回答了说是因为买的腾讯云，哈哈只是开个玩笑，面试官也笑了 切回正题吧，说说我前端的问题 也答得不太好，因为一紧张就忘了，只说了，css和js阻塞的问题，没有深入说，挺尴尬的。应该从以下几方面去回答： 缓存利用 请求数量 请求带宽 JavaScript代码 HTML代码 CSS代码 输入一个url到看到网页经历了什么过程TCP三次握手、四次挥手算法题 判断是否是回文，输入：12321，返回：true；输入：sfdgdfs，返回：false；输入：23321，输出：false 手写深浅拷贝（洗个澡回来就忘了，emmmm，后边想起来了再更新吧~) Node Js与JavaScript的区别及nodejs优缺点1.原生js运行文件依赖于浏览器； 2.nodejs运行文件的时候服务为终端； 3.原生js有兼容性问题，nodejs不存在兼容性问题； 4.nodejs可以进行本地的读写，服务器搭建，连接数据库等，而原生js无法做到。 nodejs的优点：在项目中相当于中间层的使用 缺点：不适合大量的运算 二面老鼠试毒药问题 没回答好，难受啊。┭┮﹏┭┮ 先看懂这个3只老鼠来确定8个瓶子哪个瓶子里有毒，每个瓶子的水可以混合（混合后毒性不减，老鼠会立刻死亡），每只老鼠只能实验一次。 3个老鼠确定8个瓶子，每个瓶子编号转化为二进制如下，每一列代表水的混合情况。 000=0 001=1 010=2 011=3 100=4 101=5 110=6 111=7每一列表示一个老鼠，0-7表示8个瓶子。也就是分别将1、3、5、7号瓶子的药混起来给老鼠1吃，2、3、6、7号瓶子的药混起来给老鼠2吃，4、5、6、7号瓶子的药混起来给老鼠3吃，哪个老鼠死了，相应的位标为1。如老鼠1死了、老鼠2没死、老鼠3死了，那么就是101=5号瓶子有毒。 同样道理10个老鼠可以确定1000个瓶子 。根据2^10=1024，所以10个老鼠可以确定1000个瓶子具体哪个瓶子有毒。 找字符串中的子串 最最基础的操作字符串的题，结果…很呆呆 以为挂了，撸主郁闷了一整天结果晚上收到了三面的通知，有点小惊喜 三面]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>腾讯面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端知识点总结——JavaScript(3)]]></title>
    <url>%2F2020%2F06%2F25%2F%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94JavaScript-3%2F</url>
    <content type="text"><![CDATA[js判断类型判断方法：typeof()，instanceof，Object.prototype.toString.call()等。 在JavaScript里使用typeof判断数据类型，只能区分基本类型，即：number、string、undefined、boolean、object。 对于null、array、function、object来说，使用typeof都会统一返回object字符串。 要想区分对象、数组、函数、单纯使用typeof是不行的。在JS中，可以通过Object.prototype.toString方法，判断某个对象之属于哪种内置类型。分为null、string、boolean、number、undefined、array、function、object、date、math。 判断基本类型 12345Object.prototype.toString.call(null); // "[object Null]"Object.prototype.toString.call(undefined); // "[object Undefined]"Object.prototype.toString.call(“abc”);// "[object String]"Object.prototype.toString.call(123);// "[object Number]"Object.prototype.toString.call(true);// "[object Boolean]" 判断原生引用类型 123456789101112131415161718192021//**函数类型**Function fn()&#123; console.log(“test”);&#125;Object.prototype.toString.call(fn); // "[object Function]"//**日期类型**var date = new Date();Object.prototype.toString.call(date); // "[object Date]"//**数组类型**var arr = [1,2,3];Object.prototype.toString.call(arr); // "[object Array]"//**正则表达式**var reg = /[hbc]at/gi;Object.prototype.toString.call(reg); // "[object RegExp]"//**自定义类型**function Person(name, age) &#123; this.name = name; this.age = age;&#125;var person = new Person("Rose", 18);Object.prototype.toString.call(arr); // "[object Object]" 事件代理在捕获阶段的实际应用可以在父元素层面阻止事件向子元素传播，也可代替子元素执行某些操作 去除字符串首尾空格使用正则(^\s)|(\s$)即可 能来讲讲JS的语言特性吗运行在客户端浏览器上； 不用预编译，直接解析执行代码； 是弱类型语言，较为灵活； 与操作系统无关，跨平台的语言； 脚本语言、解释性语言； JavaScript脚本语言具有以下特点: 脚本语言 JavaScript是一种解释型的脚本语言,C、C++等语言先编译后执行,而JavaScript是在程序的运行过程中逐行进行解释。 基于对象 JavaScript是一种基于对象的脚本语言,它不仅可以创建对象,也能使用现有的对象。 简单 JavaScript语言中采用的是弱类型的变量类型,对使用的数据类型未做出严格的要求,是基于Java基本语句和控制的脚本语言,其设计简单紧凑。 动态性 JavaScript是一种采用事件驱动的脚本语言,它不需要经过Web服务器就可以对用户的输入做出响应。在访问一个网页时,鼠标在网页中进行鼠标点击或上下移、窗口移动等操作JavaScript都可直接对这些事件给出相应的响应。 跨平台性 JavaScript脚本语言不依赖于操作系统,仅需要浏览器的支持。因此一个JavaScript脚本在编写后可以带到任意机器上使用,前提上机器上的浏览器支 持JavaScript脚本语言,目前JavaScript已被大多数的浏览器所支持。不同于服务器端脚本语言，例如PHP与ASP，JavaScript主要被作为客户端脚本语言在用户的浏览器上运行，不需要服务器的支持。所以在早期程序员比较青睐于JavaScript以减少对服务器的负担，而与此同时也带来另一个问题：安全性。而随着服务器的强壮，虽然程序员更喜欢运行于服务端的脚本以保证安全，但JavaScript仍然以其跨平台、容易上手等优势大行其道。同时，有些特殊功能（如AJAX）必须依赖Javascript在客户端进行支持。随着引擎如V8和框架如Node.js的发展，及其事件驱动及异步IO等特性，JavaScript逐渐被用来编写服务器端程序。 js全排列1234567891011121314151617function permutate(str) &#123; var result = []; if(str.length &gt; 1) &#123; var left = str[0]; var rest = str.slice(1, str.length); var preResult = permutate(rest); for(var i=0; i&lt;preResult.length; i++) &#123; for(var j=0; j&lt;preResult[i].length; j++) &#123; var tmp = preResult[i].slice(0, j) + left + preResult[i].slice(j, preResult[i].length); result.push(tmp); &#125; &#125; &#125; else if (str.length == 1) &#123; return [str]; &#125; return result;&#125; null == undefined为什么要比较相等性之前，不能将null 和 undefined 转换成其他任何值，但 null == undefined 会返回 true 。ECMAScript规范中是这样定义的。 暂停死区在代码块内，使用let、const命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区” 编程题满足以下条件 Hero(“37er”);执行结果为 Hi! This is 37er Hero(“37er”).kill(1).recover(30)；执行结果为 Hi! This is 37er Kill 1 bug Recover 30 bloods Hero(“37er”).sleep(10).kill(2) 。执行结果为 Hi! This is 37er //等待10s后 Kill 2 bugs //注意为bugs （双斜线后的为提示信息，不需要打印） 12345678910111213141516171819202122232425function Hero(name)&#123; let o=new Object(); o.name=name; o.time=0; console.log("Hi! This is "+o.name); o.kill=function(bugs) &#123; if(bugs==1)&#123; console.log("Kill "+(bugs)+" bug"); &#125;else &#123; setTimeout(function () &#123; console.log("Kill " + (bugs) + " bugs"); &#125;, 1000 * this.time); &#125; return o; &#125;; o.recover=function (bloods) &#123; console.log("Recover "+(bloods)+" bloods"); return o; &#125; o.sleep=function (sleepTime) &#123; o.time=sleepTime; return o; &#125; return o;&#125; 写一个函数，第一秒打印1，第二秒打印2两个方法，第一个是用let块级作用域 12345for(let i=0;i&lt;5;i++)&#123; setTimeout(function()&#123; console.log(i) &#125;,1000*i)&#125; 第二个方法闭包 1234567for(var i=0;i&lt;5;i++)&#123; (function(i)&#123; setTimeout(function()&#123; console.log(i) &#125;,1000*i) &#125;)(i)&#125; 什么是事件监听addEventListener()方法，用于向指定元素添加事件句柄，它可以更简单的控制事件，语法为 element.addEventListener(event, function, useCapture); 第一个参数是事件的类型(如 “click” 或 “mousedown”)。 第二个参数是事件触发后调用的函数。 第三个参数是个布尔值用于描述事件是冒泡还是捕获。该参数是可选的。 事件传递有两种方式，冒泡和捕获。 事件传递定义了元素事件触发的顺序，如果你将P元素插入到div元素中，用户点击P元素， 在冒泡中，内部元素先被触发，然后再触发外部元素， 捕获中，外部元素先被触发，在触发内部元素 写一个newBind函数，完成bind的功能bind（）方法，创建一个新函数，当这个新函数被调用时，bind（）的第一个参数将作为它运行时的this，之后的一序列参数将会在传递的实参前传入作为它的参数 作用 函数的bind方法用于将函数体内的this绑定到某个对象，然后返回一个新函数。 //bind 相比于call apply this 都等于 obj; bind是产生一个新的函数 不执行,call apply 立即执行 Fn.bind(obj, arg1, arg2,…); Fn.bind(obj) //新的函数 function () { [native code] } 看不到 Fn.bind(obj) (); //执行函数 类似：a=function(){}; 执行 a(); 一个道理 1234567891011// 定义这个方法为myBindFunction.prototype.myBind = function(thisArg) &#123; if (typeof this !== 'function') &#123; return; &#125; var _self = this; var args = Array.prototype.slice.call(arguments, 1) //从第二个参数截取 return function() &#123; return _self.apply(thisArg, args.concat(Array.prototype.slice.call(arguments))); // 注意参数的处理 &#125;&#125; 有了解过事件模型吗，DOM0级和DOM2级有什么区别，DOM的分级是什么JSDOM事件流存在如下三个阶段： 事件捕获阶段 处于目标阶段 事件冒泡阶段 JSDOM标准事件流的触发的先后顺序为：先捕获再冒泡，点击DOM节点时，事件传播顺序：事件捕获阶段，从上往下传播，然后到达事件目标节点，最后是冒泡阶段，从下往上传播 DOM节点添加事件监听方法addEventListener，中参数capture可以指定该监听是添加在事件捕获阶段还是事件冒泡阶段，为false是事件冒泡，为true是事件捕获，并非所有的事件都支持冒泡，比如focus，blur等等，我们可以通过event.bubbles来判断 事件模型有三个常用方法： event.stopPropagation:阻止捕获和冒泡阶段中，当前事件的进一步传播， event.stopImmediatePropagetion，阻止调用相同事件的其他侦听器， event.preventDefault，取消该事件（假如事件是可取消的）而不停止事件的进一步传播， event.target：指向触发事件的元素，在事件冒泡过程中这个值不变 event.currentTarget = this，时间帮顶的当前元素，只有被点击时目标元素的target才会等于currentTarget， 最后，对于执行顺序的问题，如果DOM节点同时绑定了两个事件监听函数，一个用于捕获，一个用于冒泡，那么两个事件的执行顺序真的是先捕获在冒泡吗，答案是否定的，绑定在被点击元素的事件是按照代码添加顺序执行的，其他函数是先捕获再冒泡 区别绑定按钮的onclick赋值为一个函数就是DOM0级的，但是onclick多次赋值不同函数，最后也会被后面的函数覆盖掉；而DOM2级利用提供的addEventListener方法监听按钮的click事件，多次写监听同一个事件，函数会被依次执行的，不会被覆盖。 分级DOM 1级（DOM Level 1）于1998年10月成为 W3C 的推荐标准，DOM1级由两个模块组成：DOM核心（DOM Core）和 DOM HTML，DOM Core 能映射以XML为基础的文档结构，允许获取和操作文档的任意部分，而DOM HTML 通过添加 HTML 专用的对象与函数对 DOM Core 进行了扩展。简单说，DOM1级就是映射文档结构和提供基本的文档操作方法。 DOM2级，就是对DOM1级进行扩展，2级DOM通过对象接口增加对鼠标和用户界面事件、范围、遍历和重叠样式表（CSS）的支持。同时也对DOM1进行了扩展，从而可支持XML命名空间。简单来说，DOM2级就是在DOM1的基础上增加了视图、事件、样式、遍历和范围的接口，和支持XML命名空间。 DOM3级，在前面DOM基础上，引入了以统一方式加载和保存文档的方法，新增了验证文档的方法，同时也对DOM核心进行了扩展，开始支持XML1.0规范。 js字符串转数字的方法通过函数parseInt（），可解析一个字符串，并返回一个整数，语法为parseInt（string ,radix） string：被解析的字符串 radix：表示要解析的数字的基数，默认是十进制，如果radix&lt;2或&gt;36,则返回NaN 跨域【策略一】：Jsonp:需要目标服务器配合一个callback函数JSONP(JSON with Padding)是一个非官方的协议，它允许在服务器端集成Script tags返回至客户端，通过javascript callback的形式实现跨域访问（这仅仅是JSONP简单的实现形式）。Json+padding（内填充），顾名思义，就是把JSON填充到一个盒子里，它的基本思想是，网页通过添加一个&lt;script&gt;元素，向服务器请求JSON数据，这种做法不受同源政策限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。首先，网页动态插入&lt;script&gt;元素，由它向跨源网址发出请求。 【策略二】基于iframe实现的跨子域：通过修改document.domain来跨子域12将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行跨域主域相同的使用document.domain 【策略三】PHP设置header头来实现跨域promisePromise是异步编程的一种解决方案，从语法上来说promise是一个什么对象，他可以获取异步操作的消息；从本意上来说，它是承诺，承诺过一段时间给你一个结果。 Promise是一个对象，保存着未来将要结束的事件，她有两个特征: 1、对象的状态不受外部影响，Promise对象代表一个异步操作，有三种状态，pending进行中，fulfilled已成功，rejected已失败，只有异步操作的结果，才可以决定当前是哪一种状态，任何其他操作都无法改变这个状态，这也就是promise名字的由来 2、一旦状态改变，就不会再变，promise对象状态改变只有两种可能，从pending改到fulfilled或者从pending改到rejected，只要这两种情况发生，状态就凝固了，不会再改变，这个时候就称为定型resolved 说说C++，Java，JavaScript这三种语言的区别从静态类型还是动态类型来看静态类型，编译的时候就能够知道每个变量的类型，编程的时候也需要给定类型，如Java中的整型int，浮点型float等。C、C++、Java都属于静态类型语言。 动态类型，运行的时候才知道每个变量的类型，编程的时候无需显示指定类型，如JavaScript中的var、PHP中的$。JavaScript、Ruby、Python都属于动态类型语言。 静态类型还是动态类型对语言的性能有很大影响。 对于静态类型，在编译后会大量利用已知类型的优势，如int类型，占用4个字节，编译后的代码就可以用内存地址加偏移量的方法存取变量，而地址加偏移量的算法汇编很容易实现。 对于动态类型，会当做字符串通通存下来，之后存取就用字符串匹配。 从编译型还是解释型来看编译型语言，像C、C++，需要编译器编译成本地可执行程序后才能运行，由开发人员在编写完成后手动实施。用户只使用这些编译好的本地代码，这些本地代码由系统加载器执行，由操作系统的CPU直接执行，无需其他额外的虚拟机等。 源代码=》抽象语法树=》中间表示=》本地代码 解释性语言，像JavaScript、Python，开发语言写好后直接将代码交给用户，用户使用脚本解释器将脚本文件解释执行。对于脚本语言，没有开发人员的编译过程，当然，也不绝对。 源代码=》抽象语法树=》解释器解释执行。 对于JavaScript，随着Java虚拟机JIT技术的引入，工作方式也发生了改变。可以将抽象语法树转成中间表示（字节码），再转成本地代码，如JavaScriptCore，这样可以大大提高执行效率。也可以从抽象语法树直接转成本地代码，如V8 Java语言，分为两个阶段。首先像C++语言一样，经过编译器编译。和C++的不同，C++编译生成本地代码，Java编译后，生成字节码，字节码与平台无关。第二阶段，由Java的运行环境也就是Java虚拟机运行字节码，使用解释器执行这些代码。一般情况下，Java虚拟机都引入了JIT技术，将字节码转换成本地代码来提高执行效率。 注意，在上述情况中，编译器的编译过程没有时间要求，所以编译器可以做大量的代码优化措施。 对于JavaScript与Java它们还有的不同：对于Java，Java语言将源代码编译成字节码，这个同执行阶段是分开的。也就是从源代码到抽象语法树到字节码这段时间的长短是无所谓的。 对于JavaScript，这些都是在网页和JavaScript文件下载后同执行阶段一起在网页的加载和渲染过程中实施的，所以对于它们的处理时间有严格要求。 js原型链，原型链的顶端是什么？Object的原型是什么？Object的原型的原型是什么？在数组原型链上实现删除数组重复数据的方法什么是js的闭包？有什么作用，用闭包写个单例模式闭包的本质就是在一个函数内部创建另一个函数。闭包=函数+函数能够访问的自由变量 作用：1.一个函数可以访问另一个函数作用域下的变量；2. 参数和变量不会被垃圾回收机制回收 闭包的应用：模仿块级作用域。2、保存外部函数的变量。3、封装私有变量 （1）什么是闭包： 闭包是指有权访问另外一个函数作用域中的变量的函数。 闭包就是函数的局部变量集合，只是这些局部变量在函数返回后会继续存在。闭包就是就是函数的“堆栈”在函数返回后并不释放，我们也可以理解为这些函数堆栈并不在栈上分配而是在堆上分配。当在一个函数内定义另外一个函数就会产生闭包。 （2）为什么要用： 匿名自执行函数：我们知道所有的变量，如果不加上var关键字，则默认的会添加到全局对象的属性上去，这样的临时变量加入全局对象有很多坏处，比如：别的函数可能误用这些变量；造成全局对象过于庞大，影响访问速度(因为变量的取值是需要从原型链上遍历的)。除了每次使用变量都是用var关键字外，我们在实际情况下经常遇到这样一种情况，即有的函数只需要执行一次，其内部变量无需维护，可以用闭包。 结果缓存：我们开发中会碰到很多情况，设想我们有一个处理过程很耗时的函数对象，每次调用都会花费很长时间，那么我们就需要将计算出来的值存储起来，当调用这个函数的时候，首先在缓存中查找，如果找不到，则进行计算，然后更新缓存并返回值，如果找到了，直接返回查找到的值即可。闭包正是可以做到这一点，因为它不会释放外部的引用，从而函数内部的值可以得以保留。 promise+Generator+Async的使用Promise解决的问题: 回调地狱 Promise规范: promise有三种状态，等待（pending）、已完成（fulfilled/resolved）、已拒绝（rejected）.Promise的状态只能从“等待”转到“完成”或者“拒绝”，不能逆向转换，同时“完成”和“拒绝”也不能相互转换。 promise 必须提供一个 then方法以访问其当前值、终值和据因。promise.then(resolve, reject),resolve 和 reject都是可选参数。如果 resolve 或reject 不是函数，其必须被忽略。 then 方法必须返回一个 promise 对象。 使用: 实例化promise对象需要传入函数(包含两个参数),resolve和reject,内部确定状态.resolve和reject函数可以传入参数在回调函数中使用.resolve和reject都是函数,传入的参数在then的回调函数中接收. 1var promise = newPromise(function(resolve, reject) &#123;setTimeout(function()&#123; then接收两个函数,分别对应resolve和reject状态的回调,函数中接收实例化时传入的参数. 12345promise.then(val=&gt;&#123;//resolved&#125;,reason=&gt;&#123;//rejected&#125;) catch相当于.then(null, rejection)当then中没有传入rejection时,错误会冒泡进入catch函数中,若传入了rejection,则错误会被rejection捕获,而且不会进入catch.此外,then中的回调函数中发生的错误只会在下一级的then中被捕获,不会影响该promise的状态. // 错误示例 123456789new Promise((resolve,reject)=&gt;&#123; resolve('正常');&#125;).then((val)=&gt;&#123; throw new Error('回调函数中错误')&#125;,(err)=&gt;&#123; console.log(err,1);&#125;).then(null,(err)=&gt;&#123; console.log(err,2);//此处捕获,也可用catch&#125;); 一个错误捕获的错误用例:该函数调用中即使发生了错误依然会进入then中的resolve的回调函数,因为函数p1中实例化promise对象时已经调用了catch,若发生错误会进入catch中,此时会返回一个新的promise,因此即使发生错误依然会进入p1函数的then链中的resolve回调函数. Promise回调链: promise能够在回调函数里面使用 return 和 throw， 所以在then中可以return出一个promise对象或其他值，也可以throw出一个错误对象，但如果没有return，将默认返回 undefined，那么后面的then中的回调参数接收到的将是undefined. 1234567891011121314151617181920function p1(val)&#123; return new Promise((resolve,reject)=&gt;&#123; val==1?resolve(1):reject() &#125;)&#125;;function p2(val)&#123; return new Promise((resolve,reject)=&gt;&#123; val==2?resolve(2):reject(); &#125;)&#125;;let promimse = new Promise(function(resolve,reject)&#123; resolve(1)&#125;).then(function(data1) &#123; return p1(data1)//如果去掉return,则返回undefined而不是p1的返回值,会导致报错&#125;).then(function(data2)&#123; return p2(data2+1)&#125;).then(res=&gt;console.log(res)) Generatorgenerator函数使用: 分段执行，可以暂停 可以控制阶段和每个阶段的返回值 可以知道是否执行到结尾 1234567891011function* g() &#123;var o = 1;yield o++;yield o++;&#125;var gen = g();console.log(gen.next()); // Object &#123;value: 1, done: false&#125;var xxx = g();console.log(gen.next()); // Object &#123;value: 2, done: false&#125;console.log(xxx.next()); // Object &#123;value: 1, done: false&#125;console.log(gen.next()); // Object &#123;value: undefined, done: true&#125; generator和异步控制:利用Generator函数的暂停执行的效果，可以把异步操作写在yield语句里面，等到调用next方法时再往后执行。这实际上等同于不需要写回调函数了，因为异步操作的后续操作可以放在yield语句下面，反正要等到调用next方法时再执行。所以，Generator函数的一个重要实际意义就是用来处理异步操作，改写回调函数。 async和异步用法: async 表示这是一个async函数，await只能用在这个函数里面。 await 表示在这里等待异步操作返回结果，再继续执行。 await 后一般是一个promise对象 示例:async用于定义一个异步函数，该函数返回一个Promise。如果async函数返回的是一个同步的值，这个值将被包装成一个理解resolve的Promise，等同于return Promise.resolve(value)。 await用于一个异步操作之前，表示要“等待”这个异步操作的返回值。await也可以用于一个同步的值。 1234567891011121314151617181920let timer = async function timer()&#123; return new Promise((resolve,reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve('500'); &#125;,500); &#125;);&#125;timer().then(result =&gt; &#123; console.log(result); //500&#125;).catch(err =&gt; &#123; console.log(err.message);&#125;);//返回一个同步的值let sayHi = async function sayHi()&#123; let hi = await 'hello world'; return hi; //等同于return Promise.resolve(hi);&#125;sayHi().then(result =&gt; &#123; console.log(result);&#125;); 事件委托以及冒泡原理事件委托是利用冒泡阶段的运行机制来实现的，就是把一个元素响应事件的函数委托到另一个元素，一般是把一组元素的事件委托到他的父元素上，委托的优点是 减少内存消耗，节约效率 动态绑定事件 减少事件绑定 事件冒泡就是元素自身的事件被触发后，如果父元素有相同的事件，如onclick事件，那么元素本身的触发状态就会传递，也就是冒到父元素，父元素的相同事件也会一级一级根据嵌套关系向外触发，直到document/window，冒泡过程结束。 深浅拷贝的区别和实现数组的浅拷贝： 如果是数组，我们可以利用数组的一些方法，比如slice，concat方法返回一个新数组的特性来实现拷贝，但假如数组嵌套了对象或者数组的话，使用concat方法克隆并不完整，如果数组元素是基本类型，就会拷贝一份，互不影响，而如果是对象或数组，就会只拷贝对象和数组的引用，这样我们无论在新旧数组进行了修改，两者都会发生变化，我们把这种复制引用的拷贝方法称为浅拷贝， 深拷贝就是指完全的拷贝一个对象，即使嵌套了对象，两者也互相分离，修改一个对象的属性，不会影响另一个 如何深拷贝一个数组 1、这里介绍一个技巧，不仅适用于数组还适用于对象！那就是： 123var arr = ['old', 1, true, ['old1', 'old2'], &#123;old: 1&#125;]var new_arr = JSON.parse( JSON.stringify(arr) );console.log(new_arr); 原理是JOSN对象中的stringify可以把一个js对象序列化为一个JSON字符串，parse可以把JSON字符串反序列化为一个js对象，通过这两个方法，也可以实现对象的深复制。 但是这个方法不能够拷贝函数 浅拷贝的实现以上三个方法concat,slice ,JSON.stringify都是技巧类，根据实际项目情况选择使用，我们可以思考下如何实现一个对象或数组的浅拷贝，遍历对象，然后把属性和属性值都放在一个新的对象里即可 深拷贝的实现那如何实现一个深拷贝呢？说起来也好简单，我们在拷贝的时候判断一下属性值的类型，如果是对象，我们递归调用深拷贝函数不就好了~ 12345678910var deepCopy = function(obj) &#123; if (typeof obj !== 'object') return; var newObj = obj instanceof Array ? [] : &#123;&#125;; for (var key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; newObj[key] = typeof obj[key] === 'object'? deepCopy(obj[key]) : obj[key]; &#125; &#125; return newObj;&#125; JS中string的startwith和indexof两种方法的区别startsWith() 方法用于检测字符串是否以指定的子字符串开始。如果是以指定的子字符串开头返回 true，否则 false。startsWith() 方法对大小写敏感。 string.startsWith(searchvalue, start) searchvalue必需，要查找的字符串。start可选，查找的开始位置，默认为 0。 Indexof()函数，indexof函数可返回某个指定字符串在字符串中首次出现的位置 如何渲染一个十几万条的大数据显示到页面上参考：https://www.cnblogs.com/ldld/p/11028179.html 1234567891011121314151617181920212223242526272829setTimeout(() =&gt; &#123; // 插入十万条数据 const total = 100000 // 一次插入 * 条，如果觉得性能不好就减少 const once = 200 // 渲染数据总共需要几次 const loopCount = total / once let countOfRender = 0 let ul = document.querySelector("ul"); function add() &#123; // 优化性能，插入不会造成回流 const fragment = document.createDocumentFragment(); for (let i = 0; i &lt; once; i++) &#123; const li = document.createElement("li"); // li.innerText = Math.floor(Math.random() * total); li.innerText = `这里是第 $&#123;countOfRender&#125; 次的 li $&#123;i&#125;`; fragment.appendChild(li); &#125; ul.appendChild(fragment); countOfRender += 1; loop(); &#125; function loop() &#123; if (countOfRender &lt; loopCount) &#123; window.requestAnimationFrame(add); &#125; &#125; loop();&#125;, 0); 如何阻止事件冒泡event.stopPropagation();事件处理过程中，阻止了事件冒泡，但不会阻击默认行为（执行超链接的跳转） return false事件处理过程中，阻止了事件冒泡，也阻止了默认行为（不执行超链接的跳转）还有一种与冒泡有关的： event.preventDefault()事件处理过程中，不阻击事件冒泡，但阻击默认行为（它只执行所有弹框，却没有执行超链接跳转） 参考：https://www.cnblogs.com/surui/tag/JS/ base64Base64是网络上最常见的用于传输8Bit字节码的编码方式之一，Base64就是一种基于64个可打印字符来表示二进制数据的方法。可查看RFC2045～RFC2049，上面有MIME的详细规范。 Base64编码是从二进制到字符的过程，可用于在HTTP环境下传递较长的标识信息。采用Base64编码具有不可读性，需要解码后才能阅读。 Base64由于以上优点被广泛应用于计算机的各个领域，然而由于输出内容中包括两个以上“符号类”字符（+, /, =)，不同的应用场景又分别研制了Base64的各种“变种”。为统一和规范化Base64的输出，Base62x被视为无符号化的改进版本。]]></content>
      <categories>
        <category>前端知识点总结</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端知识点总结——JavaScript(2)]]></title>
    <url>%2F2020%2F06%2F18%2F%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94JavaScript-2%2F</url>
    <content type="text"><![CDATA[原型链 &spades;&spades;&spades;见纸质版笔记 this &spades;&spades;&spades;this是JavaScript的一个关键字，随着函数使用场合的不同，this的值会发生变化。但是有一个原则，即this指向的是调用函数的那个对象。this是全局对象Global，可以作为方法调用 this作为构造函数执行this 指向创建出来的实例 1234567var name = 'zl'function test()&#123; this.name = 'hlc' console.log(this.name);&#125;var o = new test();//可以看出o代表的不是全局对象 this作为对象方法（属性）执行this 指代上级对象 / 指向调用该方法的对象 123456789var x =3;function test()&#123; alert(this.x);&#125;var o = &#123; x:1, m:test &#125;;o.m(); // 1 作为普通函数执行this 指代全局对象 12345function test()&#123; this.x = 1; //这里this就是window console.log(this.x);&#125;test(); // 1 call、apply、bindthis指代上下文对象 / 同时也是改变this指向的方法 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 在JavaScript中，this指针是在创建时，由系统默认生成的两个隐式参数之一（另一个是arguments）。 this指针指向与该函数调用进行隐式关联的一个对象，该对象被称为“函数上下文”。 this的几种指向： 通过事件调用，this-&gt;事件 自调用函数，this-&gt;window 构造函数中，this-&gt;new出来的对象 箭头函数，this-&gt;创建函数时指向的对象 call和apply，this-&gt;call和apply第一个参数 JS多位数字每隔三位加一个逗号(千分位格式化)123456789function toThousands(num) &#123; var num = (num || 0).toString(), result = ''; while (num.length &gt; 3) &#123; result = ',' + num.slice(-3) + result; num = num.slice(0, num.length - 3); &#125; if (num) &#123; result = num + result; &#125; return result;&#125; TypeScript有了解吗 TypeScript是一种由微软开发的开源、跨平台的编程语言。它是JavaScript的超集，最终会被编译为JavaScript代码。TypeScript添加了可选的静态类型系统、很多尚未正式发布的ECMAScript新特性（如装饰器 ）。2012年10月，微软发布了首个公开版本的TypeScript，2013年6月19日，在经历了一个预览版之后微软正式发布了正式版TypeScript。当前最新版本为TypeScript3.8。 JavaScript 与 TypeScript 的区别TypeScript 是 JavaScript 的超集，扩展了 JavaScript 的语法，因此现有的 JavaScript 代码可与 TypeScript 一起工作无需任何修改，TypeScript 通过类型注解提供编译时的静态类型检查。 TypeScript 可处理已有的 JavaScript 代码，并只对其中的 TypeScript 代码进行编译。 TypeScript 可以使用 JavaScript 中的所有代码和编码概念，TypeScript 是为了使 JavaScript 的开发变得更加容易而创建的。例如，TypeScript 使用类型和接口等概念来描述正在使用的数据，这使开发人员能够快速检测错误并调试应用程序 TypeScript 从核心语言方面和类概念的模塑方面对 JavaScript 对象模型进行扩展。JavaScript 代码可以在无需任何修改的情况下与 TypeScript 一同工作，同时可以使用编译器将 TypeScript 代码转换为 JavaScript。TypeScript 通过类型注解提供编译时的静态类型检查。TypeScript 中的数据要求带有明确的类型，JavaScript不要求。TypeScript 为函数提供了缺省参数值。TypeScript 引入了 JavaScript 中没有的“类”概念。TypeScript 中引入了模块的概念，可以把声明、数据、函数和类封装在模块中。 闭包是什么？有什么用处 &spades;&spades;&spades;一句话可以概括：闭包就是能够读取其他函数内部变量的函数，或者子函数在外调用，子函数所在的父函数的作用域不会被释放 12345678910function hello () &#123; var num = 100; return function () &#123; console.log(num) num++ &#125;&#125;var f = hello()f() // 执行结果 打印101f() // 执行结果 打印102 闭包内部的的变量会存在，而闭包内部函数的内部变量不会存在，使得JavaScript的垃圾回收机制不会收回hello()占用的资源，因为hello()内部中函数执行需要依赖hello()中的变量 闭包的两个作用 闭包不仅可以取到外层函数中的局部变量 还可以将值保存在内存中 优点有利于封装（实现类和继承等）；可访问局部变量； 避免全局变量的污染；私有成员的存在 ； 缺点内存占用浪费严重，容易产生内存泄漏 总结谨慎使用 创建对象的方式 优缺点 &spades;字面式声明123var obj = &#123;&#125; //字面式声明obj.name = xxxx;obj.age = xxxx; 缺点:只能创建一次对象，复用性较差，如果要创建多个对象，代码冗余度太高 new操作符+object声明123var obj = new Object() //new操作符+object声明obj.name = xxxx;obj.age = xxxx; 缺点:只能创建一次对象，复用性较差，如果要创建多个对象，代码冗余度太高 完全没有必要用new Object(),而应该采用对象字面量{}的方式进行声明 构造函数声明12345function test (age, name) &#123; //构造函数声明 this.age = age this.name = name&#125;var obj = new test() 优点：实例可以识别为一个特定的类型 缺点：每次创建实例时，每个方法都要被创建一次。构造函数中定义函数，那么每次创建对象，都会重新创建该函数，这样会导致全局变量增多，造成污染,代码结构会混乱,不易维护 工厂方式声明对象12345678910function createObject (name, age) &#123;//工厂方式声明对象 var obj = new Object(); obj.name = name; obj.age = age; obj.run = function () &#123; return this.name + this.age &#125; return obj&#125;var obj1 = createObj('zhangsan', 100) 缺点：对象无法识别，因为所有的实例都指向一个原型 原型模式声明12345678//原型模式声明function test () &#123; test.prototype.属性名称 = 属性值; test.prototype.方法名称 = function () &#123; //函数执行体 &#125;&#125;var obj = new test() 优点：方法不会重新创建。构造函数的原型对象中的成员，可以被该构造函数创建出来的所有对象访问,而且，所有的对象共享该对象,所以，我们可以将构造函数中需要创建的函数，放到原型对象中存储,这样就解决 全局变量污染的问题 以及 代码结构混乱的问题 缺点：1. 所有的属性和方法都共享 2. 不能初始化参数 混合式声明对象123456789//混合式声明对象function test (参数1, 参数2) &#123; this.属性名称 = 参数1; this.属性名称 = 参数2;&#125;test.prototype.方法名称 = function () &#123; //执行代码&#125;var obj = new test() 优点：该共享的共享，该私有的私有，使用最广泛的方式 缺点：有的人就是希望全部都写在一起，即更好的封装性 moveenter和moveover参考地址：https://www.jianshu.com/p/2f9c3c765459 mouseover：当鼠标移入元素或其子元素都会触发事件，所以有一个重复触发，冒泡的过程。对应的移除事件是mouseout mouseenter：当鼠标移除元素本身（不包含元素的子元素）会触发事件，也就是不会冒泡，对应的移除事件是mouseleave clientHeight，scrollHeight，offsetHeight，以及clientTop，scrollTop，offsetTop的区别参考文章：https://blog.csdn.net/dongdaxiaopenyou/article/details/82458329 clientHeight，scrollHeight，offsetHeightclientHeight: 可理解为内部可视区高度，样式的height+上下padding scrollHeight: 内容的实际高度+上下padding（如果没有限制div的height，即height是自适应的，一般是scrollHeight==clientHeight） offsetHeight:可理解为div的可视高度，样式的height+上下padding+上下border-width。 clientTop，scrollTop，offsetTopclientTop: 容器内部相对于容器本身的top偏移，实际就是 上border-width scrollTop: Y轴的滚动条没有，或滚到最上时，是0；y轴的滚动条滚到最下时是 scrollHeight-clientHeight（很好理解） offsetTop: 容器到其包含块顶部的距离，粗略的说法可以理解为其父元素。 offsetTop = top + margin-top + border-top js拖拽功能的实现在实现基本的效果之前，有几点需要说明的： 元素想要被拖动，它的postion属性一定要是relative或absolute 通过event.clientX和event.clientY获取鼠标的坐标 onmousemove是绑定在document元素上而不是拖拽元素本身，这样能解决快速拖动造成的延迟或停止移动的问题 常见的拖拽操作是什么样的呢？整过过程大概有下面几个步骤： 1、用鼠标点击被拖拽的元素 2、按住鼠标不放，移动鼠标 3、拖拽元素到一定位置，放开鼠标 这里的过程涉及到三个dom事件：onmousedown，onmousemove，onmouseup。 所以拖拽的基本思路就是： 用鼠标点击被拖拽的元素触发onmousedown 设置当前元素的可拖拽为true，表示可以拖拽 记录当前鼠标的坐标x,y 记录当前元素的坐标x,y 移动鼠标触发onmousemove 判断元素是否可拖拽，如果是则进入步骤2，否则直接返回 如果元素可拖拽，则设置元素的坐标 元素的x坐标 = 鼠标移动的横向距离+元素本来的x坐标 = 鼠标现在的x坐标 - 鼠标之前的x坐标 + 元素本来的x坐标 元素的y坐标 = 鼠标移动的横向距离+元素本来的y坐标 = 鼠标现在的y坐标 - 鼠标之前的y坐标 + 元素本来的y坐标 放开鼠标触发onmouseup 将鼠标的可拖拽状态设置成false 答案二 首先是三个事件，分别是mousedown，mousemove，mouseup 当鼠标点击按下的时候，需要一个tag标识此时已经按下，可以执行mousemove里面的具体方法。 clientX，clientY标识的是鼠标的坐标，分别标识横坐标和纵坐标，并且我们用offsetX和offsetY来表示元素的元素的初始坐标，移动的举例应该是： 鼠标移动时候的坐标-鼠标按下去时候的坐标。 也就是说定位信息为： 鼠标移动时候的坐标-鼠标按下去时候的坐标+元素初始情况下的offetLeft. 还有一点也是原理性的东西，也就是拖拽的同时是绝对定位，我们改变的是绝对定位条件下的left以及top等等值 补充：也可以通过html5的拖放（Drag 和 drop）来实现 异步加载JS方案一&lt;script&gt;标签的async=”async”属性（详细参见：script标签的async属性） HTML5中新增的属性，Chrome、FF、IE9&amp;IE9+均支持（IE6~8不支持）。此外，这种方法不能保证脚本按顺序执行。 HTML5属性仅适用于外部脚本，并且如果在IE中，同时存在defer和async，那么defer的优先级比较高，脚本将在页面完成时执行。兼容所有浏览器。此外，这种方法可以确保所有设置defer属性的脚本按顺序执行。 方案二&lt;script&gt;标签的defer=”defer”属性 只支持IE如果您的脚本不会改变文档的内容，可将 defer 属性加入到&lt;script&gt;标签中，以便加快处理文档的速度。因为浏览器知道它将能够安全地读取文档的剩余部分而不用执行脚本，它将推迟对脚本的解释，直到文档已经显示给用户为止。 方案三动态创建&lt;script&gt;标签示例： 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script type="text/javascript"&gt;(function()&#123;var s = document.createElement('script');s.type = 'text/javascript';s.src = "http://code.jquery.com/jquery-1.7.2.min.js";var tmp = document.getElementsByTagName('script')[0];tmp.parentNode.insertBefore(s, tmp);&#125;)();&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;img src="http://xybtv.com/uploads/allimg/100601/48-100601162913.jpg" /&gt;&lt;/body&gt;&lt;/html&gt; 兼容所有浏览器。 方案四AJAX eval（使用AJAX得到脚本内容，然后通过eval(xmlhttp.responseText)来运行脚本）兼容所有浏览器 方案五iframe方式（这里可以参照：iframe异步加载技术及性能 中关于Meboo的部分）兼容所有浏览器。 Ajax解决浏览器缓存问题 在一些项目中，一般提交请求都会通过ajax来提交，测试时发现，每次提交后得到的数据都是一样的，经过调试，发现问题发现在前端，没有清理缓存，所以得到的还是原来的旧数据。而我们都知道ajax能提高页面载入的速度主要的原因是通过ajax减少了重复数据的载入，也就是说在载入数据的同时将数据缓存到内存中，一旦数据被加载其中，只要我们没有刷新页面，这些数据就会一直被缓存在内存中，当我们提交 的URL与历史的URL一致时，就不需要提交给服务器，也就是不需要从服务器上面去获取数据，虽然这样降低了服务器的负载提高了用户的体验，但是我们不能获取最新的数据。为了保证我们读取的信息都是最新的，我们就需要禁止他的缓存功能。 禁止浏览器缓存功能有如下几种方法： 在ajax发送请求前加上 anyAjaxObj.setRequestHeader(&quot;If-Modified-Since&quot;,&quot;0&quot;) 在ajax发送请求前加上 anyAjaxObj.setRequestHeader(&quot;Cache-Control&quot;,&quot;no-cache&quot;) 在URL后面加上一个随机数： &quot;fresh=&quot; + Math.random() 在URL后面加上时间搓：&quot;nowtime=&quot; + new Date().getTime() 如果是使用jQuery，直接这样就可以了 $.ajaxSetup({cache:false})。这样页面的所有ajax都会执行这条语句就是不需要保存缓存记录。 JS中的垃圾回收机制必要性：由于字符串、对象和数组没有固定大小，所有当他们的大小已知时，才能对他们进行动态的存储分配。JavaScript程序每次创建字符串、数组或对象时，解释器都必须分配内存来存储那个实体。只要像这样动态地分配了内存，最终都要释放这些内存以便他们能够被再用，否则，JavaScript的解释器将会消耗完系统中所有可用的内存，造成系统崩溃。 这段话解释了为什么需要系统需要垃圾回收，JS不像C/C++，他有自己的一套垃圾回收机制（Garbage Collection）。JavaScript的解释器可以检测到何时程序不再使用一个对象了，当他确定了一个对象是无用的时候，他就知道不再需要这个对象，可以把它所占用的内存释放掉了。例如： 123var a=&quot;hello world&quot;;var b=&quot;world&quot;;var a=b; //这时，会释放掉”hello world”，释放内存以便再引用 垃圾回收的方法：标记清除、计数引用。 标记清除这是最常见的垃圾回收方式，当变量进入环境时，就标记这个变量为”进入环境“,从逻辑上讲，永远不能释放进入环境的变量所占的内存，永远不能释放进入环境变量所占用的内存，只要执行流程进入相应的环境，就可能用到他们。当离开环境时，就标记为离开环境。 垃圾回收器在运行的时候会给存储在内存中的变量都加上标记（所有都加），然后去掉环境变量中的变量，以及被环境变量中的变量所引用的变量（条件性去除标记），删除所有被标记的变量，删除的变量无法在环境变量中被访问所以会被删除，最后垃圾回收器，完成了内存的清除工作，并回收他们所占用的内存。 引用计数法另一种不太常见的方法就是引用计数法，引用计数法的意思就是每个值没引用的次数，当声明了一个变量，并用一个引用类型的值赋值给该变量，则这个值的引用次数为1；相反的，如果包含了对这个值引用的变量又取得了另外一个值，则原先的引用值引用次数就减1，当这个值的引用次数为0的时候，说明没有办法再访问这个值了，因此就把所占的内存给回收进来，这样垃圾收集器再次运行的时候，就会释放引用次数为0的这些值。 用引用计数法会存在内存泄露，下面来看原因： 123456function problem() &#123;var objA = new Object();var objB = new Object();objA.someOtherObject = objB;objB.anotherObject = objA;&#125; 在这个例子里面，objA和objB通过各自的属性相互引用，这样的话，两个对象的引用次数都为2，在采用引用计数的策略中，由于函数执行之后，这两个对象都离开了作用域，函数执行完成之后，因为计数不为0，这样的相互引用如果大量存在就会导致内存泄露。 特别是在DOM对象中，也容易存在这种问题： 1234var element=document.getElementById（''）;var myObj=new Object();myObj.element=element;element.someObject=myObj; 这样就不会有垃圾回收的过程。 eval是做什么的它的功能是将对应的字符串解析成js并执行，应该避免使用，因为非常消耗性能（2次，一次解析成js，一次执行） 1234eval("x=10;y=20;document.write(x*y)")document.write(eval("2+2"))var x=10document.write(eval(x+17)) 如何理解前端模块化前端模块化就是复杂的文件编程一个一个独立的模块，比如js文件等等，分成独立的模块有利于重用（复用性）和维护（版本迭代），这样会引来模块之间相互依赖的问题，所以有了commonJS规范，AMD，CMD规范等等，以及用于js打包（编译等处理）的工具webpack 说一下Commonjs、AMD和CMD一个模块是能实现特定功能的文件，有了模块就可以方便的使用别人的代码，想要什么功能就能加载什么模块。 Commonjs：开始于服务器端的模块化，同步定义的模块化，每个模块都是一个单独的作用域，模块输出modules.exports，模块加载require()引入模块 AMD：中文名异步模块定义的意思。 requireJS实现了AMD规范，主要用于解决下述两个问题。 1.多个文件有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器 2.加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应的时间越长。 语法：requireJS定义了一个函数define，它是全局变量，用来定义模块。 requireJS的例子： //定义模块 123456789define([&apos;dependency&apos;], function()&#123;var name = &apos;Byron&apos;;function printName()&#123;console.log(name);&#125;return &#123;printName: printName&#125;;&#125;); //加载模块 123require([&apos;myModule&apos;], function (my)&#123;my.printName();&#125; requirejs定义了一个函数define,它是全局变量，用来定义模块： define(id?dependencies?,factory) 在页面上使用模块加载函数： require([dependencies],factory)； 总结AMD规范：require（）函数在加载依赖函数的时候是异步加载的，这样浏览器不会失去响应，它指定的回调函数，只有前面的模块加载成功，才会去执行。因为网页在加载js的时候会停止渲染，因此我们可以通过异步的方式去加载js,而如果需要依赖某些，也是异步去依赖，依赖后再执行某些方法。 实现一个once函数，传入函数参数只执行一次12345678910function ones(func)&#123; var tag=true; return function()&#123; if(tag==true)&#123; func.apply(null,arguments); tag=false; &#125; return undefined &#125;&#125; js监听对象属性的改变我们假设这里有一个user对象, (1)在ES5中可以通过Object.defineProperty来实现已有属性的监听 1234Object.defineProperty(user,'name',&#123; set：function(key,value)&#123; &#125;&#125;) 缺点：如果id不在user对象中，则不能监听id的变化 (2)在ES6中可以通过Proxy来实现 1234var user = new Proxy(&#123;&#125;，&#123; set：function(target,key,value,receiver)&#123; &#125;&#125;) 这样即使有属性在user中不存在，通过user.id来定义也同样可以这样监听这个属性的变化哦~ 如何实现一个私有变量，用getName方法可以访问，不能直接访问(1)通过defineProperty来实现 123456789obj=&#123;name:yuxiaoliang, getName:function()&#123; return this.name &#125;&#125;object.defineProperty(obj,"name",&#123;//不可枚举不可配置&#125;); (2)通过函数的创建形式 1234567function product()&#123; var name='yuxiaoliang'; this.getName=function()&#123; return name;&#125;&#125;var obj=new product() ===和==区别 ===：称为等同符，当两边值的类型相同时，直接比较值，若类型不相同，直接返回false； ==：称为等值符，当等号两边的类型相同时，直接比较值是否相等，若不相同，则先转化为类型相同的值，再进行比较； 什么情况用===1234if (obj.a == null) &#123; //这里是相当于obj.a === null || obj.a === undefined 的简写形式 // 这是jQuery源码中的推荐的写法&#125; 其他情况都用=== object.is(1) == “ “==0 //true “0”==0 //true “ “ !=”0” //true 123==”123” //true null==undefined //true (2)Object.is 主要的区别就是+0 != -0 而NaN==NaN(相对比===和==的改进) setTimeout、setInterval和requestAnimationFrame之间的区别这里有一篇文章讲的是requestAnimationFrame：http://www.cnblogs.com/xiaohuochai/p/5777186.html 与setTimeout和setInterval不同，requestAnimationFrame不需要设置时间间隔， RAF采用的是系统时间间隔，不会因为前面的任务，不会影响RAF，但是如果前面的任务多的话，会响应setTimeout和setInterval真正运行时的时间间隔。 特点：（1）requestAnimationFrame会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率。 （2）在隐藏或不可见的元素中，requestAnimationFrame将不会进行重绘或回流，这当然就意味着更少的CPU、GPU和内存使用量 （3）requestAnimationFrame是由浏览器专门为动画提供的API，在运行时浏览器会自动优化方法的调用，并且如果页面不是激活状态下的话，动画会自动暂停，有效节省了CPU开销。 window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行 注意：若你想在浏览器下次重绘之前继续更新下一帧动画，那么回调函数自身必须再次调用window.requestAnimationFrame() 当你准备更新动画时你应该调用此方法。这将使浏览器在下一次重绘之前调用你传入给该方法的动画函数(即你的回调函数)。回调函数执行次数通常是每秒60次，但在大多数遵循W3C建议的浏览器中，回调函数执行次数通常与浏览器屏幕刷新次数相匹配。为了提高性能和电池寿命，因此在大多数浏览器里，当requestAnimationFrame() 运行在后台标签页或者隐藏的&lt;iframe&gt;里时，requestAnimationFrame() 会被暂停调用以提升性能和电池寿命。 自己构造一个bind函数原理：通过apply或者call方法来实现。 (1)初始版本 12345678Function.prototype.bind=function(obj,arg)&#123; var arg=Array.prototype.slice.call(arguments,1); var context=this; return function(newArg)&#123; arg=arg.concat(Array.prototype.slice.call(newArg)); return context.apply(obj,arg); &#125;&#125; Array.prototype.slice.call(arguments,1)该语句涉及两个知识点。 arguments是一个关键字，代表当前参数，在javascript中虽然arguments表面上以数组形式来表示，但实际上没有原生数组slice的功能，这里使用call方法算是对arguments对象不完整数组功能的修正。 slice返回一个数组，该方法只有一个参数的情况下表示除去数组内的第一个元素。就本上下文而言，原数组的第一个参数是“事件名称”，具体像“click”,”render”般的字符串，其后的元素才是处理函数所接纳的参数列表。 (2) 考虑到原型链 为什么要考虑？因为在new 一个bind过生成的新函数的时候，必须的条件是要继承原函数的原型 12345678Function.prototype.bind=function(obj,arg)&#123; var arg=Array.prototype.slice.call(arguments,1); var context=this; var bound=function(newArg)&#123; arg=arg.concat(Array.prototype.slice.call(newArg)); return context.apply(obj,arg);&#125;var F=function()&#123;&#125; //这里需要一个寄生组合继承 123F.prototype=context.prototype;bound.prototype=new F();return bound 用setTimeout来实现setInterval但是通常情况下，很少真正使用间歇调用，因为后一个间歇调用可能在前一个间歇调用结束之前调用 重复定时器的规则有两个问题：1.某些间隔会被跳过 2.多个定时器的代码执行时间可能会比预期小。 12345function say()&#123;//somethingsetTimeout(say,200);&#125;setTimeout(say,200) 或者 1234setTimeout(function()&#123;//do somethingsetTimeout(arguments.callee,200);&#125;,200); js怎么控制一次加载一张图片，加载完后再加载下一张(1)方法1 123456789&lt;script type="text/javascript"&gt;var obj=new Image();obj.src="http://www.phpernote.com/uploadfiles/editor/201107240502201179.jpg";obj.onload=function()&#123; //alert('图片的宽度为：'+obj.width+'；图片的高度为：'+obj.height); document.getElementById("mypic").innnerHTML="&lt;img src='"+this.src+"' /&gt;";&#125;&lt;/script&gt;&lt;div id="mypic"&gt;onloading……&lt;/div&gt; (2)方法2 1234567891011&lt;script type="text/javascript"&gt;var obj=new Image();obj.src="http://www.phpernote.com/uploadfiles/editor/201107240502201179.jpg";obj.onreadystatechange=function()&#123; if(this.readyState=="complete")&#123; //alert('图片的宽度为：'+obj.width+'；图片的高度为：'+obj.height); document.getElementById("mypic").innnerHTML="&lt;img src='"+this.src+"' /&gt;"; &#125;&#125;&lt;/script&gt;&lt;div id="mypic"&gt;onloading……&lt;/div&gt; 代码的执行顺序12345678setTimeout(function()&#123;console.log(1)&#125;,0);new Promise(function(resolve,reject)&#123; console.log(2); resolve();&#125;).then(function()&#123;console.log(3)&#125;).then(function()&#123;console.log(4)&#125;);process.nextTick(function()&#123;console.log(5)&#125;);console.log(6); //输出2,6,5,3,4,1 script(主程序代码)——&gt;process.nextTick——&gt;promise——&gt;setTimeout 为什么呢？具体请参考我的文章：从promise、process.nextTick、setTimeout出发，谈谈Event Loop中的Job queue 如何实现sleep的效果（es5或者es6）(1)while循环的方式 123456function sleep(ms)&#123;var start=Date.now(),expire=start+ms;while(Date.now() &gt; expire); console.log('1111'); return;&#125; 执行sleep(1000)之后，休眠了1000ms之后输出了1111。上述循环的方式缺点很明显，容易造成死循环。 (2)通过promise来实现 123456789function sleep(ms)&#123; var temple=new Promise(resolve=&gt;&#123; console.log(111);setTimeout(resolve,ms) &#125;); return temple&#125;sleep(500).then(function()&#123;//console.log(222)&#125;) //先输出了111，延迟500ms后输出222 (3)通过async封装 123456789function sleep(ms)&#123; return new Promise((resolve)=&gt;setTimeout(resolve,ms));&#125;async function test()&#123; var temple=await sleep(1000); console.log(1111) return temple&#125;test(); //延迟1000ms输出了1111 (4).通过generate来实现 1234567function* sleep(ms)&#123; yield new Promise(function(resolve,reject)&#123; console.log(111); setTimeout(resolve,ms); &#125;)&#125;sleep(500).next().value.then(function()&#123;console.log(2222)&#125;) 怎样获取当前对象的原型对象prototype使用 Object.getPrototypeOf(); 12345678function Person(name)&#123; this.name = name;&#125;var lilei = new Person("Lilei");Object.getPrototypeOf(lilei); // &#123;constructor: ƒ&#125;lilei.constructor.prototype; // &#123;constructor: f&#125; 简单实现Node的Events模块简介：观察者模式或者说订阅模式，它定义了对象间的一种一对多的关系，让多个观察者对象同时监听某一个主题对象，当一个对象发生改变时，所有依赖于它的对象都将得到通知。 node中的Events模块就是通过观察者模式来实现的： 123456var events=require('events');var eventEmitter=new events.EventEmitter();eventEmitter.on('say',function(name)&#123; console.log('Hello',name);&#125;)eventEmitter.emit('say','Jony yu'); 这样，eventEmitter发出say事件，通过On接收，并且输出结果，这就是一个订阅模式的实现，下面我们来简单的实现一个Events模块的EventEmitter。 (1)实现简单的Event模块的emit和on方法 12345678910111213141516171819function Events()&#123; this.on=function(eventName,callBack)&#123; if(!this.handles)&#123; this.handles=&#123;&#125;; &#125; if(!this.handles[eventName])&#123; this.handles[eventName]=[]; &#125; this.handles[eventName].push(callBack); &#125; this.emit=function(eventName,obj)&#123; if(this.handles[eventName])&#123; for(var i=0; i &lt; this.handles[eventName].length; i++)&#123; this.handles[eventName][i](obj); &#125; &#125; &#125; return this;&#125; 这样我们就定义了Events，现在我们可以开始来调用： 12345var events=new Events();events.on('say',function(name)&#123; console.log('Hello',name)&#125;);events.emit('say','Jony yu'); //结果就是通过emit调用之后，输出了hello Jony yu (2)每个对象是独立的 因为是通过new的方式，每次生成的对象都是不相同的，因此： 12345678910var event1=new Events();var event2=new Events();event1.on('say',function()&#123; console.log('Jony event1');&#125;);event2.on('say',function()&#123; console.log('Jony event2');&#125;)event1.emit('say');event2.emit('say'); //event1、event2之间的事件监听互相不影响 //输出结果为’Jony event1’ ‘Jony event2’ 箭头函数中this指向举例1234567var a=11;function test2()&#123; this.a=22; let b=()=&gt;&#123;console.log(this.a)&#125; b();&#125;var x=new test2(); //输出22 定义时绑定。]]></content>
      <categories>
        <category>前端知识点总结</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序开发]]></title>
    <url>%2F2020%2F06%2F14%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[开发文档https://developers.weixin.qq.com/miniprogram/dev/framework/ 全局配置小程序根目录下的 app.json 文件用来对微信小程序进行全局配置。文件内容为一个 JSON 对象， 每一个小程序页面也可以使用 .json 文件来对本页面的窗口表现进行配置。页面中配置项在当前页面会覆盖 app.json 的 window 中相同的配置项。文件内容为一个 JSON 对象，有以下属性： 页面配置微信现已开放小程序内搜索，开发者可以通过 sitemap.json 配置，或者管理后台页面收录开关来配置其小程序页面是否允许微信索引。当开发者允许微信索引时，微信会通过爬虫的形式，为小程序的页面内容建立索引。当用户的搜索词条触发该索引时，小程序的页面将可能展示在搜索结果中。 爬虫访问小程序内页面时，会携带特定的 user-agent：mpcrawler 及场景值：1129。需要注意的是，若小程序爬虫发现的页面数据和真实用户的呈现不一致，那么该页面将不会进入索引中。 setmap配置小程序根目录下的 sitemap.json 文件用于配置小程序及其页面是否允许被微信索引，文件内容为一个 JSON 对象，如果没有 sitemap.json ，则默认为所有页面都允许被索引；sitemap.json 有以下属性：]]></content>
      <categories>
        <category>web前端技术学习</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端知识点总结——webapp和小程序]]></title>
    <url>%2F2020%2F06%2F13%2F%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94webapp%E5%92%8C%E5%B0%8F%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[移动端布局固定布局固定布局是第一次做移动端时最好的选择方式,思路沿用PC端,上手比较快。在标签里把 viewport 加好,然后设想整个网页的宽度为 320px 即可。 其他地方根据 PC 端来布局。 缺点:大屏手机显示网页比较宽,固定布局宽度参照永远是 320px,导致左右两 边会有空白。 流动布局流动布局与固定宽度布局基本不同点就在于对网站尺寸的测量单位不同，流动布局就是使用百分比来代替px作为单位。 优点是流动布局可以很好解决自适应需求。缺点是不够灵活，添加元素时，需要更改其他元素的值。 bootstrap布局bootstrap是一个比较流行的响应式前端框架，利用bootstrap的栅格系统可以实现响应式的移动端布局。栅格系统：Bootstrap中定义了一套响应式的网格系统，其使用方式就是将一个容器划分成12列，然后通过col-xx-xx的类名控制每一列的占比， 在使用的时候，我们给相应的div设置col-lg-2 col-md-3 col-sm-4 col-xs-6，以此完成布局。 媒体查询+REM布局使用媒体查询可以根据不同的设备宽度加载不同的css样式。rem是一个相对单位，会根据根节点的字体大小来计算的，使用媒体查询和rem可以实现移动端的响应式。 改变meta中的缩放比例改变缩放比例，进行布局，类似于上一种方式，不过上一种是根据设备宽高对根元素进行font-size的动态改变，这种方式则是通过改变meta种缩放比例，来进行动态改变页面的 这里有一个点需要说明 ，像素比 window.devicePixelRatio = 设备像素/css像素 flex布局Flexbox是CSS3引入的新的布局模式，也称为弹性布局，他会根据页面的剩余宽度自动分配空间。 它决定了元素如何在页面上排列，使它们能在不同的屏幕尺寸和设备下可预测地展现出来。它能够扩展和收缩 flex 容器内的元素， 以最大限度地填充可用空间。Flexbox布局最适合应用程序的组件和小规模的布局，而网格布局更适合那些更大规模的布局。 响应式布局vh/vw移动端和PC端的区别？ （1）PC考虑的是浏览器的兼容性，而移动端开发考虑的更多的是手机兼容性，因为目前不管是android手机还是ios手机，一般浏览器使用的都是webkit内核，所以说做移动端开发，更多考虑的应该是手机分辨率的适配，和不同操作系统的略微差异化。 （2）在部分事件的处理上，移动端多出来的事件是触屏事件，而缺少的是hover事件。 另外包括移动端弹出的手机键盘的处理，这样的问题在PC端都是遇不到的。 （3）在布局上，移动端开发一般是要做到布局自适应的，我使用的一直是rem布局，感觉很好。 （4）在动画处理上，PC端由于要考虑IE的兼容性，所以通常使用JS做动画的通用性会更好一些，但是CSS3做了很大的牺牲， 而在手机端，如果要做一些动画、特效等，第一选择肯定是CSS3， 既简单、效率又高。 （5）一般pc端用jquery，移动端用zepto，因为移动端的流量还是比较重要的， 所以引入的资源或者插件，能小则小，一个30k的资源和一个80k的资源，在移动端的差别还是挺大的。 （6）比如在手机上的300ms的延迟，这在PC端是没有的，如果我们希望做成webapp，那么自然就不需要这300ms的延迟，所以可以使用hammer-time.js来移除这300ms的延迟。 REM原理Rem布局原理rem布局的本质是什么？这是我问过很多人的一个问题，但得到的回答都差强人意。其实rem布局的本质是等比缩放，一般是基于宽度假设我们将屏幕宽度平均分成100份，每一份的宽度用x表示，x = 屏幕宽度 / 100，如果将x作为单位，x前面的数值就代表屏幕宽度的百分比 1234/* 作用于根元素，相对于原始大小（16px），所以html的font-size为32px*/html&#123;font-size:2rem&#125;/* 作用于非根元素，相对于根元素字体大小，所以为64px */p&#123;font-size:2rem&#125; 如果让html元素字体的大小，恒等于屏幕宽度的1/100，那1rem和1x就等价了 123html&#123;fons-size:width/100&#125;p&#123;width:50rem&#125;/* 50rem = 50x = 屏幕宽度的50% */ 如何让html字体大小一直等于屏幕宽度的百分之一呢？ 可以通过js来设置，一般需要在页面dom ready、resize和屏幕旋转中设置 1document.documentElement.style.fontSize=document.documentElement.clientWidth/100+'px'; 移动端一边框像素问题为什么会有这个问题为什么移动端CSS里面写了1px，实际上看起来比1px粗；了解设备物理像素和逻辑像素的同学应该很容易理解，其实这两个px的含义其实是不一样的，UI设计师要求的1px是指设备的物理像素1px，而CSS里记录的像素是逻辑像素，它们之间存在一个比例关系，可以用javascript中的window.devicePixelRatio来获取，也可以用媒体查询的-webkit-min-device-pixel-ratio来获取。当然，比例多少与设备相关。在手机上border无法达到我们想要的效果。这是因为devicePixelRatio特性导致，iPhone的devicePixelRatio==2，而border-width: 1px描述的是设备独立像素，所以，border被放大到物理像素2px显示，在iPhone上就显得较粗。 移动端开发常需要在html的header里添加如下一句：&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;&gt;这句话定义了本页面的viewport的宽度为设备宽度，初始缩放值和最大缩放值都为1，并禁止了用户缩放。 你的疑问可能来了，老是看到viewport，除了知道中文名叫视口，到底是啥意思？其实，它就是设备屏幕上能用来显示我们网页内容的那一块区域，具体点就是浏览器或app中的webview用来显示网页的那部分区域，但viewport又不局限于浏览器可视区域的大小，可能大也可能小。体现在用户是否缩放了屏幕。 心细的同学应该都有感觉，meta标签中常设置user-scalable=no也就是禁止用户缩放，那用户缩放到底会造成什么影响呢？ 其实也就是显示上的变化。缩放一倍，CSS像素(逻辑像素)所代表的物理像素也就缩放了一倍，即设备物理像素和设备独立像素的比例增大(减小)了一倍。 或许你已经明白1px变粗的原因是啥了， viewport的设置和屏幕物理分辨率是按比例而不是相同的. 移动端window对象有个devicePixelRatio属性, 它表示设备物理像素和css像素的比例, 在retina屏的iphone手机上, 这个值为2或3, css里写的1px长度映射到物理像素上就有2px或3px那么长。 如何解决1px问题媒体查询利用设备像素比缩放，设置小数像素1234567.border &#123; border: 1px solid #999 &#125;@media screen and (-webkit-min-device-pixel-ratio: 2) &#123; .border &#123; border: 0.5px solid #999 &#125;&#125;@media screen and (-webkit-min-device-pixel-ratio: 3) &#123; .border &#123; border: 0.333333px solid #999 &#125;&#125; 【缺点】对设备有要求，小数像素目前兼容性较差。 viewport + rem 方案 该方案是对上述方案的优化，整体思路就是利用viewport + rem + js 动态的修改页面的缩放比例，实现小于1像素的显示。在页面初始化时，在头部引入原始默认状态如下： 12&lt;meta http-equiv="Content-Type" content="text/html;charset=UTF-8"&gt; &lt;meta name="viewport" id="WebViewport" content="initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"&gt; 接下来的任务就是js的动态修改缩放比 以及 实现rem根元素字体大小的设置。 12345678910111213var viewport = document.querySelector("meta[name=viewport]")if (window.devicePixelRatio == 1) &#123; viewport.setAttribute('content', 'width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no')&#125; if (window.devicePixelRatio == 2) &#123; viewport.setAttribute('content', 'width=device-width, initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no')&#125; if (window.devicePixelRatio == 3) &#123; viewport.setAttribute('content', 'width=device-width, initial-scale=0.333333333, maximum-scale=0.333333333, minimum-scale=0.333333333, user-scalable=no')&#125; var docEl = document.documentElement;var fontsize = 10 * (docEl.clientWidth / 320) + 'px';docEl.style.fontSize = fontsize; 【缺点】以为缩放涉及全局的rem单位，比较适合新项目，对于老项目可能要涉及到比较多的改动。 设置 border-image 方案background-image 渐变实现box-shadow 方案transform: scale(0.5) 方案 - 推荐: 很灵活 参考地址：https://www.jianshu.com/p/fa670b737a29 微信小程序 尺寸单位rpx与px,rem相互转换 rpx :微信小程序开发中新出了尺寸单位rpx（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。 如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。 rem （root em）: 规定屏幕宽度为20rem；1rem = (750/20)rpx 。]]></content>
      <categories>
        <category>前端知识点总结</category>
      </categories>
      <tags>
        <tag>响应式布局</tag>
        <tag>小程序</tag>
        <tag>webapp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端知识点总结——AJAX和JSON]]></title>
    <url>%2F2020%2F06%2F13%2F%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94AJAX%E5%92%8CJSON%2F</url>
    <content type="text"><![CDATA[Ajax的流程Ajax通过XMLHttpRequest对象实现异步方式在后台发送发送请求。 主要有以下四个步骤： （1）初始化XMLHttpRequest对象。不同浏览器的差异，需要我们创建一个跨浏览器的对象，并判断XMLHttpRequest对象创建是否成功，如果不成功，则给予提示。 （2）为XMLHttpRequest对象指定一个回调函数，用于对后台返回结果进行处理。 （3）创建一个与服务器的连接，在创建时，需要指定发送请求的方式（GET/POST），以及设置是否采用异步方式发送请求。 （4）向服务器发送请求。 服务端向客户端主动发送消息Ajax轮询所谓的Ajax轮询，其实就是定时的通过Ajax查询服务端，客户端按规定时间定时像服务端发送ajax请求，服务器接到请求后马上返回响应信息并关闭连接。 这种技术方式实现起来非常简单，但是这种方式会有非常严重的问题，就是需要不断的向服务器发送消息询问，这种方式会对服务器造成极大的性能浪费。 还有一个类似的轮询是使用JSONP跨域请求的方式轮询，在实现起来有差别，但基本原理都是相同的，都是客户端不断的向服务器发起请求。 优点 实现简单。 缺点 这是通过模拟服务器发起的通信，不是实时通信，不顾及应用的状态改变而盲目检查更新，导致服务器资源的浪费，且会加重网络负载，拖累服务器。 CometComet，基于 HTTP 长连接的 “服务器推” 技术，能使服务器端主动以异步的方式向客户端程序推送数据，而不需要客户端显式的发出请求，目前有两种实现方式： 基于 AJAX 的长轮询（long-polling）方式 Ajax 的出现使得 JavaScript 可以调用 XMLHttpRequest 对象发出 HTTP 请求，JavaScript 响应处理函数根据服务器返回的信息对 HTML 页面的显示进行更新。使用 AJAX 实现 “服务器推” 与传统的 AJAX 应用不同之处在于： 服务器端会阻塞请求直到有数据传递或超时才返回。 客户端 JavaScript 响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接。 当客户端处理接收的数据、重新建立连接时，服务器端可能有新的数据到达；这些信息会被服务器端保存直到客户端重新建立连接，客户端会一次把当前服务器端所有的信息取回。 基于长轮询的服务器推模型 相对于”轮询”（poll），这种长轮询方式也可以称为”拉”（pull）。因为这种方案基于 AJAX，具有以下一些优点：请求异步发出；无须安装插件；IE、Mozilla FireFox 都支持 AJAX。 长轮询 (long polling) 是在打开一条连接以后保持并等待服务器推送来数据再关闭，可以采用HTTP长轮询和XHR长轮询两种方式: (1) HTTP 和JSONP方式的长轮询把 script 标签附加到页面上以让脚本执行。服务器会挂起连接直到有事件发生，接着把脚本内容发送回浏览器，然后重新打开另一个 script 标签来获取下一个事件，从而实现长轮询的模型。 (2) XHR长轮询这种方式是使用比较多的长轮询模式。 客户端打开一个到服务器端的 AJAX 请求然后等待响应；服务器端需要一些特定的功能来允许请求被挂起，只要一有事件发生，服务器端就会在挂起的请求中送回响应并关闭该请求。客户端 JavaScript 响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接；如此循环。 现在浏览器已经支持CROS的跨域方式请求，因此HTTP和JSONP的长轮询方式是慢慢被淘汰的一种技术，建议采用XHR长轮询。 优点 客户端很容易实现良好的错误处理系统和超时管理，实现成本与Ajax轮询的方式类似。 缺点 需要服务器端有特殊的功能来临时挂起连接。当客户端发起的连接较多时，服务器端会长期保持多个连接，具有一定的风险。 基于 Iframe 及 htmlfile 的流（streaming）方式 iframe 是很早就存在的一种 HTML 标记， 通过在 HTML 页面里嵌入一个隐蔵帧，然后将这个隐蔵帧的 SRC 属性设为对一个长连接的请求，服务器端就能源源不断地往客户端输入数据。 基于流方式的服务器推模型 Comet的优缺点 优点： 实时性好（消息延时小）；性能好（能支持大量用户）缺点： 长期占用连接，丧失了无状态高并发的特点。 websocket方式WebSocket是HTML5开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。WebSocket通讯协议于2011年被IETF定为标准RFC 6455，WebSocketAPI被W3C定为标准。在WebSocket API中，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。 WebSocket是一种在单个TCP连接上进行全双工通信的协议。WebSocket通信协议于2011年被IETF定为标准RFC 6455，并由RFC7936补充规范。WebSocket API也被W3C定为标准。 WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。 axiosaxios是什么？ 他是一个封装好的http请求库，他是基于es6的promise机制实现的。 浏览器基于XMLHttpRequest对象封装的，跟Ajax一样，只不过他们开放的API使用有差别而已； axios的特点有哪些？ 支持pormise的所有API 支持服务端与客户端使用 支持配置实例默认值和拦截器。（一般一个前端项目我们只需要配置一个axios实例，所以实例默认值理解成全局默认值可能更好理解。比如请求地址的前缀，和统一的错误处理；） 支持防御CSRF跨站攻击 （把token加在http请求头自定义属性里，服务端配合使用） 他不支持JSONP方式 axios有哪些常用方法 axios.get get请求；axios.put put请求；axios.post post请求 axios.delete请求；等等 axios.all 多个请求一起顺序同步请求。 axios相关配置属性 URL，baseUrl，method，headers，params(url参数)，data（请求体参数），auth,配置token axios的拦截器 通过axios.interceptors.request.use添加请求拦截器 通过axios.interceptors.respones.use添加响应拦截器 也可以为自定义实例添加 axios为什么既能在浏览器环境运行又能在服务器(node)环境运行？ 他在发送请求时会判断时如果XMLHttpRequest对象存在则使用客户端方式发送请求 否则判断process对象是否存在，存在则使用服务端方式发送请求。 参考：前端知识扫盲VUE知识篇三（axios知识）]]></content>
      <categories>
        <category>前端知识点总结</category>
      </categories>
      <tags>
        <tag>AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端知识点总结——正则表达式]]></title>
    <url>%2F2020%2F06%2F13%2F%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[正则表达式中?=和?:和?!的理解要理解?=和?!，首先需要理解前瞻，后顾，负前瞻，负后顾四个概念： 12345678// 前瞻：exp1(?=exp2) 查找exp2前面的exp1// 后顾：(?&lt;=exp2)exp1 查找exp2后面的exp1// 负前瞻：exp1(?!exp2) 查找后面不是exp2的exp1// 负后顾：(?&lt;!exp2)exp1 查找前面不是exp2的exp1 要理解?:则需要理解捕获分组和非捕获分组的概念： 12()表示捕获分组，()会把每个分组里的匹配的值保存起来，使用$n(n是一个数字，表示第n个捕获组的内容)(?:)表示非捕获分组，和捕获分组唯一的区别在于，非捕获分组匹配的值不会保存起来]]></content>
      <categories>
        <category>前端知识点总结</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端知识点总结——CSS]]></title>
    <url>%2F2020%2F06%2F13%2F%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94CSS%2F</url>
    <content type="text"><![CDATA[CSS的盒模型 怎么切换box-sizing:content-box这是W3C盒模型， width = content box-sizing:border-box这是width = border + padding + content 清除浮动导致的问题 父元素无法撑开 与元素同级的非浮动元素会紧随其后（类似遮盖现象） 如果一个元素浮动，则该元素之前的元素也需要浮动；否则， 会影响页面显示的结构（即通常所说的串行现象） 解决方法 为父元素设置固定高度 为父元素设置overflow: hidden，目的是让父元素的高度被撑开 用clear：both样式属性 外墙法，指在父元素外面添加“一堵墙”，设置属性clear:both 内墙法，指在父元素内部，浮动元素的最后边添加”一堵墙“，设置属性clear:both 伪元素是指为了少创建元素，对父元素添加after伪元素，设置属性content:&quot;&quot;;display:block;clear: both 使用通用类clearfix，clearfix的实现如下： 12345.clearfix:after&#123; content: ''; display: block; clear:both;&#125; 原理：触发了BFC块级格式化上下文：BFC(block formatting contexts) 照本宣科的定义看起来可能不大好理解，BFC是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。BFC元素特性表现原则就是，内部子元素再怎么翻江倒海，翻云覆雨都不会影响外部的元素。所以，避免margin穿透啊，清除浮动什么的也好理解了。 创建了新的BFC的盒子是独立布局的，盒子里边的子元素的样式不会影响到外边的元素。在同一个BFC中，两个毗邻的块级盒在垂直方向（和布局方向有关系）的margin会发生重叠 BFC决定元素如何对其内容进行布局，也决定与其他元素的关系和相互作用 形成BFC的常见条件 float不是none position是absolute或者fixed overflow不是visible display是flex 、inline-block等 @font-face 规则指定名为”myFirstFont”的字体，并指定在哪里可以找到它的URL： 123456@font-face&#123;font-family: myFirstFont;src: url('Sansation_Light.ttf'), url('Sansation_Light.eot'); /* IE9 */&#125; font-spider可以帮助压缩字体，只有内容使用字体才生效 transform有哪些值css动画，有没有做过动画垂直水平居中的实现块级元素margin： 0 auto (无绝对定位) 上下左右均为 0 ; position: absolute; margin: auto;（有决定定位属性） CSS3.0弹性布局12345body&#123; display: flex; align-items: center;/*定义body的元素垂直居中*/ justify-content: center;/*定义body的元素水平居中*/&#125; vertical-align:middle垂直方向居中。verical-align 定义行内元素的基线相对于该元素所在行的基线的垂直对齐。 行内元素text-align: center position（定位元素）12345position: absolute;top: 50%;left: 50%;margin-top: -50px; /*高度的一半*/margin-left: -50px; /宽度的一半*/ 缺点：需要提前知道元素的尺寸。如果不知道元素尺寸，这个时候就需要JS获取了。 CSS3.0的兴起，使这个问题有了更好的解决方法，就是使用 transform 代替 margin 。 transform 中 translate 偏移的百分比是相对于自身大小而说的。 1234position: absolute;top: 50%;left: 50%;transform: translate( -50%, -50%); 优点：无论绝对定位元素的尺寸是多少，它都是水平垂直居中显示的。 缺点：就是兼容性问题。 display:table实现12345678910.parent&#123; width: 300px; height: 300px; text-align: center; display: table;&#125;.son&#123; display: table-cell; vertical-align: middle;&#125; 相对定位12345678910.content&#123; width: 300px; height: 300px; background: orange; margin: 0 auto;/*水平居中*/ position: relative;/*设置position*/ top: 50%; /*偏移*/ /*margin-top: -150px;*/ /*第一种：margin-top*/ transform: translateY(-50%);/*第二种：transform：转换*/&#125; CSS渲染过程1、浏览器在接收到服务器返回的html页面后， 2、浏览器开始构建DOM树 DOM TREE,遇到CSS样式会构建CSS规则树 CSS RULE TREE, 3、遇到 javascript会通过 DOM API和CSSDOM API来操作DOM TREE和 CSS RuLe Tree， 4、浏览器引擎会通过DOM Tree和CSS Rule Tree，解析完成后， 5、最后，渲染树构建完成后就是“布局”处理，也就是确实每个节点在屏幕上的确切显示位置 6、下个步骤(渲染之后)，开始“绘制”，便利渲染树，并用UI后端层，将每一个节点绘制出来！ 规则css的渲染规则，是从上到下从左到右渲染的。 1.main h4 a &#123; font-size: 14px; &#125; 渲染过程是这样的：首先先找到所有的a，沿着a的父元素查找h4，然后在沿着h4，查找.main。中途找到了符合匹配规则的节点就加入结果集。如果找到根元素的html都没有匹配，则这条路径不在遍历。下一个a开始重复这个查找匹配，直至没有a继续查找。 浏览器的这种规则是为了尽早过滤掉一些无关的样式规则和元素。 浏览器渲染页面的过程从耗时的角度浏览器请求，加载，渲染一个页面，时间花在下面五件事情上： 1.DNS查询 2.TCP连接 3.HTTP请求即响应 4.服务器响应 5.客户端渲染这里讨论第五部分即浏览器对内容的渲染，这一部分(渲染树构建，布局及绘制)，又可以分为下面5个步骤 1.处理HTML标记并构建DOM树2.处理CSS标记并创建CSSOM树3.将DOM与CSSOM合并成一个渲染树4.根据渲染树来布局，以计算每个节点的几何信息5.将各个节点渲染到屏幕上需要明白，这五个步骤并不一定一次性顺序完成。如果 DOM 或 CSSOM 被修改，以上过程需要重复执行，这样才能计算出哪些像素需要在屏幕上进行重新渲染。实际页面中，CSS 与 JavaScript 往往会多次修改 DOM 和 CSSOM，下面就来看看它们的影响方式。 CSS和JavaScript阻塞谈论资源的阻塞时，我们要清楚，现在浏览器总是并行加载资源。例如当HTML解析器(HTML Parser)被脚本阻塞时，解析器虽然会停止构建DOM，但是仍会执行该脚本后面的资源，并进行预加载。 CSS 是阻塞渲染的资源。需要将它尽早、尽快地下载到客户端，以便缩短首次渲染的时间。 默认情况下，CSS 被视为阻塞渲染的资源，这意味着浏览器将不会渲染任何已处理的内容，直至 CSSOM 构建完毕。JavaScript 不仅可以读取和修改 DOM 属性，还可以读取和修改 CSSOM 属性。 存在阻塞的 CSS 资源时，浏览器会延迟 JavaScript 的执行和 DOM 构建。当浏览器遇到一个 script 标记时，DOM 构建将暂停，直至脚本完成执行。JavaScript 可以查询和修改 DOM 与 CSSOM。CSSOM 构建时，JavaScript 执行将暂停，直至 CSSOM 就绪。 所以，script 标签的位置很重要。实际使用时，可以遵循下面两个原则：CSS 优先：引入顺序上，CSS 资源先于 JavaScript 资源。JavaScript 应尽量少影响 DOM 的构建。 画一条0.5px的线采用meta viewport的方式 1&lt;meta name="viewport" content="initial-scale=1.0, maximum-scale=1.0, user-scalable=no" /&gt; 采用border-image的方式 采用transform: scale()的方式 1transform: scale(0.5,0.5); link标签和import标签的区别link属于html标签，而@import是css提供的 页面被加载时，link会同时被加载，而@import引用的css会等到页面加载结束后加载。 link是html标签，因此没有兼容性，而@import只有IE5以上才能识别。 link方式样式的权重高于@import的 transition和animation的区别Animation和transition大部分属性是相同的，他们都是随时间改变元素的属性值，他们的主要区别是transition需要触发一个事件才能改变属性，而animation不需要触发任何事件的情况下才会随时间改变属性值，并且transition为2帧，从from …. to，而animation可以一帧一帧的。 了解重绘和重排吗，知道怎么去减少重绘和重排吗，让文档脱离文档流有哪些方法重绘（repaint或redraw）：当盒子的位置、大小以及其他属性，例如颜色、字体大小等都确定下来之后，浏览器便把这些原色都按照各自的特性绘制一遍，将内容呈现在页面上。重绘是指一个元素外观的改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。 触发重绘的条件：改变元素外观属性。如：color，background-color等。 重排（重构/回流/reflow）：当渲染树中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建, 这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候。 注意：table及其内部元素可能需要多次计算才能确定好其在渲染树中节点的属性值，比同等元素要多花两倍时间，这就是我们尽量避免使用table布局页面的原因之一。 重绘和重排的关系：在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程称为重绘。所以，重排必定会引发重绘，但重绘不一定会引发重排。 DOM的变化影响到了元素的几何属性比如宽高，浏览器重新计算元素的几何属性，其他元素的几何属性也会受到影响，浏览器需要重新构造渲染树，这个过程称之为重排，浏览器将受到影响的部分重新绘制在屏幕上的过程称为重绘 原因重排发生的根本原理就是元素的几何属性发生了改变，那么我们就从能够改变元素几何属性的角度入手 添加或删除可见的DOM元素 元素位置改变 元素本身的尺寸发生改变 内容改变 页面渲染器初始化 浏览器窗口大小发生改变 重排一定导致重绘，重绘不一定导致重排 减少重绘重排的方法有 不在布局信息改变时做DOM查询，批量修改DOM 使用csstext,className一次性改变属性 使用fragment。重点就在于DocumentFragment 节点不属于文档树。因此当把创建的节点添加到该对象时，并不会导致页面的回流，因此性能就自然上去了 对于多次重排的元素，比如说动画。使用绝对定位脱离文档流，使其不影响其他元素 怎么脱离文档流 float absolute fixed 两个嵌套的div，position都是absolute，子div设置top属性，那么这个top是相对于父元素的哪个位置定位的。margin的内边缘，padding的外边缘（个人感觉和父元素是relative没啥区别） 相对布局和绝对布局，position:relative和obsolute相对定位relative如果对一个元素进行相对定位，它将出现在它所在的位置上。然后，可以通过设置垂直或水平位置，让这个元素“相对于”它的起点进行移动。 在使用相对定位时，无论是否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其它框。 绝对定位absolute绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那么它的位置相对于&lt;html&gt;。 absolute 定位使元素的位置与文档流无关，因此不占据空间。 absolute 定位的元素和其他元素重叠。 flex布局flex 是 Flexible Box 的缩写，意为”弹性布局”。指定容器display: flex即可。 容器有以下属性flex-direction，flex-wrap，flex-flow，justify-content，align-items，align-content。 flex-direction属性决定主轴的方向； flex-wrap属性定义，如果一条轴线排不下，如何换行； flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap； justify-content属性定义了项目在主轴上的对齐方式。 align-items属性定义项目在交叉轴上如何对齐。 align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 项目（子元素）也有一些属性order，flex-grow，flex-shrink，flex-basis，flex，align-self。 order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。 flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 block、inline、inline-block的区别block元素会独占一行，多个block元素会各自新起一行。默认情况下，block元素宽度自动填满其父元素宽度。 block元素可以设置width,height属性。块级元素即使设置了宽度,仍然是独占一行。 block元素可以设置margin和padding属性。 inline元素不会独占一行，多个相邻的行内元素会排列在同一行里，直到一行排列不下，才会新换一行，其宽度随元素的内容而变化。 inline元素设置width,height属性无效。 inline元素的margin和padding属性，水平方向的padding-left, padding-right, margin-left, margin-right都产生边距效果；但竖直方向的padding-top, padding-bottom, margin-top, margin-bottom不会产生边距效果。 inline-block：简单来说就是将对象呈现为inline对象，但是对象的内容作为block对象呈现。之后的内联对象会被排列在同一行内。比如我们可以给一个link（a元素）inline-block属性值，使其既具有block的宽度高度特性又具有inline的同行特性 css布局六种布局方式总结：圣杯布局、双飞翼布局、Flex布局、绝对定位布局、表格布局、网格布局。 圣杯布局是指布局从上到下分为header、container、footer，然后container部分定为三栏布局。这种布局方式同样分为header、container、footer。圣杯布局的缺陷在于 center 是在 container 的padding中的，因此宽度小的时候会出现混乱。 双飞翼布局给center 部分包裹了一个 main 通过设置margin主动地把页面撑开。 理解双飞翼布局和圣杯布局：https://www.jianshu.com/p/81ef7e7094e8 Flex布局是由CSS3提供的一种方便的布局方式。 绝对定位布局是给container 设置position: relative和overflow: hidden，因为绝对定位的元素的参照物为第一个postion不为static的祖先元素。 left 向左浮动，right 向右浮动。center 使用绝对定位，通过设置left和right并把两边撑开。 center 设置top: 0和bottom: 0使其高度撑开。 表格布局的好处是能使三栏的高度统一。 网格布局可能是最强大的布局方式了，使用起来极其方便，但目前而言，兼容性并不好。网格布局，可以将页面分割成多个区域，或者用来定义内部元素的大小，位置，图层关系。 Vuetify 有两个突出的优点1、默认样式就很好看，我之前用 Ant Design，.vue 文件里经常要写一些 CSS 来改变控件的默认外观、间距什么的。用上 Vuetify 后，我发现基本不用手写 CSS 了。 2、对移动端的支持非常好，我的博客一套代码，在 PC 端和移动端都很完美，关键是实现起来很简单。 说实话，上手确实有一定难度，我在起步安装上就耗费了不少时间，可能是国外的思维习惯和国人的不太一样，没有elementui,iview的直来直去，用法略显复杂，文档虽然写的很丰富，但是当你用上一个组件后，总感觉很多细节没有说清楚，很多技巧需要自己摸索。 但是抛开这些，Vuetify确实是一款非常精致的UI框架，它提供了很多常用的组件，依靠Material Design的设计优势，让你无需编写一行css代码就可以得到非常美观的界面功能。同时Vuetify还具备自适应的能力，可以使用一份代码写出同时兼容手机平板电脑的网页功能，非常值得你花时间去上手使用它。]]></content>
      <categories>
        <category>前端知识点总结</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端知识点总结——HTML]]></title>
    <url>%2F2020%2F06%2F13%2F%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94HTML%2F</url>
    <content type="text"><![CDATA[canvas的一些方法requestAnimationFrame有用过吗？知道是干什么的吗？实现动画效果的方法比较多，Javascript 中可以通过定时器 setTimeout 来实现，css3 可以使用 transition 和 animation 来实现，html5 中的 canvas 也可以实现。除此之外，html5 还提供一个专门用于请求动画的API，那就是 requestAnimationFrame，顾名思义就是请求动画帧。 屏幕刷新频率：屏幕每秒出现图像的次数。普通笔记本为60Hz 动画原理：计算机每16.7ms刷新一次，由于人眼的视觉停留，所以看起来是流畅的移动。 setTimeout：通过设定间隔时间来不断改变图像位置，达到动画效果。但是容易出现卡顿、抖动的现象；原因是：1、settimeout任务被放入异步队列，只有当主线程任务执行完后才会执行队列中的任务，因此实际执行时间总是比设定时间要晚；2、settimeout的固定时间间隔不一定与屏幕刷新时间相同，会引起丢帧。 requestAnimationFrame：优势：由系统决定回调函数的执行时机。60Hz的刷新频率，那么每次刷新的间隔中会执行一次回调函数，不会引起丢帧，不会卡顿 使用： 1234567891011var progress = 0; //回调函数 function render() &#123; progress += 1; //修改图像的位置 if (progress &lt; 100) &#123; //在动画没有结束前，递归渲染 window.requestAnimationFrame(render); &#125; &#125; //第一帧渲染 window.requestAnimationFrame(render);&lt;/pre&gt; 优势： CPU节能：使用setTimeout实现的动画，当页面被隐藏或最小化时，setTimeout 仍然在后台执行动画任务，由于此时页面处于不可见或不可用状态，刷新动画是没有意义的，完全是浪费CPU资源。而requestAnimationFrame则完全不同，当页面处理未激活的状态下，该页面的屏幕刷新任务也会被系统暂停，因此跟着系统步伐走的requestAnimationFrame也会停止渲染，当页面被激活时，动画就从上次停留的地方继续执行，有效节省了CPU开销。 函数节流：在高频率事件(resize,scroll等)中，为了防止在一个刷新间隔内发生多次函数执行，使用requestAnimationFrame可保证每个刷新间隔内，函数只被执行一次，这样既能保证流畅性，也能更好的节省函数执行的开销。 优雅降级：由于兼容性问题，需要降级对接口进行封装，优先使用高级特性，再根据浏览器不同情况进行回退，直到只能使用settimeout。参考GitHub） iframe是什么？有什么缺点？定义：iframe元素会创建包含另一个文档的内联框架 提示：可以将提示文字放在&lt;iframe&gt;&lt;/iframe&gt;之间，来提示某些不支持iframe的浏览器 缺点： 会阻塞主页面的onload事件 搜索引擎无法解读这种页面，不利于SEO iframe和主页面共享连接池，而浏览器对相同区域有限制所以会影响性能。 Doctype作用?严格模式与混杂模式如何区分？它们有何意义?Doctype声明于文档最前面，告诉浏览器以何种方式来渲染页面，这里有两种模式，严格模式和混杂模式。 严格模式的排版和JS 运作模式是 以该浏览器支持的最高标准运行。 混杂模式，向后兼容，模拟老式浏览器，防止浏览器无法兼容页面。 响应式布局的常用解决方案对比(媒体查询、百分比、rem和vw/vh）前端开发中，静态网页通常需要适应不同分辨率的设备，常用的自适应解决方案包括媒体查询、百分比、rem和vw/vh等。本文从px单位出发，分析了px在移动端布局中的不足，接着介绍了几种不同的自适应解决方案。 px和视口 媒体查询 百分比 自适应场景下的rem解决方案 通过vw/vh来实现自适应 iframe通信，同源和不同源两种情况，多少种方法同源，根据父页面以及cookie，不同源设置子域的方法 HTML5新增的元素首先html5为了更好的实践web语义化，增加了header，footer，nav,aside,section等语义化标签 在表单方面，为了增强表单，为input增加了color，emial,data ,range等类型 在存储方面，提供了sessionStorage，localStorage,和离线存储，通过这些存储方式方便数据在客户端的存储和获取，在多媒体方面规定了音频和视频元素audio和vedio 另外还有地理定位，canvas画布，拖放，多线程编程的web worker和websocket协议 pageX clienXt screenX offsetX pageX/pageY鼠标相对于整个页面的X/Y坐标。注意，整个页面的意思就是你整个网页的全部，比如说网页很宽很长，宽2000px，高3000px，那pageX,pageY的最大值就是它们了。特别说明：IE不支持！ clientX/clientY事件发生时鼠标在浏览器内容区域的X/Y坐标（不包含滚动条）。浏览器内容区域即浏览器窗口中用来显示网页的可视区域，注意这个可视，也就是说需要拖动滚动条才能看到的区域不算。当你将浏览器窗口缩小时，clientX/clientY的最大值也会缩小，但始终，它们的最大值不会超过你浏览器可视区域。特别说明：IE下此属性不规范，它们的最小值不是0而是2，也就是说IE下的clientX/clientY比火狐下始终大2px。 screenX/screenY鼠标在屏幕上的坐标。screenX,screenY的最大值不会超过屏幕分辨率。 offsetX/offsetY相对于带有定位的父盒子的x，y坐标 x、y和screenX、screenY一样 HTML5和CSS3用的多吗？你了解它们的新属性吗？有在项目中用过吗？html51）标签增删 8个语义元素 header section footer aside nav main article figure 内容元素mark高亮 progress进度 新的表单控件calander date time email url search 新的input类型 color date datetime datetime-local email 移除过时标签big font frame frameset 2）canvas绘图，支持内联SVG。支持MathML 3）多媒体audio video source embed track 4）本地离线存储，把需要离线存储在本地的文件列在一个manifest配置文件 5）web存储。localStorage、SessionStorage css3CSS3边框如border-radius，box-shadow等；CSS3背景如background-size，background-origin等；CSS3 2D，3D转换如transform等；CSS3动画如animation等]]></content>
      <categories>
        <category>前端知识点总结</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端知识点总结——前端工程化]]></title>
    <url>%2F2020%2F06%2F13%2F%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%2F</url>
    <content type="text"><![CDATA[loader的运行原理和作用具体作用如下： 实现对不同格式文件的处理，比如将Scss转化为CSS，或将TypeScript转化为JavaScript。 可以编译文件，从而使其能够添加到依赖关系中。loader是WebPack最重要的部分之一。通过使用不同的loader,我们能够调用外部的脚本或者工具，实现对不同格式文件的处理。loader需要在webpack.config.js文件里单独用module进行设置。 常用的loader如下： babel-loader: 将下一代的JavaScript语法规范转换成现代浏览器能够支持的语法规范。因为babel有些复杂，所以大多数开发者都会新建一个.babelrc来进行配置 css-loader、style-loader: 这两个建议配合使用， 用来解析CSS文件依赖 less-loader: 解析less文件 file-loader: 生成的文件名就是文件内容的MD5散列值，并会保留所引用的资源的原始拓展名 url-loader:功能类似于file-loader,但是当文件大小低于指定的限制时，可以返回一个DataURL webPack的核心原理 一切皆模块 正如JavaScript文件可以是一个“模块”一样，其他的（如CSS、image或者HTML）文件也可以以视作模块。因此，可以执行require(‘myJSfile.js’)，亦可以执行require(‘myCSSfile.css’)。这意味着我们可以将事务（业务）分割成更小的，易于管理的片段，从而达到重复利用的目的。 按需加载 传统的模块打包（module bundler）最终将所有的模块编译在一起并生成一个庞大的bundle.js文件。但是，在真实地App里，bundle.js文件的大小应该在10MB到15MB之间，这可能会导致应用一直处于加载状态。因此，WebPack使用许多特性来分割代码，然后生成多个bundle.js文件，而且异步加载部分代码用于实现按需加载。 1.入口(entry) :使用哪个模块来构建内部依赖图的开始2.输出(output) :在哪里输出它所创建的bundle.js及命名规则3.loader :可以促使webpack额外地处理非javascript文件4.插件(plugins) :执行范围更广的任务，如：打包优化和压缩等 WebPack打包一个项目的基本流程 &spades; 通过entry配置入口文件 通过output指定输出的文件 使用各种loader处理css、JavaScript、image等资源，并将它们编译与打包成浏览器可以解析的内容等 webpack4打包一个项目的基本步骤:http://www.manongjc.com/article/36472.html webpack用来干什么的webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个bundle。 Plugin的原理它主要的作用是根据webpack提供的一些hooks来进行一些额外的操作。 首先，我们在写之前要清楚plugin是怎么写的，有什么要求，去官方文档https://webpack.js.org/api/plugins/ 与 https://webpack.js.org/contribute/writing-a-plugin/查阅后原来plugin就是一个类， 它的主要的步骤如下: 编写一个JavaScript class 在class里面写一个apply方法，这个方法接收一个参数compiler，表示这次打包的上下文。 指定挂载的webpack事件钩子。 处理webpack内部实例的特定数据。 功能完成后调用webpack提供的回调。 编写插件之前要理解compiler和compilation两个对象，以及webpack生命周期的各个阶段和钩子。 然后我们开始写，还是在plugin这个项目里面写，在src目录下新建一个plugins的目录，在plugins目录下新建一个MyHtmlWebpackPlugin.js 写之前我们理清一下思路： 1、写一个class 里面有一个apply方法，接收一个compiler参数，开始写 123class MyHtmlWebpackPlugin &#123; apply(compiler) &#123;&#125;&#125; 2、然后指定挂载的webpack事件钩子，在里面做我们要做的事情，我们要做什么事情？ 我先查一下这个https://webpack.js.org/api/compiler-hooks/文档看一下有哪些钩子可以用，然后我们的插件的目的很明确，就是拿到打包后的资源，插入到html中，并且生成一个html到dist目录下。 3、所以接下来就是在对应的钩子干活了，在apply方法里面写这些逻辑。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class MyHtmlWebpackPlugin &#123; apply(compiler) &#123; // 在 emit 这个异步钩子里面拿到生成好的静态资源，第一个参数必须和我们的插件同名'MyHtmlWebpackPlugin' compiler.hooks.emit.tapAsync('MyHtmlWebpackPlugin', (compilation, callback) =&gt; &#123;// 给一个默认的html const html = `&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;MyIndex&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;` // 提取js文件 const scriptFile = '&lt;script type="text/javascript" src="&#123;&#125;"&gt;&lt;/script&gt;' const scriptArr = [] for (let filename in compilation.assets) &#123; if (/\.js$/.test(filename)) &#123; const file = scriptFile.replace('&#123;&#125;', filename) scriptArr.push(file) &#125; &#125; // 把提取到js文件插入html里面去，返回一个新的html const newHtml = html.replace('&lt;/body&gt;', scriptArr.join('\n') + '&lt;/body&gt;') // 最后在compilation.assets下面挂载一个新的命名为MyIndex.html输出文件，里面有它的内容和内容的长度 compilation.assets['MyIndex.html'] = &#123; source: function () &#123; return newHtml; &#125;, size: function () &#123; return newHtml.length; &#125; &#125;; // callback这个回调方法必须要执行 callback(); &#125;); &#125;&#125;// 导出这个pluginmodule.exports = MyHtmlWebpackPlugin 4、 来试一下我们写的插件，把webpack.config.js中的html-webpack-plugin注释，换成我们写的MyHtmlWebpackPlugin 1234567891011121314151617181920const path = require('path');// const HtmlWebpackPlugin = require('html-webpack-plugin')const MyHtmlWebpackPlugin = require('./src/plugins/MyHtmlWebpackPlugin')const &#123; CleanWebpackPlugin &#125; = require('clean-webpack-plugin')module.exports = &#123; mode: 'development', entry: &#123; main: './src/index.js' &#125;, output: &#123; path: path.resolve(__dirname, 'dist'), filename: '[name].js' &#125;, plugins: [ // new HtmlWebpackPlugin(), new MyHtmlWebpackPlugin(), new CleanWebpackPlugin(), // 清除dist目录 ]&#125; 5、npm run build 结果如下 总结plugin就是一个类,这个类里面有一个apply方法，我们在这个apply里面根据需求，在对应的钩子中注册我们的想要做的事件 webpack的loader和plugin的区别Loader用于对模块源码的转换，loader描述了webpack如何处理非javascript模块，并且在buld中引入这些依赖。loader可以将文件从不同的语言（如TypeScript）转换为JavaScript，或者将内联图像转换为data URL。比如说：CSS-Loader，Style-Loader等。 loader的使用很简单： 在webpack.config.js中指定loader。module.rules可以指定多个loader，对项目中的各个loader有个全局概览。 loader是运行在NodeJS中，可以用options对象进行配置。plugin可以为loader带来更多特性。loader可以进行压缩，打包，语言翻译等等。 loader从模板路径解析，npm install node_modules。也可以自定义loader，命名XXX-loader。 语言类的处理器loader：CoffeeScript，TypeScript，ESNext（Bable）,Sass,Less,Stylus。任何开发技术栈都可以使用webpack。 Plugin目的在于解决loader无法实现的其他事，从打包优化和压缩，到重新定义环境变量，功能强大到可以用来处理各种各样的任务。webpack提供了很多开箱即用的插件：CommonChunkPlugin主要用于提取第三方库和公共模块，避免首屏加载的bundle文件，或者按需加载的bundle文件体积过大，导致加载时间过长，是一把优化的利器。而在多页面应用中，更是能够为每个页面间的应用程序共享代码创建bundle。 webpack功能强大，难点在于它的配置文件，webpack4默认不需要配置文件，可以通过mode选项为webpack指定了一些默认的配置，mode分为：development/production，默认是production。 插件可以携带参数，所以在plugins属性传入new实例。 git流程 一般工作流程如下： 克隆 Git 资源作为工作目录。 在克隆的资源上添加或修改文件。 如果其他人修改了，你可以更新资源。 在提交前查看修改。 提交修改。 在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。 前端工程化-Sass,Babel,Webpack参考：https://www.jianshu.com/p/4115de4152c9]]></content>
      <categories>
        <category>前端知识点总结</category>
      </categories>
      <tags>
        <tag>前端工程化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于slice和concat深浅拷贝的问题]]></title>
    <url>%2F2020%2F06%2F12%2F%E5%85%B3%E4%BA%8Eslice%E5%92%8Cconcat%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[使用slice()进行深拷贝12345var arr1 = ["1","2","3"];var arr2 = arr1.slice(0);arr2[1] = "9";console.log("数组的原始值：" + arr1 ); // 1,2,3console.log("数组的新值：" + arr2 ); // 1,9,3 使用concat()进行深拷贝12345var arr1 = ["1","2","3"];var arr2 = arr1.concat();arr2[1] = "9";console.log("数组的原始值：" + arr1 ); // 1,2,3console.log("数组的新值：" + arr2 ); // 1,9,3 局限性先看看concat12345var arr1 = [&#123;"name":"weifeng"&#125;,&#123;"name":"boy"&#125;];//原数组var arr2 = [].concat(arr1);//拷贝数组arr1[1].name="girl";console.log(arr1);// [&#123;"name":"weifeng"&#125;,&#123;"name":"girl"&#125;]console.log(arr2);//[&#123;"name":"weifeng"&#125;,&#123;"name":"girl"&#125;] 再看看slice1234var a1=[["1","2","3"],"2","3"],a2;a2=a1.slice(0);a1[0][0]=0; //改变a1第一个元素中的第一个元素console.log(a2[0][0]); // 打印0， 说明影响到了a2 总结从上面两个例子可以看出，由于数组内部属性值为引用对象，因此使用slice和concat对对象数组的拷贝，整个拷贝还是浅拷贝，拷贝之后数组各个值的指针还是指向相同的存储地址。 因此，slice和concat这两个方法，仅适用于对不包含引用对象的一维数组的深拷贝]]></content>
      <categories>
        <category>前端知识点总结</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端知识点总结——ES6(2)]]></title>
    <url>%2F2020%2F06%2F11%2F%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94ES6-2%2F</url>
    <content type="text"><![CDATA[普通函数和箭头函数的区别 &spades;箭头函数相当于匿名函数，并且简化了函数定义。箭头函数有两种格式，一种只包含一个表达式，连{ … }和return都省略掉了。还有一种可以包含多条语句，这时候就不能省略{ … }和return。 箭头函数是匿名函数，不能作为构造函数，不能使用new12345let FunConstructor = () =&gt; &#123; console.log('lll');&#125; let fc = new FunConstructor();//报错 箭头函数不绑定arguments，取而代之用rest参数…解决1234567891011121314function A(a)&#123; console.log(arguments);&#125;A(1,2,3,4,5,8); // [1, 2, 3, 4, 5, 8, callee: ƒ, Symbol(Symbol.iterator): ƒ] let B = (b)=&gt;&#123; console.log(arguments);&#125;B(2,92,32,32); // Uncaught ReferenceError: arguments is not defined let C = (...c) =&gt; &#123; console.log(c);&#125;C(3,82,32,11323); // [3, 82, 32, 11323] 箭头函数不绑定this，会捕获其所在的上下文的this值，作为自己的this值12345678910111213var obj = &#123; a: 10, b: () =&gt; &#123; console.log(this.a); // undefined console.log(this); // Window &#123;postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …&#125; &#125;, c: function() &#123; console.log(this.a); // 10 console.log(this); // &#123;a: 10, b: ƒ, c: ƒ&#125; &#125;&#125;obj.b(); obj.c(); 箭头函数通过 call() 或 apply() 方法调用一个函数时，只传入了一个参数，对 this 并没有影响。12345678910111213141516let obj2 = &#123; a: 10, b: function(n) &#123; let f = (n) =&gt; n + this.a; return f(n); &#125;, c: function(n) &#123; let f = (n) =&gt; n + this.a; let m = &#123; a: 20 &#125;; return f.call(m,n); &#125;&#125;;console.log(obj2.b(1)); // 11console.log(obj2.c(1)); // 11 箭头函数没有原型属性箭头函数不能当做Generator函数,不能使用yield关键字总结： 箭头函数的 this 永远指向其上下文的 this ，任何方法都改变不了其指向，如 call() , bind() , apply() 普通函数的this指向调用它的那个对象 原文链接：https://www.cnblogs.com/biubiuxixiya/p/8610594.html ES6之symbol数据类型概述 ES6 引入了一种新的原始数据类型 Symbol ，表示独一无二的值，最大的用法是用来定义对象的唯一属性名。 ES6 数据类型除了 Number 、 String 、 Boolean 、 Object、 null 和 undefined ，还新增了 Symbol 。 基本用法 Symbol 函数栈不能用 new 命令，因为 Symbol 是原始数据类型，不是对象。可以接受一个字符串作为参数，为新创建的 Symbol 提供描述，用来显示在控制台或者作为字符串的时候使用，便于区分。 1234567let sy = Symbol("KK"); console.log(sy); // Symbol(KK) typeof(sy); // "symbol" // 相同参数 Symbol() 返回的值不相等 let sy1 = Symbol("kk"); sy === sy1; // false Symbl确保唯一，即使采用相同的名称，也会产生不同的值，我们创建一个字段，仅为知道对应symbol的人能访问，使用symbol很有用，symbol并不是100%隐藏，有内置方法Object.getOwnPropertySymbols(obj)可以获得所有的symbol。也有一个方法Reflect.ownKeys(obj)返回对象所有的键，包括symbol。 所以并不是真正隐藏。但大多数库内置方法和语法结构遵循通用约定他们是隐藏的。 ES6之proxy浅析使用proxy，你可以把老虎伪装成猫的外表，这有几个例子，希望能让你感受到proxy的威力。 proxy 用来定义自定义的基本操作行为，比如查找、赋值、枚举性、函数调用等。 proxy接受一个待代理目标对象和一些包含元操作的对象，为待代理目标创建一个‘屏障’，并拦截所有操作，重定向到自定义的元操作对象上。 proxy通过new Proxy来创建，接受两个参数： 待代理目标对象 元操作对象 闲话少说，直接看例子。 最简单的只代理一个返回功能，在这个例子里，我们让get操作，永远返回一个固定的值 1234567891011let target = &#123; name: 'fox', age: 23&#125;let handler = &#123; get: (obj, k) =&gt; 233&#125;target = new Proxy(target, handler);target.a // 233target.b // 233target.c // 233 无论你taget.x、target[x]、Reflect.get(target, &#39;x&#39;)都会返回233 当然，代理get仅仅是其中一种操作，还有： - get - set - has - apply - construct - ownKeys - deleteProperty - defineProperty - isExtensible - preventExtensions - getPrototypeOf - setPrototypeOf - getOwnPropertyDescriptor 改变默认值为0在其他语言中，如果访问对象中没有的属性，默认会返回0，这在某些场景下很有用，很方便，比如坐标系，一般来说z轴默认是0. 但是在js中，对象中不存在的key的默认值是undefined，而不是合法的初始值。 不过可以使用proxy解决这个问题 123const defaultValueObj = (target, defaultValue) =&gt; new Proxy(target, &#123; get: (obj, k) =&gt; Reflect.has(obj, k) ? obj[k] : defaultValue&#125;) 建议根据不同类型返回不同的默认值，Number =&gt; 0 String =&gt; ‘’ Object =&gt; {} Array =&gt; []等等 数组负索引取值js中，获取数组的最后一个元素是相对麻烦的，容易出错的。这就是为什么TC39提案定义一个方便的属性，Array.lastItem去获取最后一个元素。 其他语言比如python，和ruby提供了访问数组最后一个元素的方法，例如使用arr[-1]代替arr[arr.length - 1] 不过，我们有proxy，负索引在js中也可以实现。 123const negativeArray = els =&gt; new Proxy(els, &#123; get: (target, k) =&gt; Reflect.get(target, +k &lt; 0 ? String(target.length + +k) : k)&#125;) 需要注意的一点是，get操作会字符串化所有的操作，所以我们需要转换成number在进行操作， 这个运用也是negative-array的原理 隐藏属性js未能实现私有属性，尽管之后引入了Symbol去设置独一无二的属性，但是这个被后来的Object.getOwnPropertySumbols淡化了 长期以来，人们使用下划线_来表示属性的私有，这意味着不运行外部操作该属性。不过，proxy提供了一种更好的方法来实现类似的私有属性 12345const enablePrivate = (target, prefix = '_') =&gt; new Proxy(target, &#123; has: (obj, k) =&gt; (!k.startsWith(prefix) &amp;&amp; k in obj), ownKeys: (obj, k) =&gt; Reflece.ownKeys(obj).filter(k =&gt; (typeof k !== 'string' || !k.startsWith(prefix))), get: (obj, k, rec) =&gt; (k in rec) ? obj[k] : undefined&#125;) 结果 123456789let userData = enablePrivate(&#123; firstName: 'Tom', mediumHandle: '@tbarrasso', _favoriteRapper: 'Drake'&#125;)userData._favoriteRapper // undefined('_favoriteRapper' in userData) // falseObject.keys(userData) // ['firstName', 'mediumHandle'] 如果你打印该proxy代理对象，会在控制台看到，不过无所谓。 缓存失效服务端和客户端同步一个状态可能会出现问题，这很常见，在整个操作周期内，数据都有可能被改变，并且很难去掌握需要重新同步的时机。 proxy提供了一种新的办法，可以让属性在必要的时候失效，所有的访问操作，都会被检查判断，是否返回缓存还是进行其他行为的响应。 1234567const timeExpired = (target, ttl = 60) =&gt; &#123; const created_at = Date.now(); const isExpired = () =&gt; (Date.now - created_at) &gt; ttl * 1000; return new Proxy(target, &#123; get: (target, k) =&gt; isExpired() ? undefined : Reflect.get(target, k); &#125;)&#125; 上面的功能很简单，他在一定时间内正常返回访问的属性，当超出ttl时间后，会返回undefined。 123456789let timeExpired = ephemeral(&#123; balance: 14.93&#125;, 10)console.log(bankAccount.balance) // 14.93setTimeout(() =&gt; &#123; console.log(bankAccount.balance) // undefined&#125;, 10 * 1000) 上面的例子会输出undefined在十秒后，更多的骚操作还请自行斟酌。 只读尽管Object.freeze可以让对象变得只读，但是我们可以提供更好的方法，让开发者在操作属性的时候获取明确的提示 12345678910const nope = () =&gt; &#123; throw new Error('不能改变只读属性')&#125;const read_only = (obj) =&gt; new Proxy(obj, &#123; set: nope, defineProperty: nope, deleteProperty: nope, preentExtensions: nope, setPrototypeOf: nope&#125;); 枚举结合上面的只读方法 12345678const createEnum = (target) =&gt; read_only(new Proxy(target, &#123; get: (obj, k) = &#123; if (k in obj) &#123; return Reflect.get(obj, k) &#125; throw new ReferenceError(`找不到属性$&#123;k&#125;`) &#125;&#125;)) 我们得到了一个对象，如果你访问不存在的属性，不会得到undefined，而是抛出一个指向异常错误，折让调试变得更方便。 这也是一个代理代理的例子，需要保证被代理的代理是一个合法的代理对象，这个有助于混合一些复杂的功能。 重载操作符最神奇的可能就是重载某些操作符了，比如使用handler.has重载in。 in用来判断指定的属性是否指定对象或者对象的原型链上，这种行为可以很优雅的被重载，比如创建一个用于判断目标数字是否在制定范围内的代理 1234567891011const range = (min, max) =&gt; new Proxy(Object.create(null), &#123; has: (obj, k) =&gt; (+k &gt; min &amp;&amp; +k &lt; max)&#125;)const X = 10.5const nums = [1, 5, X, 50, 100]if (X in range(1, 100)) &#123; // true // ...&#125;nums.filter(n =&gt; n in range(1, 10)) // [1, 5] 上面的例子，虽然不是什么复杂的操作，也没有解决什么复杂的问题，但是这种清晰，可读，可复用的方式相信也是值得推崇的。 当然除了in操作符，还有delete 和 new; 其他 兼容性一般，不过谷歌开发的proxy-polyfill目前已经支持get、set、apply、construct到ie9了 目前浏览器没有办法判断对象是否被代理，不过在node版本10以上，可以使用util.types.isProxy来判断 proxy的第一个参数必须是对象，不能代理原始值 性能，proxy的一个缺点就是性能，但是这个也因人/浏览器而异，不过，proxy绝对不适合用在性能关键点的代码上，当然，你可以衡量proxy带来的遍历和可能损耗的性能，进行合理的中和，来达到最佳的开发体验和用户体验 ES6之ReflectES6 中将 Object 的一些明显属于语言内部的方法移植到了 Reflect 对象上（当前某些方法会同时存在于 Object 和 Reflect 对象上），未来的新方法会只部署在 Reflect 对象上。 Reflect 对象对某些方法的返回结果进行了修改，使其更合理。 Reflect 对象使用函数的方式实现了 Object 的命令式操作。 静态方法 1Reflect.get(target, name, receiver) 查找并返回 target 对象的 name 属性。 1Reflect.set(target, name, value, receiver) 将 target 的 name 属性设置为 value。返回值为 boolean ，true 表示修改成功，false 表示失败。当 target 为不存在的对象时，会报错。 1Reflect.has(obj, name) 是 name in obj 指令的函数化，用于查找 name 属性在 obj 对象中是否存在。返回值为 boolean。如果 obj 不是对象则会报错 TypeError。 1Reflect.deleteProperty(obj, property) 是 delete obj[property] 的函数化，用于删除 obj 对象的 property 属性，返回值为 boolean。如果 obj 不是对象则会报错 TypeError。 1Reflect.construct(obj, args) 等同于 new target(…args)。 1Reflect.getPrototypeOf(obj) 用于读取 obj 的 proto 属性。在 obj 不是对象时不会像 Object 一样把 obj 转为对象，而是会报错。 1Reflect.setPrototypeOf(obj, newProto) 用于设置目标对象的 prototype。 1Reflect.apply(func, thisArg, args) 等同于 Function.prototype.apply.call(func, thisArg, args) 。func 表示目标函数；thisArg 表示目标函数绑定的 this 对象；args 表示目标函数调用时传入的参数列表，可以是数组或类似数组的对象。若目标函数无法调用，会抛出 TypeError 。 1Reflect.defineProperty(target, propertyKey, attributes) 用于为目标对象定义属性。如果 target 不是对象，会抛出错误。 1Reflect.getOwnPropertyDescriptor(target, propertyKey) 用于得到 target 对象的 propertyKey 属性的描述对象。在 target 不是对象时，会抛出错误表示参数非法，不会将非对象转换为对象。 1Reflect.isExtensible(target) 用于判断 target 对象是否可扩展。返回值为 boolean 。如果 target 参数不是对象，会抛出错误。 1Reflect.preventExtensions(target) 用于让 target 对象变为不可扩展。如果 target 参数不是对象，会抛出错误。 1Reflect.ownKeys(target) 用于返回 target 对象的所有属性，等同于 Object.getOwnPropertyNames 与Object.getOwnPropertySymbols 之和。 Reflect 对象的方法与 Proxy 对象的方法是一一对应的。所以 Proxy 对象的方法可以通过调用 Reflect 对象的方法获取默认行为，然后进行额外操作。 1234567891011121314151617181920let exam = &#123; name: "Tom", age: 24&#125;let handler = &#123; get: function(target, key)&#123; console.log("getting "+key); return Reflect.get(target,key); &#125;, set: function(target, key, value)&#123; console.log("setting "+key+" to "+value) Reflect.set(target, key, value); &#125;&#125;let proxy = new Proxy(exam, handler)proxy.name = "Jerry"proxy.name// setting name to Jerry// getting name// "Jerry" Object.defineProperty()语法 12&gt; Object.defineProperty(obj, prop, descriptor)&gt; 参数obj：要定义属性的对象。 prop：要定义或修改的属性的名称或 Symbol 。 descriptor：要定义或修改的属性描述符。 在ES6中，由于 Symbol类型的特殊性，用Symbol类型的值来做对象的key与常规的定义或修改不同，而Object.defineProperty 是定义key为Symbol的属性的方法之一。 value 任意 默认undefined writable Boolean false enumerable Boolean false 可否枚举（循环遍历） configurable Boolean false 可否被重新配置 作用修改现有属性的特征；向对象添加新属性 Object.seal()Object.seal()方法封闭一个对象，阻止添加新属性并将所有现有属性标记为不可配置。当前属性的值只要原来是可写的就可以改变。 Object.freeze()Object.freeze() 方法可以冻结一个对象。一个被冻结的对象再也不能被修改；冻结了一个对象则不能向这个对象添加新的属性，不能删除已有属性，不能修改该对象已有属性的可枚举性、可配置性、可写性，以及不能修改已有属性的值。此外，冻结一个对象后该对象的原型也不能被修改。freeze() 返回和传入的参数相同的对象。 Array.from()Array.from() 方法从一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。 其他类似方法还有： Array.prototype.slice.call() [].slice().call() […]拓展运算符 arguments是什么arguments对象是所有（非箭头）函数中都可用的局部变量 拥有的属性 arguments.callee—指向当前执行的函数 arguments.length—指向传递给当前函数的参数数量 arguments.arguments— 返回一个新的Array迭代器对象，该对象包含参数中每个索引的值 arguments对象可以与剩余参数、默认参数和解构赋值参数结合使用 类数组对象：对于一个普通的对象来说，如果它的所有property名均为正整数，同时也有相应的length属性，那么虽然该对象并不是由Array构造函数所创建的，它依然呈现出数组的行为，在这种情况下，这些对象被称为“类数组对象”。 与数组的区别1、一个是对象，一个是数组 2、数组的length属性，当新的元素添加到列表中的时候，其值会自动更新。类数组对象的不会。 3、设置数组的length属性可以扩展或截断数组。 4、数组也是Array的实例可以调用Array的方法，比如push,pop等等 所以说arguments对象不是一个 Array 。它类似于Array，但除了length属性和索引元素之外没有任何Array属性。 怎么获得对象上的属性：比如说通过Object.keys（）从ES5开始，有三种方法可以列出对象的属性 for（let I in obj）该方法依次访问一个对象及其原型链中所有可枚举的类型 object.keys:返回一个数组，包括所有可枚举的属性名称 object.getOwnPropertyNames:返回一个数组包含不可枚举的属性 简单讲一讲ES6的一些新特性ES6在变量的声明和定义方面增加了let、const声明变量，有局部变量的概念，赋值中有比较吸引人的结构赋值，同时ES6对字符串、 数组、正则、对象、函数等拓展了一些方法，如字符串方面的模板字符串、函数方面的默认参数、对象方面属性的简洁表达方式，ES6也 引入了新的数据类型symbol，新的数据结构set和map,symbol可以通过typeof检测出来，为解决异步回调问题，引入了promise和 generator，还有最为吸引人了实现Class和模块，通过Class可以更好的面向对象编程，使用模块加载方便模块化编程，当然考虑到 浏览器兼容性，我们在实际开发中需要使用babel进行编译 重要的特性： 块级作用域：ES5只有全局作用域和函数作用域，块级作用域的好处是不再需要立即执行的函数表达式，循环体中的闭包不再有问题 rest参数：用于获取函数的多余参数，这样就不需要使用arguments对象了， promise:一种异步编程的解决方案，比传统的解决方案回调函数和事件更合理强大 模块化：其模块功能主要有两个命令构成，export和import，export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能 实现多个页面之间进行通信使用cookie，使用web worker，使用localeStorage和sessionStorage ES6箭头函数的特性箭头函数与普通函数的区别在于： 1、箭头函数没有this，所以需要通过查找作用域链来确定this的值，这就意味着如果箭头函数被非箭头函数包含，this绑定的就是最近一层非箭头函数的this， 2、箭头函数没有自己的arguments对象，但是可以访问外围函数的arguments对象 3、不能通过new关键字调用，同样也没有new.target值和原型 let const var提起这三个最明显的区别是var声明的变量是全局或者整个函数块的，而let,const声明的变量是块级的变量，var声明的变量存在变量提升，let,const不存在，let声明的变量允许重新赋值，const不允许]]></content>
      <categories>
        <category>前端知识点总结</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是CI/CD]]></title>
    <url>%2F2020%2F06%2F10%2F%E4%BB%80%E4%B9%88%E6%98%AFCI-CD%2F</url>
    <content type="text"><![CDATA[参考博客：https://www.jianshu.com/p/5643b1cf9e3f]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>部署</tag>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端知识点总结——性能优化]]></title>
    <url>%2F2020%2F06%2F10%2F%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[谈谈性能优化的问题缓存利用缓存Ajax，使用CDN、外部JavaScript和CSS文件缓存，添加Expires头，在服务器端配置Etag，减少DNS查找等 请求数量合并样式和脚本，使用CSS图片精灵，初始首屏之外的图片资源按需加载，静态资源延迟加载 请求带宽压缩文件，开启GZIP JavaScript代码 用散列表来代替优化查找，少用全局变量，用innerHTML代替DOM操作，减少DOM操作次数，优化JavaScript性能， 用setTimeout避免页面失去响应，缓存DOM节点查找结果，避免使用with（with会创建自己的作用域，增加作用域链的长度），多个变量声明合并 HTML代码避免图片和iFrame等src属性为空。src属性为空，会重新加载当前页面，影响速度和效率，尽量避免在HTML标签中写Style属性 img标签的src为什么不能为空 应该用什么出现一次这样的标签会导致向你的服务器多做一次请求 在一个访问量不高的网站中，多一个这样的请求也无所谓（甚至可以让你的网站浏览看上去翻番），但在一个千万级访问量甚至更高的WEB站点里，这样会导致你的服务器和带宽的成本显著增加。 另外一个隐患是，重新请求某个页面可能会导致用户的一些信息被无意中修改，例如cookies，或者ajax操作。 你计划是从服务器端读取这个src地址，但是由于某个原因，这个地址还未设置，或者代码的BUG导致读取失败，就会出现空的src标签。 其他的标签中的空src会不会导致这样的问题？好消息是，在IE中只有image标签有这个问题。坏消息是，在Chrome, Safari, 和 Firefox中script和link都会导致出现一个新的请求。 如何解决这个问题？可以从两方面着手，一是尽量避免这种坏的编程方式，不要出现空的src标签。另外，可以从服务器端着手，在发现时这种无意义的请求时不要返回任何东西给客户端。 懒加载 预加载 懒加载其实就是延时加载，即当对象需要用到的时候再去加载。 图片进入可视区域之后请求图片资源。对于电商等图片很多，页面很长的业务场景适用。减少无效资源的加载。并发加载的资源过多会阻塞 js 的加载，影响网站的正常使用。 浏览器解析的过程中，遇到image里面有src，他就会去请求 src 里面的资源，在真实场景中，我们希望图片进入可视区域之后，src 才会被设置进去，而不是一开始可视区域之外的 img 就设置了 src ,如果已经设置了，显然没在可是区域就去加载了。所以一开始不在可视区域的图片只是一个占位符，他真正的 url 存放在 data-url 上面。这个地址因为没放在 src 上，所以不会造成去请求图片相关的资源。通过 js 监听 scroll 事件，监听到这个图片到可视区域之后，将 data-url 放置到 src ，src 的变化就会触发请求。这就是懒加载的原理。 12345678910111213141516171819202122232425262728var viewHeight = document.documentElement.clientHeight // 可视区域的高度function lazyload () &#123; var eles = document.querySelectorAll('img[data-original][lazyload]') Array.prototype.forEach.call(eles, function (item, index) &#123; var rect if (item.dataset.original === '') return; // getBoundingClientRect 返回元素的大小及其相对于视口的位置。 rect = item.getBoundingClientRect() if (rect.bottom &gt;= 0 &amp;&amp; rect.top &lt; viewHeight) &#123; !function () &#123; var img = new Image() img.src = item.dataset.original img.onload = function () &#123; item.src = img.src &#125; item.removeAttribute('data-original') item.removeAttribute('lazyload') &#125;() &#125; &#125;)&#125;lazyload()document.addEventListener('scroll', lazyload) 预加载跟懒加载是个相反的过程，图片等静态资源在使用之前提前请求，资源使用到时能从缓存中加载，提升用户体验。 1.display:none 2.new Image的方式。js执行到的时候已经被加载下来，实际上还没有被使用 var image = new Image() image.src = “http://pic26.nipic.com/20121213/6168183_004444903000_2.jpg&quot; 3.xmlhttprequest 12345678910111213141516171819202122232425// 使用XMLHttpRequest对象var xmlhttprequest = new XMLHttpRequest(); xmlhttprequest.onreadystatechange = callback;xmlhttprequest.onprogress = progressCallback;xmlhttprequest.open("GET","http://image.baidu.com/mouse.jpg",true);xmlhttprequest.send();function callback () &#123; if (xmlhttprequest.readyState == 4 &amp;&amp; xmlhttprequest.status==200)&#123; var responseText = xmlhttprequest.responseText; &#125;else&#123; console.log("Request was unsuccessful: " + xmlhttprequest.status); &#125; &#125;function progressCallback (e) &#123; e = e || event; if (e.lengthComputable)&#123; console.log("Received " + e.loaded + " of " + e.total + " bytes") &#125;&#125; 缺陷是有跨域问题，优点是可以更加精细的控制预加载过程 白屏概念和重要性白屏时间：即用户点击一个链接或打开浏览器输入URL地址后，从屏幕空白到显示第一个画面的时间。 白屏时间的长短将直接影响用户对该网站的第一印象。 当用户点开一个链接或者是直接在浏览器中输入URL开始进行访问时，就开始等待页面的展示。页面渲染的时间越短，用户等待的时间就越短，用户感知到页面的速度就越快。这样可以极大的提升用户的体验，减少用户的跳出，提升页面的留存率。 从打开一个页面到展示经历的过程1.DNS Lookup DNS Lookup 即浏览器从DNS服务器中进行域名查询。 浏览器会先对页面进行域名解析，获取到服务器的IP地址后，进而和服务器进行通信。 Tips: 通常在整个加载页面的过程中，浏览器会多次进行DNS Lookup，包括页面本身的域名查询以及在解析HTML页面时加载的JS、CSS、Image、Video等资源产生的域名查询。 2.建立TCP请求连接 浏览器和服务端TCP请求建立的过程，是基于TCP/IP，该协议由网络层的IP和传输层的TCP组成。IP是每一台互联网设备在互联网中的唯一地址。 TCP通过三次握手建立连接，并提供可靠的数据传输服务。 3.服务端请求处理响应 在TCP连接建立后，Web服务器接受请求，开始进行处理，同时浏览器端开始等待服务器的处理响应。 Web服务器根据请求类型的不同，进行相应的处理。静态资源如图片、CSS文件、静态HTML直接进行响应；如其他注册的请求转发给相应的应用服务器，进行如数据处理、缓存中取数据，将数据按照约定好的格式响应给浏览器。 在大型应用中，通常为分布式服务架构，应用服务器的处理有可能经过很多个系统的中间件，最终获取到需要的数据 4.客户端下载、解析、渲染显示页面 在服务器返回数据后，客户端浏览器接收数据，进行HTML下载、解析、渲染显示。 浏览器采用至上而下的方式解析，所以会先解析html，直到遇到外部样式和外部脚本，即： html解析-&gt;外部样式、脚本加载-&gt;外部样式执行-&gt;外部脚本执行-&gt;html继续解析 a. 如果是Gzip包，则先解压为HTML b. 解析HTML的头部代码，下载头部代码中的样式资源文件或脚本资源文件 c. 解析HTML代码和样式文件代码，构建HTML的DOM树以及与CSS相关的CSSOM树 d. 通过遍历DOM树和CSSOM树，浏览器依次计算每个节点的大小、坐标、颜色等样式，构造渲染树 e. 根据渲染树完成绘制过程 浏览器下载HTML后，首先解析头部代码，进行样式表下载，然后继续向下解析HTML代码，构建DOM树，同时进行样式下载。当DOM树构建完成后，立即开始构造CSSOM树。理想情况下，样式表下载速度够快，DOM树和CSSOM树进入一个并行的过程，当两棵树构建完毕，构建渲染树，然后进行绘制。 Tips:浏览器安全解析策略对解析HTML造成的影响 当解析HTML时遇到内联JS代码，会阻塞DOM树的构建 特别悲惨的情况： 当CSS样式文件没有下载完成时，浏览器解析HTML遇到了内联JS代码，此时！！！根据浏览器的安全解析策略，浏览器暂停JS脚本执行，暂停HTML解析。直到CSS文件下载完成，完成CSSOM树构建，重新恢复原来的解析。 一定要合理放置JS代码！！！ 白屏-性能优化1.DNS解析优化 针对DNS Lookup环节，我们可以针对性的进行DNS解析优化。 DNS缓存优化 DNS预加载策略 稳定可靠的DNS服务器 2.TCP网络链路优化 针对网络链路的优化，好像除了花钱没有什么更好的方式！ 3.服务端处理优化 服务端的处理优化，是一个非常庞大的话题，会涉及到如Redis缓存、数据库存储优化或是系统内的各种中间件以及Gzip压缩等… 4.浏览器下载、解析、渲染页面优化 根据浏览器对页面的下载、解析、渲染过程，可以考虑一下的优化处理： 尽可能的精简HTML的代码和结构 尽可能的优化CSS文件和结构 一定要合理的放置JS代码，尽量不要使用内联的JS代码 控制图片加载完成后调用回调函数的方法1234567891011121314151617181920//实现一系列图片的预加载 //参数sources:图片信息关联数组 //参数callback:回调函数——图片预加载完成后立即执行此函数。 function loadImages(sources, callback)&#123; var count = 0, images =&#123;&#125;, imgNum = 0; for(src in sources)&#123; imgNum++; &#125; for(src in sources)&#123; images[src] = new Image(); images[src].onload = function()&#123; if(++count &gt;= imgNum)&#123; callback(images); &#125; &#125; images[src].src = sources[src]; &#125; &#125; 参考博客地址：https://www.jianshu.com/p/cb9bbd3066ba 前端优化降低请求量：合并资源，减少HTTP 请求数，minify / gzip 压缩，webP，lazyLoad。 加快请求速度：预解析DNS，减少域名数，并行加载，CDN 分发。 缓存：HTTP 协议缓存请求，离线缓存 manifest，离线数据缓存localStorage。 渲染：JS/CSS优化，加载顺序，服务端渲染，pipeline。 减少HTTP请求 使用内容发布网络（CDN） 添加本地缓存 压缩资源文件 将CSS样式表放在顶部，把javascript放在底部（浏览器的运行机制决定） 避免使用CSS表达式 减少DNS查询 使用外部javascript和CSS 避免重定向 图片lazyLoad 使用fagment减少dom的操作 https://www.cnblogs.com/blueSkys/p/3685740.html 也可参考文章：https://www.365jz.com/article/24506 前端的图片优化方案1.使用base64编码代替图片 场景：适用于图片大小小于2KB，页面上引用图片总数不多的情况 原理：将图片转换为base64编码字符串inline到页面或css中 优势：减少http的请求次数，并可以放到后台数据库中，只传输字符串，有较多的构建工具可以直接实现 劣势：这种方法仅限于图片总数较少，而且图片大小小于2KB的情况。否则图片字符串会变得很长很长。 2.合并图片sprite 场景：任何用到页面图片的场景 原理：将多个页面上用到的背景图片合并成一个大的图片在页面中引用 优势：可以有效的较少请求个数，而且，而不影响开发体验，使用构建插件可以做到对开发者透明。适用于页面图片多且丰富的场景。 劣势：生成的图片体积较大，减少请求个数同时也增加了图片大小，不合理拆分将不利于并行加载。 3.使用css、svg、canvas或iconfont代替图片css代替图片 场景：适用于移动端或较高级的浏览器，而且绘制的图案较为简单。 原理：css方式可以用来绘制相对简单的团来代替图片，一般使用before或者after伪元素来丰富图案的复杂度。 优势：具有实现简单，图片体积小的特点，可以实现简单的动态效果 劣势：也受限于css的兼容性特点，绘制复杂图案困难svg的描述和适用场景上文已说明。canvas代替图片 场景：需要高性能的图片或动画 原理：适用html5的canvas元素绘制创建图片 优势：整个就是画2D图形时，页面渲染性能比较高，页面渲染性能受图形复杂度影响小，性能只受图形的分辨率的影响，画出来的图形可以直接保存为 .png 或者 .jpg的图形，适合于画光栅图像或者不规则图形 劣势：没有dom操作，必须依赖定时器，文字渲染性能差，不能添加描述(title属性什么的)，兼容性限制iconfont是一种web字体来代替图片的解决方案： 场景：代替页面上色彩单一的图片 优势：兼容性好，应用广，目前使用也很广泛 劣势：但是由于字体的颜色设置单一，只能用于代替颜色单一的图片，对于色彩复杂的图片，iconfont处理起来比较困难， 4.响应式图片 场景：不同终端对同一个图片需求不一样，可以根据终端加载不同的图片来节省没必要的流量 原理：通过picture元素，picturefill或平台判断来为不同终端平台输出不同的图片 优势：减少没必要的图片加载，灵活控制，慢速用户加载小图片不至于加载失败，移动端没必要加载大尺寸图片等，可以通过不同方式兼容所有浏览器 劣势：无法避免图片的加载过程，图片本身没优化。 5.压缩图片 场景：在不得不加载图片的前提下，要进一步提升优化效果，只能通过有损或无损压缩来减少图片的大小， 原理：对图片进行无损、有损压缩或格式转换，转为压缩后图片或压缩率更高的图片格式来实现 优势：减少图片加载流量，效果比较明显 劣势：服务器和浏览器压力增大，而且服务器需要额外的服务支持，格式转换要考虑浏览器的兼容性。]]></content>
      <categories>
        <category>前端知识点总结</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端知识点总结——操作系统]]></title>
    <url>%2F2020%2F06%2F10%2F%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[进程和线程的区别 参考作者：阮一峰，链接地址：http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html 进程是资源分配的最小单位，线程是CPU调度的最小单位 计算机的核心是CPU，它承担了所有的计算任务。它就像一座工厂，时刻在运行。 假定工厂的电力有限，一次只能供给一个车间使用。也就是说，一个车间开工的时候，其他车间都必须停工。背后的含义就是，单个CPU一次只能运行一个任务。 进程就好比工厂的车间，它代表CPU所能处理的单个任务。任一时刻，CPU总是运行一个进程，其他进程处于非运行状态。 一个车间里，可以有很多工人。他们协同完成一个任务。 线程就好比车间里的工人。一个进程可以包括多个线程。 车间的空间是工人们共享的，比如许多房间是每个工人都可以进出的。这象征一个进程的内存空间是共享的，每个线程都可以使用这些共享内存。 可是，每间房间的大小不同，有些房间最多只能容纳一个人，比如厕所。里面有人的时候，其他人就不能进去了。这代表一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。 一个防止他人进入的简单方法，就是门口加一把锁。先到的人锁上门，后到的人看到上锁，就在门口排队，等锁打开再进去。这就叫“互斥锁”（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域。 还有些房间，可以同时容纳n个人，比如厨房。也就是说，如果人数大于n，多出来的人只能在外面等着。这好比某些内存区域，只能供给固定数目的线程使用。 这时的解决方法，就是在门口挂n把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。这种做法叫做“信号量”)（Semaphore），用来保证多个线程不会互相冲突。 不难看出，mutex是semaphore的一种特殊情况（n=1时）。也就是说，完全可以用后者替代前者。但是，因为mutex较为简单，且效率高，所以在必须保证资源独占的情况下，还是采用这种设计。 总结操作系统的设计，因此可以归结为三点： （1）以多进程形式，允许多个任务同时运行； （2）以多线程形式，允许单个任务分成不同的部分运行； （3）提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源。 进程间的通信方式有哪些1、无名管道：半双工的通信方式，数据只能单向流动且只能在具有亲缘关系的进程间使用 2、高级管道：将另一个程序当作一个新的进程在当前程序进程中启动，则这个进程算是当前程序的子进程， 3、有名管道，：也是半双工的通信方式，但是允许没有亲缘进程之间的通信 4、消息队列：消息队列是有消息的链表，存放在内核中，并由消息队列标识符标识，消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限的缺点 5、信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问，它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源， 6、信号：用于通知接受进程某个事件已经发生 7、共享内存：共享内存就是映射一段能被其他进程所访问的内存。这段共享内存由一个进程创建，但是多个进程可以访问，共享内存是最快的IPC 方式，往往与其他通信机制配合使用 8、套接字：可用于不同机器之间的进程通信 Linux查询进程指令，查询端口，杀进程，查看安装的软件sudo dpkg -L 软件名sudo apt-cache search all把输出结果保存到 .txt 文件里边 sudo dpkg -l &gt; .txt 安装软件sudo apt-get install nginx 查询进程ps 命令用于查看当前正在运行的进程。 grep 是搜索 例如： ps -ef | grep java 表示查看所有进程里CMD是java的进程信息 ps -aux | grep java -aux 显示所有状态 ps 杀死进程： kill -9[PID] 查看非root启动的程序 ps -U root -u root -N 系统中的每个进程 ps -A # ps -e top命令提供了运行中系统的动态 cat命令命令格式： cat &lt;文件&gt; 意义：cat是concatenate 的缩写。表示读取文件内容及拼接文件。 rm命令命令格式： rm &lt;文件&gt; 或 rm -r &lt;文件夹&gt; 意义：rm是remove 的缩写。用于删除文件或文件夹，常用参数-r -f，-r表示删除目录，也可以用于删除文件，-f表示强制删除，不需要确认。同样的，删除文件前需保证当前用户对当前路径有修改的权限。 示例： rm -rf path 删除path。 rm test.txt 删除test.txt。 mkdir命令命令格式： mkdir 文件夹 意义：mkdir是make directory 的缩写。用于创建文件夹。创建文件夹前需保证当前用户对当前路径有修改的权限。 示例： mkdir /data/path 在/data路径下创建path文件夹。 mkdir -p a/b/c 参数 -p用于创建多级文件夹，这句命令表示在当前路径下创建文件夹a， 而a文件夹包含子文件夹b，b文件夹下又包含子文件夹c。 cp命令命令格式： cp &lt;文件&gt;&lt;目标文件&gt;或者cp -r&lt;文件夹&gt;&lt;目标文件夹&gt; 意义：cp是copy 的缩写。用于复制文件或文件夹。 示例： cp /data/logs /data/local/tmp/logs 复制/data路径下的logs到/data/local/tmp路径下。 cp 1.sh /sdcard/ 复制当前路径下的1.sh到/sdcard下。 kill命令命令格式：kill PID码 意义：结束当前进程 示例： 先通过输入命令 ps au查看进程，找到需要终止进程的PID再通过kill PID即可，如我这里想要终止的进程是vim test.py，查到的PID是3163，我们可以输入kill 3163结束这个程序，如果结束不了，可以通过kill -9 PID码强制结束，即kii -9 3163 除了这七个命令，还有许多常见的命令，如pwd命令，这个可以查看当前路径，这个在移动数据集或者整理文件list的时候很有用；tar命令，这个可以文件压缩；unzip命令，这个可以用于文件解压，这样的命令其实还有很多，需要我们在使用的过程中不断熟练，需要我们不停的查阅学习。 线程的那些资源共享，那些资源不共享共享的资源a. 堆 由于堆是在进程空间中开辟出来的，所以它是理所当然地被共享的；因此new出来的都是共享的（16位平台上分全局堆和局部堆，局部堆是独享的） b. 全局变量 它是与具体某一函数无关的，所以也与特定线程无关；因此也是共享的 c. 静态变量虽然对于局部变量来说，它在代码中是“放”在某一函数中的，但是其存放位置和全局变量一样，存于堆中开辟的.bss和.data段，是共享的 d. 文件等公用资源 这个是共享的，使用这些公共资源的线程必须同步。Win32 提供了几种同步资源的方式，包括信号、临界区、事件和互斥体。 独享的资源a. 栈 栈是独享的 b. 寄存器 这个可能会误解，因为电脑的寄存器是物理的，每个线程去取值难道不一样吗？其实线程里存放的是副本，包括程序计数器PC Redis和 mysql（1）类型上 从类型上来说，mysql是关系型数据库，redis是缓存数据库 （2）作用上 mysql用于持久化的存储数据到硬盘，功能强大，但是速度较慢 redis用于存储使用较为频繁的数据到缓存中，读取速度快 （3）需求上 mysql和redis因为需求的不同，一般都是配合使用。]]></content>
      <categories>
        <category>前端知识点总结</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端知识点总结——算法与数据结构]]></title>
    <url>%2F2020%2F06%2F09%2F%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[排序算法了解哪些 &spades;冒泡排序 插入排序 选择排序 快速排序 归并排序 手写桶排序桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点： 在额外空间充足的情况下，尽量增大桶的数量 使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中 同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。 什么时候最快当输入的数据可以均匀的分配到每一个桶中。 什么时候最慢当输入的数据被分配到了同一个桶中。 JavaScript 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445function bucketSort(arr, bucketSize) &#123; if (arr.length === 0) &#123; return arr; &#125; var i; var minValue = arr[0]; var maxValue = arr[0]; for (i = 1; i &lt; arr.length; i++) &#123; if (arr[i] &gt; maxValue) &#123; // 输入数据的最大值 maxValue = arr[i]; &#125; if (arr[i] &lt; minValue) &#123; // 输入数据的最小值 minValue = arr[i] &#125; &#125; //桶的初始化 var DEFAULT_BUCKET_SIZE = 5; // 设置桶的默认数量为5 bucketSize = bucketSize || DEFAULT_BUCKET_SIZE; var bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1; var buckets = new Array(bucketCount); for (i = 0; i &lt; buckets.length; i++) &#123; buckets[i] = []; // 二维数组 &#125; //利用映射函数将数据分配到各个桶中 for (i = 0; i &lt; arr.length; i++) &#123; buckets[Math.floor((arr[i] - minValue) / bucketSize)].push(arr[i]); &#125; arr.length = 0; for (i = 0; i &lt; buckets.length; i++) &#123; // 对每个桶进行排序，这里的排序方法自己选择哦铁汁 insertionSort(buckets[i]); for (var j = 0; j &lt; buckets[i].length; j++) &#123; arr.push(buckets[i][j]); &#125; &#125; return arr;&#125;function sortArr () &#123;...&#125; 数组和链表的区别链表通过指针来连接元素与元素，数组则是把所有元素按次序依次存储。 链表的插入删除元素相对数组较为简单，不需要移动元素，且较为容易实现长度扩充，但是寻找某个元素较为困难； 数组寻找某个元素较为简单，但插入与删除比较复杂，由于最大长度需要再编程一开始时指定，故当达到最大长度时，扩充长度不如链表方便。相同：两种结构均可实现数据的顺序存储，构造出来的模型呈线性结构。 滑动窗口12345678910111213141516171819202122232425262728var minWindow = (s, t) =&gt; &#123; let minLen = Infinity, resL // minLen初始尽量大，第一次就能被改写 let map = &#123;&#125; // 存储目标字符，和对应的缺失个数 let missingType = 0 // 当前缺失的字符种类数 for (const char of t) &#123; // t为baac的话，map为&#123;a:2,b:1,c:1&#125; if (!map[char]) &#123; missingType++ // 需要找齐的种类数 +1 map[char] = 1 &#125; else &#123; map[char]++ &#125; &#125; let left = 0, right = 0 // 左右指针 for (; right &lt; s.length; right++) &#123; // right++ 扩张窗口，超出s串就结束循环 let rightChar = s[right] // 获取right指向的新字符 if (map[rightChar] !== undefined) map[rightChar]-- // 是目标字符，它的缺失个数-1 if (map[rightChar] === 0) missingType-- // 它的缺失个数变0，缺失的种类就-1 while (missingType === 0) &#123; //只要满足当前窗口包含所有字符，就一直收缩窗口 if (right - left + 1 &lt; minLen) &#123; // 计算长度，和minLen比较 minLen = right - left + 1 // 更新minLen resL = left // 更新最小子串的起点 &#125; let leftChar = s[left] // 获取左指针指向的字符 if (map[leftChar] !== undefined) map[leftChar]++ //目标字符被舍弃，缺失个数+1 if (map[leftChar] &gt; 0) missingType++ // 缺失个数变&gt;0，缺失的种类+1 left++ // 左指针步进，收缩窗口 &#125; &#125; return s.substring(resL, resL + minLen) // 根据起点和minLen截取子串&#125;]]></content>
      <categories>
        <category>前端知识点总结</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端知识点总结——JavaScript]]></title>
    <url>%2F2020%2F06%2F09%2F%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94JavaScript%2F</url>
    <content type="text"><![CDATA[apply bind call的区别call 、bind 、 apply 这三个函数的第一个参数都是 this 的指向对象 第二个参数差别来了 call的参数是直接放进去的，第二第三第n个参数全都用逗号分隔，直接放到后面 obj.myFun.call(db,&#39;成都&#39;, ... ,&#39;string&#39; )； apply的所有参数都必须放在一个数组里面传进去 obj.myFun.apply(db,[&#39;成都&#39;, ..., &#39;string&#39; ]); bind除了返回是函数以外，它 的参数和call 一样。 123obj.myFun.call(db,'成都','上海')； // 德玛 年龄 99 来自 成都去往上海obj.myFun.apply(db,['成都','上海']); // 德玛 年龄 99 来自 成都去往上海 obj.myFun.bind(db,'成都','上海')(); // 德玛 年龄 99 来自 成都去往上海 Event LoopEvent Loop 是一个很重要的概念，指的是计算机系统的一种运行机制。 JavaScript语言就采用这种机制，来解决单线程运行带来的一些问题。 想要理解Event Loop，就要从程序的运行模式讲起。运行以后的程序叫做“进程”（process），一般情况下，一个进程一次只能执行一个任务。 如果有很多任务需要执行，不外乎三种解决方法。 （1）排队。因为一个进程一次只能执行一个任务，只好等前面的任务执行完了，再执行后面的任务。 （2）新建进程。使用fork命令，为每个任务新建一个进程。 （3）新建线程。因为进程太耗费资源，所以如今的程序往往允许一个进程包含多个线程，由线程去完成任务。 进程和线程的详细解释，请看这里 以JavaScript语言为例，它是一种单线程语言，所有任务都在一个线程上完成，即采用上面的第一种方法。一旦遇到大量任务或者遇到一个耗时的任务，网页就会出现”假死”，因为JavaScript停不下来，也就无法响应用户的行为。 你也许会问，JavaScript为什么是单线程，难道不能实现为多线程吗？ 这跟历史有关系。JavaScript从诞生起就是单线程。==原因大概是不想让浏览器变得太复杂，因为多线程需要共享资源、且有可能修改彼此的运行结果，对于一种网页脚本语言来说，这就太复杂了。 JavaScript 的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript 的主要用途是与用户互动，以及操作 DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript 同时有两个线程，一个线程在某个 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？ 后来就约定俗成，JavaScript为一种单线程语言。（Worker API可以实现多线程，但是JavaScript本身始终是单线程的。） 如果某个任务很耗时，比如涉及很多I/O（输入/输出）操作，那么线程的运行大概是下面的样子。 上图的绿色部分是程序的运行时间，红色部分是等待时间。可以看到，由于I/O操作很慢，所以这个线程的大部分运行时间都在空等I/O操作的返回结果。这种运行方式称为”同步模式”（synchronous I/O）或”堵塞模式”（blocking I/O）。 如果采用多线程，同时运行多个任务，那很可能就是下面这样。 上图表明，多线程不仅占用多倍的系统资源，也闲置多倍的资源，这显然不合理。Event Loop就是为了解决这个问题而提出的。 “Event Loop是一个程序结构，用于等待和发送消息和事件。（a programming construct that waits for and dispatches events or messages in a program.）” 简单说，就是在程序中设置两个线程：一个负责程序本身的运行，称为”主线程”；另一个负责主线程与其他进程（主要是各种I/O操作）的通信，被称为”Event Loop线程”（可以译为”消息线程”）。 上图主线程的绿色部分，还是表示运行时间，而橙色部分表示空闲时间。每当遇到I/O的时候，主线程就让Event Loop线程去通知相应的I/O程序，然后接着往后运行，所以不存在红色的等待时间。等到I/O程序完成操作，Event Loop线程再把结果返回主线程。主线程就调用事先设定的回调函数，完成整个任务。 js 引擎执行异步代码而不用等待，是因有为有 消息队列和事件循环。 消息队列：消息队列是一个先进先出的队列，它里面存放着各种消息。 事件循环：事件循环是指主线程重复从消息队列中取消息、执行的过程。 实际上，主线程只会做一件事情，就是从消息队列里面取消息、执行消息，再取消息、再执行。当消息队列为空时，就会等待直到消息队列变成非空。而且主线程只有在将当前的消息执行完成后，才会去取下一个消息。这种机制就叫做事件循环机制，取一个消息并执行的过程叫做一次循环。 可以看到，由于多出了橙色的空闲时间，所以主线程得以运行更多的任务，这就提高了效率。这种运行方式称为”异步模式“（asynchronous I/O）或”非堵塞模式”（non-blocking mode）。 这正是JavaScript语言的运行方式。单线程模型虽然对JavaScript构成了很大的限制，但也因此使它具备了其他语言不具备的优势。如果部署得好，JavaScript程序是不会出现堵塞的，这就是为什么node.js平台可以用很少的资源，应付大流量访问的原因。 参考作者：阮一峰，链接地址：http://www.ruanyifeng.com/blog/2013/10/event_loop.html 跨域以及处理方法 &spades;&spades;&spades;怎样才会造成跨域问题: 调用接口的时候，当你调用接口的 域名|协议|端口 和你浏览器的 域名|协议|端口 不一致时，就会造成跨域问题。 JSONP123&lt;script src="http://www.a.com/script/1.js"&gt;&lt;/script&gt;&lt;img src="http://www.b.com/1.jpg"&gt;&lt;link href="http://www.c.com/1.css"&gt; 这种标签是不会遇到’跨域’问题的，严格上来说，这不是跨域，跨域是指在脚本代码中向非同源域发送HTTP请求，这只是跨站资源请求 那么我们可以试试看用这种跨站资源请求的方式来实现跨域HTTP请求 原理动态创建script标签，然后利用script中的src属性不受同源策略的影响约束来跨域获取数据 1234567891011121314151617181920212223242526272829303132333435363738function getJsonp (url, callback) &#123; if (!url) &#123;return &#125; //定义一个数组随机生成函数名 var a = ['a' , 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'] var r1 = Math.floor(Math.random()*10) var r2 = Math.floor(Math.random()*10) var r3 = Math.floor(Math.random()*10) //下边两行表明是在getJsonp这个函数下定义了一个随机的名字作为回调函数名字 var name = 'getJsonp' + a[r1] + a[r2] + a[r3] var cbname = 'getJsonp.' + name if (url.indexOf('?') === -1) &#123; url += '?jsonp=' + cbname &#125;else &#123; url += '&amp;jsonp=' + cbname &#125; console.log(url) //定义脚本 var script = document.createElement('script') getJsonp[name] = function(e) &#123; try&#123; //e为得到的数据 callback &amp;&amp; callback(e) &#125;catch (e)&#123; // &#125;finally&#123; //最后删除该函数与script元素 delete getJsonp[name] script.parentNode.removeChild(script) &#125; &#125; script.src = url document.getElementsByTagName('head')[0].appendChild(script)&#125;//跨域调用getJsonp('http://class.imooc.com/api/jsonp', function(response)&#123; console.log(response)&#125;) 简单一点，可以这样获取 1234567891011121314function myjsonp(obj) &#123; //定义一个处理Jsonp返回数据的回调函数 //直接在window["callback"] = function () &#123;&#125;定义回调更简单 myjsonp["callback"] = function(object) &#123; console.log(object) &#125; var script = document.createElement("script"); //组合请求URL script.src = obj.url + "?jsonp=myjsonp.callback"; document.getElementsByTagName("body")[0].appendChild(script); &#125;myjsonp(&#123; url:"http://class.imooc.com/api/jsonp",&#125;); CORS 对比 JSONP JSONP只能实现GET请求，而CORS支持所有类型的HTTP请求 使用CORS，开发者可以使用普通的XMLHttpRequest发起请求和获得数据，比起JSONP有更好的错误处理 JSONP主要被老的浏览器支持，它们往往不支持CORS，而绝大多数现代浏览器都已经支持了CORS CORS的整个过程都由浏览器自动完成，前端无需做任何设置，跟平时发送ajax请求并无差异。所以，实现CORS的关键在于服务器，只要服务器实现CORS接口，就可以实现跨域通信。 对于简单请求，浏览器会直接发送CORS请求，具体说来就是在header中加入origin请求头字段。同样，在响应头中，返回服务器设置的相关CORS头部字段，Access-Control-Allow-Origin字段为允许跨域请求的源。请求时浏览器在请求头的Origin中说明请求的源，服务器收到后发现允许该源跨域请求，则会成功返回。这里需要注意的是，尽管请求失败，但返回的状态码依然可能为200。 CORS字段介绍：Access-Control-Allow-Methods、Access-Control-Allow-Headers、Access-Control-Allow-Credentials、Access-Control-Max-Age 代码实例 前端代码与发送普通请求没有差异，我们只需在服务端设置即可，以node为例： 123456789var express = require('express');var app = express();var allowCrossDomain = function (req, res, next) &#123; res.header('Access-Control-Allow-Origin', 'http://localhost:3001'); res.header('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE'); res.header('Access-Control-Allow-Headers', 'Content-Type'); next();&#125;app.use(allowCrossDomain); 自定义首部字段为Content-Type的非简单请求则会被正常访问，当然，你也可以将Access-control-Allow-Methods和Access-Control-Allow-Headers这两个配置删掉，删掉之后，将仅支持简单请求进行跨域。 通过修改document.domain来跨子域如果主域相同，可以通过修改document.domain实现跨域。将子域和主域的document.domain设为同一个主域。前提条件是这两个域名必须属于同一个基础域名，而且协议、端口都要一致，否则无法利用document.domain实现跨域。 通过修改window.name来进行跨域window对象有一个name属性，该属性有个特征：在一个窗口（window）的生命周期内，窗口中载入的所有页面都是共享一个window.name的，每个页面对window.name都有读写的权限。载入过的所有页面的window对象，将持有地存储name属性 服务器端设置代理可以实现跨域Nginx代理 使用HTML5中新引进的window.postMessage方法来跨域传送数据通过Flash可以实现跨域手写一个ajax，不依赖第三方库123456789101112var xhr = new XMLHttpRequest();xhr.open("get", "http://www.somewhere-else.com/page", true);xhr.onreadystateChange = function() &#123; if(xhr.readyState === 4) &#123; if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt;= 300 || xhr.status === 304) &#123; alert(xhr.responseText); &#125; else &#123; alert("error ", xhr.status); &#125; &#125;&#125;xhr.send(null); 深拷贝和浅拷贝的区别浅拷贝（shallowCopy）只是增加了一个指针指向已存在的内存地址 如果是基本数据类型，名字和值都会储存在栈内存中 深拷贝（deepCopy）是增加了一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内存 如果是引用数据类型，名字存在栈内存中，值存在堆内存中，但是栈内存会提供一个引用的地址指向堆内存中的值 实现浅拷贝的方法 Object.assign方法 123456var obj = &#123; a: 1, b: 2&#125;var obj1 = Object.assign(obj);console.log(obj === obj1) // true 直接用=赋值 [].slice() 多层嵌套的情况是浅拷贝 [].concat() 多层嵌套的情况是浅拷贝 实现深拷贝的方法 for in 1234567891011//for in 递归实现深层的深拷贝var deepCopy = function(obj) &#123; if (typeof obj !== 'object') return; var newObj = obj instanceof Array ? [] : &#123;&#125;; for (var key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; newObj[key] = typeof obj[key] === 'object' ? deepCopy(obj[key]) : obj[key]; &#125; &#125; return newObj;&#125; 通过JSON对象来实现深拷贝 12345function deepClone2(obj) &#123; var _obj = JSON.stringify(obj), objClone = JSON.parse(_obj); return objClone;&#125; 缺点： 无法实现对对象中方法的深拷贝，会显示为undefined 通过jQuery的extend方法实现深拷贝 12var array = [1,2,3,4];var newArray = $.extend(true,[],array); // true为深拷贝，false为浅拷贝 lodash函数库实现深拷贝 1let result = _.cloneDeep(test) Reflect法 1234567891011121314// 代理法function deepClone(obj) &#123; if (!isObject(obj)) &#123; throw new Error('obj 不是一个对象！') &#125; let isArray = Array.isArray(obj) let cloneObj = isArray ? [...obj] : &#123; ...obj &#125; Reflect.ownKeys(cloneObj).forEach(key =&gt; &#123; cloneObj[key] = isObject(obj[key]) ? deepClone(obj[key]) : obj[key] &#125;) return cloneObj&#125; 手动实现深拷贝 1234567891011let obj1 = &#123; a: 1, b: 2&#125;let obj2 = &#123; a: obj1.a, b: obj1.b&#125;obj2.a = 3;alert(obj1.a); // 1alert(obj2.a); // 3 Object.assign() 如果对象的value是基本类型的话，也可以用Object.assign来实现深拷贝，但是要把它赋值给一个空对象 1234567var obj = &#123; a: 1, b: 2&#125;var obj1 = Object.assign(&#123;&#125;, obj); // obj赋值给一个空&#123;&#125;obj1.a = 3;console.log(obj.a)；// 1 用slice实现对数组的深拷贝 用concat实现对数组的深拷贝 直接使用var newObj = Object.create(oldObj)，可以达到深拷贝的效果 使用扩展运算符实现深拷贝 用扩展运算符对数组或者对象进行拷贝时，只能扩展和深拷贝第一层的值，对于第二层极其以后的值，扩展运算符将不能对其进行打散扩展，也不能对其进行深拷贝，即嵌套后的对象结构无法进行深拷贝 123456// 当value是基本数据类型，比如String，Number，Boolean时，是可以使用拓展运算符进行深拷贝的// 当value是引用类型的值，比如Object，Array，引用类型进行深拷贝也只是拷贝了引用地址，所以属于浅拷贝var car = &#123;brand: "BMW", price: "380000", length: "5米"&#125;var car1 = &#123; ...car, price: "500000" &#125;console.log(car1); // &#123; brand: "BMW", price: "500000", length: "5米" &#125;console.log(car); // &#123; brand: "BMW", price: "380000", length: "5米" &#125; arguments中的callee在函数内部，有两个特殊的对象：arguments 和 this。其中， arguments 的主要用途是保存函数参数， 但这个对象还有一个名叫 callee 的属性，该属性是一个指针，指向拥有这个 arguments 对象的函数。 请看下面这个非常经典的阶乘函数 1234567function factorial(num)&#123; if (num &lt;=1) &#123; return 1; &#125; else &#123; return num * factorial(num-1) &#125; &#125; 定义阶乘函数一般都要用到递归算法；如上面的代码所示，在函数有名字，而且名字以后也不会变 的情况下，这样定义没有问题。但问题是这个函数的执行与函数名 factorial 紧紧耦合在了一起。为 了消除这种紧密耦合的现象，可以像下面这样使用 arguments.callee 1234567function factorial(num)&#123; if (num &lt;=1) &#123; return 1; &#125; else &#123; return num * arguments.callee(num-1); &#125; &#125; 在这个重写后的 factorial()函数的函数体内，没有再引用函数名 factorial。这样，无论引用 函数时使用的是什么名字，都可以保证正常完成递归调用。例如 12345678910111213function factorial(num)&#123; if(num &lt;= 1)&#123; return 1; &#125;else&#123; return num * arguments.callee(num-1); &#125;&#125;var trueFactorial = factorial;alert(trueFactorial(5)); //120 factorial = function() &#123; return 0;&#125; alert(trueFactorial(5));// 120 如果没有使用arguments.callee，将返回0 如何实现私有变量闭包 + defineProperty，已经可以很精细地定义和使用属性。 1234567891011121314function createAccessor(obj, propName, value) &#123; var accessor = &#123; get: function() &#123; return value &#125;, set: function(v) &#123; value = v &#125; &#125; Object.defineProperty(obj, propName, &#123; get: accessor.get &#125;) return accessor&#125; 闭包定义局部变量（自执行函数）123456789101112131415161718192021222324252627282930313233343536var PClass = (function()&#123; var a = '私有变量'; var getA = function()&#123; console.log(a, '私有方法') &#125; var setA = function(val)&#123; a = val &#125; function P ()&#123; this.b = '变量b，外部可访问' &#125; P.prototype = &#123; getB : function()&#123; console.log(this.b,'--- 获取对象公有属性b ---') &#125;, setType: function(a,val)&#123; if(a == 'a')&#123; setA(val); &#125; &#125;, getType: function(a)&#123; if(a == 'a')&#123; getA(); &#125; &#125; &#125; return P&#125;()) var pclass = new PClass() pclass.b //打印 变量b，外部可访问pclass.getB() //打印 变量b，外部可访问 --- 获取对象公有属性b ---console.log(pclass) //打印 P &#123;b: "变量b，外部可访问"&#125;// 通过对外开放的另一方法我们可以获取到了私有变量apclass.getType('a') //打印 私有变量 私有方法 根据上面的例子我们不难发现，私有变量只能再闭包内部访问，外部无法访问，当时这个方案并不完美,为什么这么说，比如我们再new 一个 pclass1 ， 然后修改a属性的值，你会发现pclass的a值也发生了变化 闭包定义局部变量（非自执行函数）12345678910111213141516171819202122232425262728293031323334353637var pClass = function()&#123; var a = '私有变量'; var getA = function()&#123; console.log(a, '私有方法') &#125; var setA = function(val)&#123; a = val &#125; function P ()&#123; this.b = '变量b，外部可访问' &#125; P.prototype = &#123; getB : function()&#123; console.log(this.b,'--- 获取对象公有属性b ---') &#125;, setType: function(a,val)&#123; if(a == 'a')&#123; setA(val); &#125; &#125;, getType: function(a)&#123; if(a == 'a')&#123; getA(); &#125; &#125; &#125; return P&#125; var PClass1 = pClass(); //开辟了一个函数作用域var PClass2 = pClass(); //重新开辟了一个函数作用域var pclass1 = new PClass1();var pclass2 = new PClass2();pclass1.setType('a', '修改私有属性a的值');pclass1.getType('a'); //打印 修改私有属性a的值 私有方法pclass2.getType('a'); //打印 私有变量 私有方法 使用ES6扩展的类型symbol类型定义1234567891011121314151617181920212223var Pclass = (function()&#123; const a = Symbol('a'); const m = Symbol('m'); class Pclass &#123; constructor()&#123; this[a] = 'a这是私有变量'; this.b = '变量B-外部可访问'; this[m] = function()&#123; console.log('私有方法'); &#125; &#125; getA()&#123; console.log(this[a]); &#125; getM()&#123; console.log(this[m]); &#125; &#125; return Pclass&#125;()) let pc = new Pclass() console.log(pc) //打印 Pclass &#123;b: "变量B-外部可访问", Symbol(a): "这是私有变量", Symbol(m): ƒ&#125; 由上述代码我们可以发现 只要不把 a = Symbol(‘a’); m = Symbol(‘m’) 这两个引用对外暴露，外部是无法访问到定义的私有变量a，和私有方法m， 因为他们的真实属性名称是a, m 这两个引用，而且是唯一的。 使用ES6扩展的类型WeakMap类型定义先来解释下WeakMap类型, 该类型数据是一个键-值（key-val）对的集合，只不过他的键（key）是一个引用，不同于一般的键-值。WeakMap 的使用如下。 123456const wm = new WeakMap();const a = &#123;&#125;, b = &#123;&#125;;wm.set(a, '这是a对象键的值');wm.set(b, '这是b对象键的值');console.log(wm.get(a)) //打印 这是a对象键的值console.log(wm.get(b)) //打印 这是b对象键的值 解释了WeakMap类型数据，那下面来写一个基于WeakMap类型的私有变量，私有属性吧。 12345678910111213141516171819202122var Pclass = (function()&#123; const aa = new WeakMap(); const mt = new WeakMap(); class Pclass &#123; constructor()&#123; this.b = 'b这是公有变量'; aa.set(this, '私有变量aa') mt.set(this, function()&#123; console.log('私有方法mt') &#125;) &#125; getA()&#123; console.log(aa.get(this)); &#125; getM()&#123; console.log(mt.get(this)); &#125; &#125; return Pclass&#125;())let pc = new Pclass() console.log(pc) // Pclass &#123;b: "b这是公有变量"&#125; 同上述代码我们可以发现 只要不把 aa = new WeakMap(); m = new WeakMap()这两个集合对外开放 外部是无法访问到定义的私有变量a，和私有方法m， 因为他们的真实属性名称是a, m 这两个引用，而且是唯一的。 fill()方法怎么用fill(value, start, end) 方法用于将一个固定值替换数组的元素。 123var fruits = ["Banana", "Orange", "Apple", "Mango"];fruits.fill("Runoob");// fruits输出结果 Runoob,Runoob,Runoob,Runoob 参数 描述 value 必需。填充的值。 start 可选。开始填充位置。 end 可选。停止填充位置 (默认为 array.length) 字符串中所有单词的首字母都转换为大写1234name = 'aaa bbb ccc';uw=name.replace(/\b\w+\b/g, function(word)&#123; return word.substring(0,1).toUpperCase()+word.substring(1);&#125; ); 事件绑定的方法在JavaScript中，有三种常用的绑定事件的方法： 在DOM元素中直接绑定我们可以在DOM元素上绑定onclick、onmouseover、onmouseout、onmousedown、onmouseup、ondblclick、onkeydown、onkeypress、onkeyup等。但不符合样式、行为、结构 三者分离的概念 在JavaScript代码中绑定在JavaScript代码中（即 script 标签内）绑定事件实现了JavaScript代码与HTML标签分离，文档结构清晰，便于管理和开发。 绑定事件监听函数在W3C中—事件监听有3个阶段，依次是捕获阶段、目标阶段、冒泡阶段。 语法：element.addEventListener(‘事件’, 监听函数, 捕捉/冒泡) event（事件） : （必需）事件名，支持所有 DOM事件 。 function（监听函数）：（必需）指定要事件触发时执行的函数。 useCapture（是否捕捉）：（可选）指定事件是否在捕获或冒泡阶段执行。true，捕获。false，冒泡。默认false。 细节1、事件名，一律不带on（IE除外）； 2、绑定事件函数中的“this”指绑定该事件的对象； 3、执行顺序，是按绑定顺序来执行的； JS实现数组去重 &spades;&spades;&spades;遍历数组法它是最简单的数组去重方法（indexOf方法） 实现思路：新建一个数组，遍历去要重的数组，当值不在新数组的时候（indexOf为-1）就加入该新数组中； 12345678910var arr=[2,8,5,0,5,2,6,7,2];function unique1(arr)&#123; var hash=[]; for (var i = 0; i &lt; arr.length; i++) &#123; if(hash.indexOf(arr[i])==-1)&#123; hash.push(arr[i]); &#125; &#125; return hash;&#125; 数组下标判断法调用indexOf方法，性能和方法1差不多 实现思路：如果当前数组的第 i 项在当前数组中第一次出现的位置不是 i，那么表示第 i 项是重复的，忽略掉。否则存入结果数组。 123456789function unique2(arr)&#123; var hash=[]; for (var i = 0; i &lt; arr.length; i++) &#123; if(arr.indexOf(arr[i])==i)&#123; hash.push(arr[i]); &#125; &#125; return hash;&#125; 排序后相邻去除法实现思路：给传入的数组排序，排序后相同的值会相邻，然后遍历排序后数组时，新数组只加入不与前一值重复的值。 12345678910function unique3(arr)&#123; arr.sort(); var hash=[arr[0]]; for (var i = 1; i &lt; arr.length; i++) &#123; if(arr[i]!=hash[hash.length-1])&#123; hash.push(arr[i]); &#125; &#125; return hash;&#125; 优化遍历数组法（推荐）实现思路：双层循环，外循环表示从0到arr.length，内循环表示从i+1到arr.length 将没重复的右边值放入新数组。（检测到有重复值时终止当前循环同时进入外层循环的下一轮判断） 123456789101112function unique4(arr)&#123; var hash=[]; for (var i = 0; i &lt; arr.length; i++) &#123; for (var j = i+1; j &lt; arr.length; j++) &#123; if(arr[i]===arr[j])&#123; ++i; &#125; &#125; hash.push(arr[i]); &#125; return hash;&#125; ES6实现基本思路：ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。 Set函数可以接受一个数组（或类似数组的对象）作为参数，用来初始化。 1234function unique5(arr)&#123; var x = new Set(arr); return [...x];&#125; js防抖和节流 &spades;&spades;&spades;在进行窗口的resize、scroll，输入框内容校验等操作时，如果事件处理函数调用的频率无限制，会加重浏览器的负担，导致用户体验非常糟糕。此时我们可以采用debounce（防抖）和throttle（节流）的方式来减少调用频率，同时又不影响实际效果。 函数防抖（debounce）当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。如下图，持续触发scroll事件时，并不执行handle函数，当1000毫秒内没有触发scroll事件时，才会延时触发scroll事件。 1234567891011121314// 防抖function debounce(fn, wait) &#123; var timeout = null; return function() &#123; if (timeout !== null) clearTimeout(timeout); timeout = setTimeout(fn, wait); &#125;&#125;// 处理函数function handle() &#123; console.log(Math.random()); &#125;// 滚动事件window.addEventListener('scroll', debounce(handle, 1000)); 函数节流（throttle）当持续触发事件时，保证一定时间段内只调用一次事件处理函数。节流通俗解释就比如我们水龙头放水，阀门一打开，水哗哗的往下流，秉着勤俭节约的优良传统美德，我们要把水龙头关小点，最好是如我们心意按照一定规律在某个时间间隔内一滴一滴的往下滴。如下图，持续触发scroll事件时，并不立即执行handle函数，每隔1000毫秒才会执行一次handle函数。 当持续触发事件时，保证在一定时间内只调用一次事件处理函数，意思就是说，假设一个用户一直触发这个函数，且每次触发小于既定值，函数节流会每隔这个时间调用一次用一句话总结防抖和节流的区别：防抖是将多次执行变为最后一次执行，节流是将多次执行变为每隔一段时间执行 函数节流主要有两种实现方法：时间戳和定时器。接下来分别用两种方法实现throttle~ 12345678910111213141516//时间戳var throttle = function(func, delay) &#123; var prev = Date.now(); return function() &#123; var context = this; var args = arguments; var now = Date.now(); if (now - prev &gt;= delay) &#123; func.apply(context, args); prev = Date.now(); &#125; &#125; &#125; function handle() &#123; console.log(Math.random()); &#125; window.addEventListener('scroll', throttle(handle, 1000)); 当高频事件触发时，第一次会立即执行，而后再怎么频繁地触发事件，也都是每delay时间才执行一次。而当最后一次事件触发完毕后，事件也不会再被执行了 123456789101112131415161718// 节流throttle代码（定时器）：var throttle = function(func, delay) &#123; var timer = null; return function() &#123; var context = this; var args = arguments; if (!timer) &#123; timer = setTimeout(function() &#123; func.apply(context, args); timer = null; &#125;, delay); &#125; &#125; &#125; function handle() &#123; console.log(Math.random()); &#125; window.addEventListener('scroll', throttle(handle, 1000)); 当触发事件的时候，我们设置一个定时器，再次触发事件的时候，如果定时器存在，就不执行，直到delay时间后，定时器执行执行函数，并且清空定时器，这样就可以设置下个定时器。当第一次触发事件时，不会立即执行函数，而是在delay秒后才执行。而后再怎么频繁触发事件，也都是每delay时间才执行一次。当最后一次停止触发后，由于定时器的delay延迟，可能还会执行一次函数。 参考文章：http://www.cnblogs.com/coco1s/p/5499469.html JS单例模式单例模式 (Singleton) 的实现在于保证一个特定类只有一个实例，第二次使用同一个类创建新对象的时候，应该得到与第一次创建对象完全相同的对象。当创建一个新对象时，实际上没有其他对象与其类似，因为新对象已经是单例了 {a:1} === {a:1} // false 。 但是如何在对构造函数使用 new 操作符创建多个对象的时候仅获取一个单例对象呢 静态属性中的实例在构造函数的静态属性中缓存该实例，缺点在于 instance 属性是公开可访问的属性，在外部代码中可能会修改该属性。 1234567891011function Universe() &#123; // 判断是否已经有单例了 if (typeof Universe.instance === 'object') &#123; return Universe.instance &#125; Universe.instance = this return this&#125;var uni1 = new Universe()var uni2 = new Universe()uni1 === uni2 // true 闭包中的实例可以把实例封装在闭包中，这样可以保证该实例的私有性并且保证该实例不会在构造函数之外被修改，代价是带来了额外的闭包开销。 123456789function Universe() &#123; var instance = this Universe = function() &#123; // 重写构造函数 return instance &#125;&#125;var uni1 = new Universe()var uni2 = new Universe()uni1 === uni2 // true 当第一次调用构造函数时，它正常返回 this ，然后在以后调用时，它将会执行重写构造函数，这个构造函数通过闭包访问了私有 instance 变量，并且简单的返回了该 instance。 或者这样 123456789101112131415161718192021(function () &#123; var Singleton = function (name) &#123; this.name = name; &#125; Singleton.prototype.getName = function () &#123; return this.name; &#125; //获取实例对象 var getInstance = (function (name) &#123; var instance = null; return function (name) &#123; if (!instance) &#123; instance = new Singleton(name) &#125; return instance; &#125; &#125;)() //因为返回的是函数不执行的话 得不到实例 var a = getInstance('aa') var b = getInstance('bb') console.log(a === b)&#125;)() ES612345678910111213class Singleton &#123; constructor(name) &#123; this.name = name; this.instance = null; &#125; // 构造一个广为人知的接口，供用户对该类进行实例化 static getInstance(name) &#123; if(!this.instance) &#123; this.instance = new Singleton(name); &#125; return this.instance; &#125;&#125;]]></content>
      <categories>
        <category>前端知识点总结</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端知识点总结——ES6]]></title>
    <url>%2F2020%2F06%2F09%2F%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94ES6%2F</url>
    <content type="text"><![CDATA[对ES6有什么了解 从以下几个方面去聊 let和constvar声明的变量会挂载在window上，而let和const声明的变量不会； 12345678var a = 100;console.log(a,window.a); // 100 100let b = 10;console.log(b,window.b); // 10 undefinedconst c = 1;console.log(c,window.c); // 1 undefined var声明变量存在变量提升，let和const不存在变量提升； 123456console.log(a); // undefined ===&gt; a已声明还没赋值，默认得到undefined值var a = 100;console.log(b); // 报错：b is not defined ===&gt; 找不到b这个变量let b = 10;console.log(c); // 报错：c is not defined ===&gt; 找不到c这个变量const c = 10; let和const声明形成块作用域； 1234567if(1)&#123; var a = 100; let b = 10;&#125;console.log(a); // 100console.log(b) // 报错：b is not defined ===&gt; 找不到b这个变量 同一作用域下let和const不能声明同名变量，而var可以； 123456789var a = 100;console.log(a); // 100var a = 10;console.log(a); // 10let a = 100;let a = 10;// 控制台报错：Identifier 'a' has already been declared ===&gt; 标识符a已经被声明了。 暂存死区 1234567var a = 100;if(1)&#123; //在当前块作用域中存在a使用let/const声明的情况下，给a赋值10时，只会在当前作用域找变量a， a = 10; // 而这时，还未到声明时候，所以控制台Error:a is not defined let a = 1;&#125; const 1231、一旦声明必须赋值,不能使用null占位。2、声明后不能再修改3、如果声明的是复合类型数据，可以修改其属性 解构赋值ES6拓展PromiseClass Promise介绍一下 &spades; &spades; &spades; 解决异步执行。另外回调函数和事件也可以解决异步执行的问题 回调与Promise12345678910111213141516function f() &#123; return new Promise(resolve =&gt; &#123; setTimeout(function () &#123; resolve(); &#125;, 1000) &#125;)&#125;f().then(function() &#123; console.log(1);return f();&#125;).then(function () &#123; console.log(2)&#125;)...... promise新建后立即执行，所以首先输出的是promise，然后then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行。 对比回调和Promise的流程控制回调函数不会重复地执行；调用的resolve全为自己所书写的流程，很大程度改善了反转控制的问题 错误处理 then方法中的第二个参数，即为失败时做的事情 1234567891011121314151617// then(resolve, reject)function f() &#123; return new Promise((resolve,reject)=&gt; &#123; if (val) &#123; resolve() &#125;else&#123; reject() &#125; &#125;)&#125;f(false).then(function() &#123; console.log(1);return f(); //对应resolve（）&#125;,function () &#123; console.log(2); //对应reject（）&#125;)... catch then()方法中无reject()的失败处理则往下走，直至被catch捕获 12345f(false).then()&#123;&#125;.then()&#123;&#125;....catch(e =&gt; &#123;...&#125; finally 不论成功或者失败，finally中的内容一定执行 Promise中的三种状态状态的改变不可逆，一旦决议就不能再修改，总的来说呢，就是Promise对于错误处理机制的理解。如果错误已经捕获了，那么错误不会继续传递下去。如果错误没有被捕获，那么错误会隐式传递下去，直到有错误处理函数来捕获这个错误。 pending（进行中）——&gt; fulfilled（已成功） pending（进行中）——&gt; rejected（已失败） Promise.all() &spades; 可以把多个Promise实例包装成一个新的Promise实例 1Promise.all([Promise1, Promise2, Promise3, Promise4, Promise5]) 所有成功则决议成功 Promise.all([]) 直接决议为成功 Promise.race([…, …, …,])只要有一个决议了（成功或者失败），j就返回；传入数组无反应 Promise.resolve()和Promise.reject() 传入一个普通的值 传递一个Promise实例 传递一个thenable 12345let obj = &#123; then (cb) &#123;&#125; oth () &#123;&#125;&#125;Promise.resolve(obj).then(data =&gt;&#123;&#125;) 小案例 页面中有个板块需要多张图片加载完后才能进行展示 1234567891011121314const loadImg = src =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; const img = new Image(); img.src = src; img.onload = () =&gt; &#123;resolve(img)&#125; img.onerror = (e) =&gt; &#123;reject(e)&#125; &#125;)&#125;const imgs =['url', 'url', 'url']Promise.all(imgs.map(src =&gt; loadImg(src))).then(arr =&gt; &#123; arr.forEach(img =&gt; &#123; document.body.appendChild(img) &#125;)&#125;) Promise封装异步1234567891011121314151617181920export default api = &#123; getMethods(url) &#123; return new Promise(function (resolve, reject) &#123; axios.get(url).then(res =&gt; &#123; resolve(res) &#125;).catch(err =&gt; &#123; reject(err) &#125;) &#125;) &#125;, postMethods: function (url, par) &#123; return new Promise(function (resolve, reject) &#123; axios.post(url, par).then(res =&gt; &#123; resolve(res) &#125;).catch(err =&gt; &#123; reject(err) &#125;) &#125;) &#125;&#125; 引用 12345678910111213import api from 'api' api.getMethods('/api/xxx').then(res =&gt; &#123; console.log(res)&#125;, err =&gt; &#123; console.log(err)&#125;) api.postMethods('/api/xxx', &#123; id: 1, name: 'xxx' &#125;).then(res =&gt; &#123; console.log(res)&#125;).catch(err =&gt; &#123; console.log(err)&#125;) 将原生的ajax封装成promise123456789101112131415var myNewAjax=function(url, data)&#123; return new Promise(function(resolve,reject)&#123; var xhr = new XMLHttpRequest(); xhr.open('get',url); xhr.send(data); xhr.onreadystatechange=function()&#123; if(xhr.status==200&amp;&amp;xhr.readyState==4)&#123; var json=JSON.parse(xhr.responseText); resolve(json) &#125;else if(xhr.readyState==4&amp;&amp;xhr.status!=200)&#123; reject('error'); &#125; &#125; &#125;)&#125; Promise和async的区别async/await是基于promise实现的，他不能用于普通的回调函数async/await使得异步代码看起来像同步代码async/await与Promise一样，是非阻塞的。 setTimeout 和 Promise哪一个先执行1234567891011121314151617181920async function async1() &#123; console.log("async1 start"); // 2 await async2(); console.log("async1 end"); // 6&#125;async function async2() &#123; console.log( 'async2'); // 3&#125;console.log("script start"); //1setTimeout(function () &#123; console.log("settimeout");// 8&#125;,0);async1();new Promise(function (resolve) &#123; console.log("promise1"); // 4 resolve();&#125;).then(function () &#123; console.log("promise2"); // 7&#125;);console.log('script end'); // 5 输出结果 12345678// script start// async1 start// async2// promise1// script end// async1 end// promise2// settimeout await async2();//执行这一句后，输出async2后，await会让出当前线程，将后面的代码加到任务队列中，然后继续执行test()函数后面的同步代码执行到setTimeout函数时，将其回调函数加入队列(此队列与promise队列不是同一个队列，执行的优先级低于promise)。继续执行 创建promise对象里面的代码属于同步代码，promise的异步性体现在then与catch处，所以promise1被输出，然后将then函数的代码加入队列，继续执行同步代码，输出script end。 至此同步代码执行完毕，开始从队列中调取任务执行，由于刚刚提到过，setTimeout的任务队列优先级低于promise队列，所以首先执行promise队列的第一个任务，即执行async1中await后面的代码，输出async1 end。 然后执行then方法的部分，输出promise2。最后promise队列中任务执行完毕，再执行setTimeout的任务队列，输出settimeout。 至此，该题的输出结果分析完毕了，这类的执行结果可以用一句话总结，先执行同步代码，遇到异步代码就先加入队列，然后按入队的顺序执行异步代码，最后执行setTimeout队列的代码。 补充一下队列任务优先级：promise.Trick()&gt;promise的回调&gt;setTimeout&gt;setImmediate async和await源码(手写async await的最简实现)介绍 优缺点 优点。相对于promise，async/await处理 then 的调用链，代码要清晰很多，几乎和同步代码一样 缺点。滥用 await 可能会导致性能问题，因为 await 会阻塞代码 async 顾名思义，就是异步的意思， 看上去是一个异步标识，就是告诉我们这个函数中有异步执行的代码。 await 等待右侧表达式的结果，这个结果是promise对象或者其他值。如果它等到的不是一个 promise 对象，那 await 表达式的运算结果就是它等到的东西。如果它等到的是一个 promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。 12345678910111213141516171819202122async function getData_1 () &#123; return '100'&#125;function getData_2 () &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve('200') &#125;, 2000) &#125;)&#125;async function run () &#123; const data_1 = await getData_1(); console.log(data_1); const data_2 = await getData_2(); console.log(data_2);&#125;run (); getData_1 前面即使不声明async，使用await也是可以的， 因为await 啥都能等！ 1.如果等到的是promise， 它就把promise的resolve的参数返回， 2.如果等到的是普通东西，就直接返回这个东西。==== 就像上面的data_1 , 就算 getData_1 没有async 它的结果也一样的。在run函数中， data_1 后的代码需要getData_1 执行完毕才会执行， data_1 得出以后， data_2其实会2秒之后才会得出， 但是此时，它会等2秒，直到data_2得出以后，才会执行后面的console 解题 async函数是generator函数的语法糖，那么到底是怎么样一个糖呢？让我们来一层层的剥开它的糖衣。 前言 如果让你手写async函数的实现，你是不是会觉得很复杂？这篇文章带你用20行搞定它的核心。 经常有人说async函数是generator函数的语法糖，那么到底是怎么样一个糖呢？让我们来一层层的剥开它的糖衣。 有的同学想说，既然用了generator函数何必还要实现async呢？ 这篇文章的目的就是带大家理解清楚async和generator之间到底是如何相互协作，管理异步的。 示例 123456789101112const getData = () =&gt; new Promise(resolve =&gt; setTimeout(() =&gt; resolve("data"), 1000))async function test() &#123; const data = await getData() console.log('data: ', data); const data2 = await getData() console.log('data2: ', data2); return 'success'&#125;// 这样的一个函数 应该再1秒后打印data 再过一秒打印data2 最后打印successtest().then(res =&gt; console.log(res)) 思路 对于这个简单的案例来说，如果我们把它用generator函数表达，会是怎么样的呢？ 12345678function* testG() &#123; // await被编译成了yield const data = yield getData() console.log('data: ', data); const data2 = yield getData() console.log('data2: ', data2); return 'success'&#125; 我们知道，generator函数是不会自动执行的，每一次调用它的next方法，会停留在下一个yield的位置。 利用这个特性，我们只要编写一个自动执行的函数，就可以让这个generator函数完全实现async函数的功能。 1234567891011121314const getData = () =&gt; new Promise(resolve =&gt; setTimeout(() =&gt; resolve("data"), 1000)) var test = asyncToGenerator( function* testG() &#123; // await被编译成了yield const data = yield getData() console.log('data: ', data); const data2 = yield getData() console.log('data2: ', data2); return 'success' &#125;)test().then(res =&gt; console.log(res)) 那么大体上的思路已经确定了， asyncToGenerator接受一个generator函数，返回一个promise， 关键就在于，里面用yield来划分的异步流程，应该如何自动执行。 如果是手动执行 在编写这个函数之前，我们先模拟手动去调用这个generator函数去一步步的把流程走完，有助于后面的思考。 12345678function* testG() &#123; // await被编译成了yield const data = yield getData() console.log('data: ', data); const data2 = yield getData() console.log('data2: ', data2); return 'success'&#125; 我们先调用testG生成一个迭代器 12// 返回了一个迭代器var gen = testG() 然后开始执行第一次next 123// 第一次调用next 停留在第一个yield的位置// 返回的promise里 包含了data需要的数据var dataPromise = gen.next() 这里返回了一个promise，就是第一次getData()所返回的promise，注意 1const data = yield getData() 这段代码要切割成左右两部分来看，第一次调用next，其实只是停留在了yield getData()这里， data的值并没有被确定。 那么什么时候data的值会被确定呢？ 下一次调用next的时候，传的参数会被作为上一个yield前面接受的值 也就是说，我们再次调用gen.next(&#39;这个参数才会被赋给data变量&#39;)的时候 1234567891011//data`的值才会被确定为`'这个参数才会被赋给data变量'gen.next('这个参数才会被赋给data变量')// 然后这里的data才有值const data = yield getData()// 然后打印出dataconsole.log('data: ', data);// 然后继续走到下一个yieldconst data2 = yield getData() 然后往下执行，直到遇到下一个yield，继续这样的流程… 这是generator函数设计的一个比较难理解的点，但是为了实现我们的目标，还是得去学习它~ 借助这个特性，如果我们这样去控制yield的流程，是不是就能实现异步串行了？ 1234567891011121314151617181920212223242526272829const getData = () =&gt; new Promise(resolve =&gt; setTimeout(() =&gt; resolve("data"), 1000))function* testG() &#123; // await被编译成了yield const data = yield getData() console.log('data: ', data); const data2 = yield getData() console.log('data2: ', data2); return 'success'&#125;var gen = testG()var dataPromise = gen.next()dataPromise.then((value1) =&gt; &#123; // data1的value被拿到了 继续调用next并且传递给data var data2Promise = gen.next(value1) // console.log('data: ', data); // 此时就会打印出data data2Promise.value.then((value2) =&gt; &#123; // data2的value拿到了 继续调用next并且传递value2 gen.next(value2) // console.log('data2: ', data2); // 此时就会打印出data2 &#125;)&#125;) 这样的一个看着像callback hell的调用，就可以让我们的generator函数把异步安排的明明白白。 实现 有了这样的思路，实现这个高阶函数就变得很简单了。 先整体看一下结构，有个印象，然后我们逐行注释讲解。 1234567891011121314151617181920212223function asyncToGenerator(generatorFunc) &#123; return function() &#123; const gen = generatorFunc.apply(this, arguments) return new Promise((resolve, reject) =&gt; &#123; function step(key, arg) &#123; let generatorResult try &#123; generatorResult = gen[key](arg) &#125; catch (error) &#123; return reject(error) &#125; const &#123; value, done &#125; = generatorResult if (done) &#123; return resolve(value) &#125; else &#123; return Promise.resolve(value).then(val =&gt; step('next', val), err =&gt; step('throw', err)) &#125; &#125; step("next") &#125;) &#125;&#125;复制代码 不多不少，22行。 接下来逐行讲解。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071function asyncToGenerator(generatorFunc) &#123; // 返回的是一个新的函数 return function() &#123; // 先调用generator函数 生成迭代器 // 对应 var gen = testG() const gen = generatorFunc.apply(this, arguments) // 返回一个promise 因为外部是用.then的方式 或者await的方式去使用这个函数的返回值的 // var test = asyncToGenerator(testG) // test().then(res =&gt; console.log(res)) return new Promise((resolve, reject) =&gt; &#123; // 内部定义一个step函数 用来一步一步的跨过yield的阻碍 // key有next和throw两种取值，分别对应了gen的next和throw方法 // arg参数则是用来把promise resolve出来的值交给下一个yield function step(key, arg) &#123; let generatorResult // 这个方法需要包裹在try catch中 // 如果报错了 就把promise给reject掉 外部通过.catch可以获取到错误 try &#123; generatorResult = gen[key](arg) &#125; catch (error) &#123; return reject(error) &#125; // gen.next() 得到的结果是一个 &#123; value, done &#125; 的结构 const &#123; value, done &#125; = generatorResult if (done) &#123; // 如果已经完成了 就直接resolve这个promise // 这个done是在最后一次调用next后才会为true // 以本文的例子来说 此时的结果是 &#123; done: true, value: 'success' &#125; // 这个value也就是generator函数最后的返回值 return resolve(value) &#125; else &#123; // 除了最后结束的时候外，每次调用gen.next() // 其实是返回 &#123; value: Promise, done: false &#125; 的结构， // 这里要注意的是Promise.resolve可以接受一个promise为参数 // 并且这个promise参数被resolve的时候，这个then才会被调用 return Promise.resolve( // 这个value对应的是yield后面的promise value ).then( // value这个promise被resove的时候，就会执行next // 并且只要done不是true的时候 就会递归的往下解开promise // 对应gen.next().value.then(value =&gt; &#123; // gen.next(value).value.then(value2 =&gt; &#123; // gen.next() // // // 此时done为true了 整个promise被resolve了 // // 最外部的test().then(res =&gt; console.log(res))的then就开始执行了 // &#125;) // &#125;) function onResolve(val) &#123; step("next", val) &#125;, // 如果promise被reject了 就再次进入step函数 // 不同的是，这次的try catch中调用的是gen.throw(err) // 那么自然就被catch到 然后把promise给reject掉啦 function onReject(err) &#123; step("throw", err) &#125;, ) &#125; &#125; step("next") &#125;) &#125;&#125; 参考作者：晨曦时梦见兮，链接：https://juejin.im/post/5e79e841f265da5726612b6e 迭代器 生成器了解吗ES6 新引入了 Generator 函数，可以通过 yield 关键字，把函数的执行流挂起，为改变执行流程提供了可能，从而为异步编程提供解决方案。 基本用法 Generator 函数组成Generator 有两个区分于普通函数的部分： 一是在 function 后面，函数名之前有个 * ； 函数内部有 yield 表达式。 其中 * 用来表示函数为 Generator 函数，yield 用来定义函数内部的状态。 12345678function* func()&#123; console.log("one"); yield '1'; console.log("two"); yield '2'; console.log("three"); return '3'; &#125; 调用 Generator 函数和调用普通函数一样，在函数名后面加上()即可，但是 Generator 函数不会像普通函数一样立即执行，而是返回一个指向内部状态对象的指针，所以要调用遍历器对象Iterator 的 next 方法，指针就会从函数头部或者上一次停下来的地方开始执行。 1234f.next(); // one // &#123;value: "1", done: false&#125; f.next(); // two // &#123;value: "2", done: false&#125; f.next(); // three // &#123;value: "3", done: true&#125; f.next(); // &#123;value: undefined, done: true&#125; 第一次调用 next 方法时，从 Generator 函数的头部开始执行，先是打印了 one ,执行到 yield 就停下来，并将yield 后边表达式的值 ‘1’，作为返回对象的 value 属性值，此时函数还没有执行完， 返回对象的 done 属性值是 false。 第二次调用 next 方法时，同上步 。 第三次调用 next 方法时，先是打印了 three ，然后执行了函数的返回操作，并将 return 后面的表达式的值，作为返回对象的 value 属性值，此时函数已经结束，多以 done 属性值为true 。 第四次调用 next 方法时， 此时函数已经执行完了，所以返回 value 属性值是 undefined ，done 属性值是 true 。如果执行第三步时，没有 return 语句的话，就直接返回 {value: undefined, done: true}。 函数返回的遍历器对象的方法next 方法 一般情况下，next 方法不传入参数的时候，yield 表达式的返回值是 undefined 。当 next 传入参数的时候，该参数会作为上一步yield的返回值。 12345678function* sendParameter()&#123; console.log("strat"); var x = yield '2'; console.log("one:" + x); var y = yield '3'; console.log("two:" + y); console.log("total:" + (x + y)); &#125; 12345678//next不传参var sendp1 = sendParameter(); sendp1.next(); // strat // &#123;value: "2", done: false&#125;sendp1.next(); // one:undefined // &#123;value: "3", done: false&#125; sendp1.next(); // two:undefined // total:NaN // &#123;value: undefined, done: true&#125; //next传参 var sendp2 = sendParameter(); sendp2.next(10); // strat // &#123;value: "2", done: false&#125; sendp2.next(20); // one:20 // &#123;value: "3", done: false&#125; sendp2.next(30); // two:30 // total:50 // &#123;value: undefined, done: true&#125; 除了使用 next ，还可以使用 for… of 循环遍历 Generator 函数生产的 Iterator 对象。 return 方法 return 方法返回给定值，并结束遍历 Generator 函数。 return 方法提供参数时，返回该参数；不提供参数时，返回 undefined 。 1234567891011121314151617function* foo()&#123; yield 1; yield 2; yield 3; &#125; var f = foo(); f.next(); // &#123;value: 1, done: false&#125; f.return("foo"); // &#123;value: "foo", done: true&#125; f.next(); // &#123;value: undefined, done: true&#125; //throw 方法 throw 方法可以再 Generator 函数体外面抛出异常，再函数体内部捕获。 var g = function* () &#123; try &#123; yield; &#125; catch (e) &#123; console.log('catch inner', e); &#125; &#125;; var i = g(); i.next(); try &#123; i.throw('a'); i.throw('b'); &#125; catch (e) &#123; console.log('catch outside', e); &#125; // catch inner a // catch outside b 遍历器对象抛出了两个错误，第一个被 Generator 函数内部捕获，第二个因为函数体内部的catch 函数已经执行过了，不会再捕获这个错误，所以这个错误就抛出 Generator 函数体，被函数体外的 catch 捕获。 yield* 表达式 yield* 表达式表示 yield 返回一个遍历器对象，用于在 Generator 函数内部，调用另一个 Generator 函数。 1234567891011121314151617181920function* callee() &#123; console.log('callee: ' + (yield)); &#125; function* caller() &#123; while (true) &#123; yield* callee(); &#125; &#125; const callerObj = caller(); callerObj.next(); // &#123;value: undefined, done: false&#125;callerObj.next("a"); // callee: a // &#123;value: undefined, done: false&#125; callerObj.next("b"); // callee: b // &#123;value: undefined, done: false&#125; // 等同于 function* caller() &#123; while (true) &#123; for (var value of callee) &#123; yield value; &#125; &#125; &#125; 使用场景实现 Iterator 为不具备 Iterator 接口的对象提供遍历方法。 12345678910function* objectEntries(obj) &#123; const propKeys = Reflect.ownKeys(obj); for (const propKey of propKeys) &#123; yield [propKey, obj[propKey]]; &#125; &#125; const jane = &#123; first: 'Jane', last: 'Doe' &#125;; for (const [key,value] of objectEntries(jane)) &#123; console.log(`$&#123;key&#125;: $&#123;value&#125;`); &#125; // first: Jane // last: Doe Reflect.ownKeys() 返回对象所有的属性，不管属性是否可枚举，包括 Symbol。 jane 原生是不具备 Iterator 接口无法通过 for… of遍历。这边用了 Generator 函数加上了 Iterator 接口，所以就可以遍历 jane 对象了。 for in /for of 区别遍历数组通常用for循环ES5的话也可以使用forEach，ES5具有遍历数组功能的还有map、filter、some、every、reduce、reduceRight等，只不过他们的返回结果不一样。但是使用foreach遍历数组的话，使用break不能中断循环，使用return也不能返回到外层函数 for in遍历数组的毛病 index索引为字符串型数字，不能直接进行几何运算 遍历顺序有可能不是按照实际数组的内部顺序 使用for in会遍历数组所有的可枚举属性，包括原型。例如上栗的原型方法method和name属性 所以for in更适合遍历对象，不要使用for in遍历数组 那么除了使用for循环，如何更简单的正确的遍历数组达到我们的期望呢（即不遍历method和name），ES6中的for of更胜一筹 12345var myArray=[1,2,4,5,6,7]myArray.name="数组";for (var value of myArray) &#123; console.log(value);&#125; 记住，for in遍历的是数组的索引（即键名），而for of遍历的是数组元素值 for of遍历的只是数组内的元素，而不包括数组的原型属性method和索引name for-of是ES6新增的功能 for-of这个方法避开了for-in循环的所有缺陷 与forEach()不同的是，它可以正确响应break、continue和return语句 for-of循环不仅支持数组，还支持大多数类数组对象，例如DOM NodeList对象。for-of循环也支持字符串遍历 遍历对象1234567891011Object.prototype.method=function()&#123; console.log(this);&#125;var myObject=&#123; a:1, b:2, c:3&#125;for (var key in myObject) &#123; console.log(key);&#125; for in 可以遍历到myObject的原型方法method,如果不想遍历原型方法和属性的话，可以在循环内部判断一下,hasOwnPropery方法可以判断某属性是否是该对象的实例属性，或者通过ES5的Object.keys(myObject)获取对象的实例属性组成的数组，不包括原型方法和属性 123456789for (var key in myObject) &#123; if（myObject.hasOwnProperty(key))&#123; console.log(key); &#125;&#125;for (var key of Object.keys(someObject)) &#123; console.log(key + ": " + someObject[key]);&#125; 总结 for…of适用遍历数/数组对象/字符串/map/set等拥有迭代器对象的集合。但是不能遍历对象，因为没有迭代器对象。与forEach()不同的是，它可以正确响应break、continue和return语句 for…of循环不支持普通对象，但如果你想迭代一个对象的属性，你可以用for…in循环（这也是它的本职工作）或内建的Object.keys()方法 补充js的对象遍历 JS对象遍历for-in遍历 for-in是为遍历对象而设计的，不适用于遍历数组。(遍历数组的缺点：数组的下标index值是数字，for-in遍历的index值”0”,”1”,”2”等是字符串) for-in循环存在缺陷：循环会遍历对象自身的和继承的可枚举属性(不含Symbol属性) 1234for (var index in arr)&#123; console.log(arr[index]); console.log(index);&#125; 使用Object.keys()遍历 返回一个数组,包括对象自身的(不含继承的)所有可枚举属性(不含Symbol属性). 1234var obj = &#123;'0':'a','1':'b','2':'c'&#125;;Object.keys(obj).forEach(function(key)&#123; console.log(key,obj[key]);&#125;); 使用Object.getOwnPropertyNames(obj)遍历 返回一个数组,包含对象自身的所有属性(不含Symbol属性,但是包括不可枚举属性). 1234var obj = &#123;'0':'a','1':'b','2':'c'&#125;;Object.getOwnPropertyNames(obj).forEach(function(key)&#123; console.log(key,obj[key]);&#125;); 使用Reflect.ownKeys(obj)遍历 返回一个数组,包含对象自身的所有属性,不管属性名是Symbol或字符串,也不管是否可枚举. 1234var obj = &#123;'0':'a','1':'b','2':'c'&#125;;Reflect.ownKeys(obj).forEach(function(key)&#123; console.log(key,obj[key]);&#125;); ES5和ES6继承 &spades;&spades;&spades;ES5继承 原型链实现继承 基本思想：利用原型让一个引用类型继承另一个引用类型的属性和方法，即让原型对象等于另一个类型的实例 1234567891011121314151617function SuperType()&#123; this.property = true;&#125;SuperType.prototype.getSuperValue = function()&#123; return this.property;&#125;;function SubType()&#123; this.subproperty = false;&#125;//继承SuperTypeSubType.prototype = new SuperType();SubType.prototype.getSubValue = function()&#123; return this.subproperty;&#125;;var instance = new SubType();alert(instance.getSuperValue()); //true 主要问题 最主要的问题来自包含引用类型值的原型，它会被所有实例共享 第二个问题是，创造子类型的实例时，不能向超类型的构造函数中传递参数 借用构造函数 主要思想：在子类型构造函数的内部调用超类型构造函数，通过使用apply()和call()方法可以在将来新创建的对象上执行构造函数 1234567891011121314function SuperType()&#123; this.colors = ["red","blue","green"];&#125;function SubType()&#123; //借调了超类型的构造函数 SuperType.call(this);&#125;var instance1 = new SubType();//["red","blue","green","black"]instance1.colors.push("black");console.log(instance1.colors);var instance2 = new SubType();//["red","blue","green"]console.log(instance2.colors); 主要问题 方法都在构造函数中定义，函数无法复用 在超类型中定义的方法，子类型不可见，结果所有类型都只能使用构造函数模式 组合继承 基本思想：将原型链和借用构造函数技术组合到一起。使用原型链实现对原型属性和方法的继承，用借用构造函数模式实现对实例属性的继承。这样既通过在原型上定义方法实现了函数复用，又能保证每个实例都有自己的属性 123456789101112131415161718function Supertype(name)&#123; this.name = name; this.colors = ["red","green","blue"];&#125;Supertype.prototype.sayName = function()&#123; console.log(this.name);&#125;;function Subtype(name,age)&#123; //call apply继承 Supertype.call(this,name); this.age = age;&#125;//原型链继承Subtype.prototype = new Supertype();Subtype.prototype.constructor = Subtype;Subtype.prototype.sayAge = function()&#123; console.log(this.age);&#125;; 主要问题：无论在什么情况下，都会调用两次超类型构造函数，一次是在创建子类型原型的时候，一次是在子类型构造函数的内部 原型式继承 基本思想：不用严格意义上的构造函数，借助原型可以根据已有的对象创建新对象，还不必因此创建自定义类型，因此最初有如下函数： 12345function object(o)&#123; function F()&#123;&#125; F.prototype = o; return new F();&#125; 从本质上讲，object()对传入其中的对象执行了一次浅复制 1234567891011var person = &#123; name:'Annika', friendes:['Alice','Joyce']&#125;;var anotherPerson = object(person);anotherPerson.name = 'Greg';anotherPerson.friendes.push('Rob');var yetAnotherPerson = object(person);yetAnotherPerson.name = 'Linda';yetAnotherPerson.friendes.push('Sophia');console.log(person.friends); //['Alice','Joyce','Rob','Sophia'] 在这个例子中，实际上相当于创建了person的两个副本。 ES5新增Object.create规范了原型式继承，接收两个参数，一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象，在传入一个参数的情况下，Object.create()和object()行为相同。 1234567891011var person = &#123; name:'Annika', friendes:['Alice','Joyce']&#125;;var anotherPerson = object.create(person,&#123; name:&#123; value:"Greg" &#125;&#125;);//用这种方法指定的任何属性都会覆盖掉原型对象上的同名属性console.log(anotherPerson.name); \\Greg 详见：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create 用处：创造两个相似的对象，但是包含引用类型的值的属性始终会共享响应的值 寄生式继承 基本思想：寄生式继承是与原型式继承紧密相关的一种思路，它创造一个仅用于封装继承过程的函数，在函数内部以某种方式增强对象，最后再返回对象。 12345678910function createAnother(original)&#123; //通过调用函数创建一个新对象 var clone = object(original); //以某种方式来增强对象 clone.sayHi = function()&#123; alert("Hi"); &#125;; //返回这个对象 return clone&#125; 主要问题：使用寄生式继承来为对象添加函数，会因为做不到函数复用而降低效率，这个与构造函数模式类似 寄生组合式继承 基本思想：通过借用构造函数来继承属性，通过原型链的混成形式来继承方法，不必为了指定子类型的原型而调用超类型的构造函数，只需要超类型的一个副本。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型 12345function inheritPrototype(Subtype,supertype)&#123; var prototype = object(supertype); //创建对象 prototype.constructor = subtype; //增强对象 subtype.prototype = prototype; //指定对象&#125; 因此，前面的例子可以改为如下的形式 123456789101112131415161718function Supertype(name)&#123; this.name = name; this.colors = ["red","green","blue"];&#125;Supertype.prototype.sayName = function()&#123; console.log(this.name);&#125;;function Subtype(name,age)&#123; //继承属性 Supertype.call(this,name); this.age = age;&#125;//继承方法inheritPrototype(Subtype,Supertype);Subtype.prototype.sayAge = function()&#123; console.log(this.age);&#125;; 优点：只调用了一次supertype构造函数，因此避免在subtype.prototype上创建不必要的，多余的属性，与此同时，原型链还能保持不变，还能正常使用instanceof 和isPrototypeOf()，因此，寄生组合式继承被认为是引用类型最理想的继承范式。 ES6中的继承es6的继承主要要注意的是class的继承。 基本用法：Class之间通过使用extends关键字，这比通过修改原型链实现继承，要方便清晰很多 12345678910class Colorpoint extends Point &#123; constructor(x,y,color)&#123; super(x,y); //调用父类的constructor(x,y) this.color = color &#125; toString()&#123; //调用父类的方法 return this.color + ' ' + super.toString(); &#125;&#125; 子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工，如果不调用super方法，子类就得不到this对象。因此，只有调用super之后，才可以使用this关键字。 prototype 和proto 一个继承语句同时存在两条继承链：一条实现属性继承，一条实现方法的继承 123class A extends B&#123;&#125;A.__proto__ === B; //继承属性A.prototype.__proto__ == B.prototype;//继承方法]]></content>
      <categories>
        <category>前端知识点总结</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端知识点总结——网络]]></title>
    <url>%2F2020%2F06%2F09%2F%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[对称加密和非对称加密 对称加密 对称加密指的就是加密和解密使用同一个秘钥，所以叫做对称加密。对称加密只有一个秘钥，作为私钥。 非对称加密 非对称加密指的是：加密和解密使用不同的秘钥，一把作为公开的公钥，另一把作为私钥。公钥加密的信息，只有私钥才能解密。私钥加密的信息，只有公钥才能解密。（A、B两把钥匙是拥有一定数学关系的一组秘钥） 区别 对称加密算法相比非对称加密算法来说，加解密的效率要高得多。但是缺陷在于对于秘钥的管理上，以及在非安全信道中通讯时，密钥交换的安全性不能保障。所以在实际的网络环境中，会将两者混合使用。 TCP和UDP的区别UDPUDP是无连接的协议 UDP不能保证可靠得交付数据 UDP是面向报文传输的 UDP没有拥塞控制 UDP的首部开销很小 不需要提前建立连接，“想发就发”，“无法保证数据在网络中是否丢失” TCPTCP是面向连接的协议 TCP的一个连接有两端（点对点的通信） TCP提供可靠的传输服务 TCP提供全双工的通信 TCP是面向字节流的协议 HTTP和HTTPS的区别 超文本传输协议HTTP协议 被用于在Web浏览器和网站服务器之间传递信息，HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码、账户金额、交易信息等。 安全套接字层超文本传输协议HTTPS 为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS，为了数据传输的安全，HTTPS在HTTP的基 础上加入了SSL/TLS协议，SSL/TLS依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。 客户端在使用HTTPS方式与Web服务器通信时的步骤 客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。 Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。 客户端的浏览器与Web服务器开始协商SSL/TLS连接的安全等级，也就是信息加密的等级。 客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。 Web服务器利用自己的私钥解密出会话密钥。 Web服务器利用会话密钥加密与客户端之间的通信。 主要区别 https协议需要到CA申请证书，一般免费证书较少，因而需要一定费用。 http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl/tls加密传输协议。 http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 http的连接很简单，是无状态的；HTTPS协议是由SSL/TLS+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。 浏览器页面渲染的流程1）解析文档构建DOM树HTML/XHTML/SVG：解析这三种文件后，会生成DOM树（DOM Tree）CSS：解析样式表，生成CSS规则树（CSS Rule Tree）JavaScript：解析脚本，通过DOM API和CSSOM API操作DOM Tree和CSS Rule Tree，与用户进行交互。 2）构建渲染树解析文档完成后，浏览器引擎会将 CSS Rule Tree 附着到DOM Tree 上，并根据DOM Tree 和 CSS Rule Tree构造 Rendering Tree（渲染树） 3）布局与绘制渲染树解析position, overflow, z-index等等属性，计算每一个渲染树节点的位置和大小，此过程被称为reflow。最后调用操作系统的Native GUI API完成绘制（repain） 解析html文档，遇到HTML标签时，构建DOM树。在构建DOM的过程中，如果遇到外联的样式声明或脚本声明，则暂停文档解析，创建新的网络连接，开始下载样式文件和脚本文件。样式文件下载完成后，构建CSS Rule DOM，脚本文件下载完成后，解释并立即执行。构建DOM的同时，结合CSS规则树完成页面渲染。如果DOM树先于CSS规则树构建完成，则在CSS规则树构建完成后，页面会发生一次重绘，将新构建的CSS规则应用于渲染树。 脚本文件对文档解析的影响在这个过程中，脚本文件的下载和执行是与文档解析同步进行的，脚本文件的下载和执行都会阻塞文档的解析，如果控制得不好，在用户体验上就会造成一定程度的影响。 css会阻塞页面渲染吗？会的话该怎么解决呢？1).css加载不会阻塞DOM树的解析2).css加载会阻塞DOM树的渲染3).css加载会阻塞后面js语句的执行 根据上一点浏览器渲染流程，可以知道，当css树还没构建完成时，页面是不会渲染到浏览器界面的，这也是为什么当css下载过慢时，会出现白屏的现象。因此，为了避免让用户看到长时间的白屏时间，我们应该尽可能的提高css加载速度 使用CDN(因为CDN会根据你的网络状况，替你挑选最近的一个具有缓存内容的节点为你提供资源，因此可以减少加载时间 对css进行压缩(可以用很多打包工具，比如webpack,gulp等，也可以通过开启gzip压缩 合理的使用缓存(设置cache-control,expires,以及E-tag都是不错的，不过要注意一个问题，就是文件更新后，你要避免缓存而带来的影响。其中一个解决防范是在文件名字后面加一个版本号 减少http请求数，将多个css文件合并，或者是干脆直接写成内联样式(内联样式的一个缺点就是不能缓存 利用媒体类型和查询来解除对渲染的阻塞。 浏览器缓存机制缓存位置分为：Service Worker；Memory Cache；Disk Cache；Push Cache（推送缓存）是HTTP/2中的内容，当前面三种缓存都没有命中时，它才会被使用 Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的 缓存策略分两种：强缓存、协商缓存。强缓存不会向服务器发送请求，直接从缓存中读取资源，如果命中并有效就使用缓存，否则就发请求，强缓存可以通过设置两种 HTTP Header 实现：Expires 和 Cache-Control；协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识（Etag,If-Modified-Since等）决定是否使用缓存的过程。如果未变会返回304告知浏览器直接使用缓存资源，否则返回最新资源。 缓存方法即其对比： 1）响应头Last-Modified和请求头加If-Modified-Since 弊端：如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被修改，服务端不能命中缓存导致发送相同的资源。因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源。 2）ETag和If-None-Match 两种方法对比： Last-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，但是Etag每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的Last-Modified也有可能不一致。 第二在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值。 第三在优先级上，服务器校验优先考虑Etag 常见http状态码 &spades;&spades;&spades;2xx表示成功的请求200 OK 请求成功。一般用于GET与POST请求 201 Created 已创建。成功请求并创建了新的资源 202 Accepted 已接受。已经接受请求，但未处理完成 203 Non-Authoritative Information 非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本 204 No Content 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档 205 Reset Content 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域 206 Partial Content 部分内容。服务器成功处理了部分GET请求 3xx表示重定向300 Multiple Choices 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择 301 Moved Permanently 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替 302 Found 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI 303 See Other 查看其它地址。与301类似。使用GET和POST请求查看 304 Not Modified 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 305 Use Proxy 使用代理。所请求的资源必须通过代理访问 306 Unused 已经被废弃的HTTP状态码 307 Temporary Redirect 临时重定向。与302类似。使用GET请求重定向 4xx表示客户端错误400 Bad Request 客户端请求的语法错误，服务器无法理解 401 Unauthorized 请求要求用户的身份认证 402 Payment Required 保留，将来使用 403 Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求 404 Not Found 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面 5xx表示服务器错误500 Internal Server Error 服务器内部错误，无法完成请求 501 Not Implemented 服务器不支持请求的功能，无法完成请求 502 Bad Gateway 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应 503 Service Unavailable 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中 504 Gateway Time-out 充当网关或代理的服务器，未及时从远端服务器获取请求 505 HTTP Version not supported 服务器不支持请求的HTTP协议的版本，无法完成处理 浏览器地址栏键入URL后会发生什么服务器处理请求并返回HTTP报文 浏览器解析渲染页面 连接结束 在地址栏里输入一个URL,到这个页面呈现出来，中间会发生什么？ 查找 disk cache 中是否有匹配，如有直接显示缓存内容 DNS域名解析 TCP连接 ，三次握手，建立连接，发送请求 发送HTTP请求 服务器收到请求，处理请求，返回响应 断开TCP连接，4次挥手 浏览器根据返回数据进行页面渲染 这是一个必考的面试问题， 输入url后，首先需要找到这个url域名的服务器ip,为了寻找这个ip，浏览器首先会寻找缓存，查看缓存中是否有记录，缓存的查找记录为：浏览器缓存-》系统缓存-》路由器缓存，缓存中没有则查找系统的hosts文件中是否有记录，如果没有则查询DNS服务器，得到服务器的ip地址后，浏览器根据这个ip以及相应的端口号，构造一个http请求，这个请求报文会包括这次请求的信息，主要是请求方法，请求说明和请求附带的数据，并将这个http请求封装在一个tcp包中，这个tcp包会依次经过传输层，网络层，数据链路层，物理层到达服务器，服务器解析这个请求来作出响应，返回相应的html给浏览器，因为html是一个树形结构，浏览器根据这个html来构建DOM树，在dom树的构建过程中如果遇到JS脚本和外部JS连接，则会停止构建DOM树来执行和下载相应的代码，这会造成阻塞，这就是为什么推荐JS代码应该放在html代码的后面，之后根据外部样式，内部样式，内联样式构建一个CSS对象模型树CSSOM树，构建完成后和DOM树合并为渲染树，这里主要做的是排除非视觉节点，比如script，meta标签和排除display为none的节点，之后进行布局，布局主要是确定各个元素的位置和尺寸，之后是渲染页面，因为html文件中会含有图片，视频，音频等资源，在解析DOM的过程中，遇到这些都会进行并行下载，浏览器对每个域的并行下载数量有一定的限制，一般是4-6个，当然在这些所有的请求中我们还需要关注的就是缓存，缓存一般通过Cache-Control、Last-Modify、Expires等首部字段控制。 Cache-Control和Expires的区别在于Cache-Control使用相对时间，Expires使用的是基于服务器 端的绝对时间，因为存在时差问题，一般采用Cache-Control，在请求这些有设置了缓存的数据时，会先 查看是否过期，如果没有过期则直接使用本地缓存，过期则请求并在服务器校验文件是否修改，如果上一次 响应设置了ETag值会在这次请求的时候作为If-None-Match的值交给服务器校验，如果一致，继续校验 Last-Modified，没有设置ETag则直接验证Last-Modified，再决定是否返回304 ## TCP连接、断开为什么三次握手和4次挥手 &spades;&spades;&spades;&spades;三次握手： 目的：为了准确无误地将数据送达目标处，TCP协议采用了三次握手策略。 发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带SYN/ACK标志的数据包以示传达确认信息。最后，发送端再回传一个带ACK标志的数据包，代表握手结束，建立连接。 “三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”;解决“网络中存在延迟的重复分组”的问题 例如以下情况如果使用两次握手： 如果客户端向服务器发送第一次连接请求在网络节点上滞留了，没有收到服务器的确认，于是又重新发送了一次连接请求服务器收到客户端的第二次请求发送确认，则连接建立完成服务器客户端进行数据传输，传输完成断开连接。此时，在网络上滞留的客户端第一次连接请求到达服务器，服务器发送确认连接但是客户端实际上并没有发送请求，因此不会理睬服务器发送的请求。但是服务器认为连接已完成，并等待客户端进行数据传输。这样会造成资源的浪费如果采用三次握手的话： 滞留在网络上的客户端第一次请求到达服务器之后，服务器发送确认，但实际上客户端器并没有发送请求，因此不会理睬服务器的确认，故不会发送确认，服务器等不到客户端的确认则连接建立失败。这样就防止了客户端失效的连接请求报文段突然又传到服务器 四次挥手： 为了持久连接，其特点是只要任意一端没有明确提出断开连接，则保持TCP连接状态；其好处是在于减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。另外，减少开销的时间，使HTTP请求和响应能更早结束，从而提高web页面的显示速度。 客户端发送一个带FIN标记的数据包给服务端；服务端分两次发送带ACK、FIN标志数据包给客户端；客户端发送带ACK标志的数据包给服务端并断开连接； 为什么要等待2MSL: 最后一个报文没有确认，确保发送方的ACK可以到达接收方，2MSL时间内没有收到，则接收方会重发 确保当前的连接的所有报文都已经过期 http协议不安全的原因，https是如何解决的http介绍下HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在WWW中使用的是HTTP/1.0的第六版，HTTP/1.1的规范化工作正在进行之中，而且HTTP-NG(Next Generation of HTTP)的建议已经提出。HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。 缺点呢1）通信使用明文，不加密，内容可能被窃听。2）不验证通信方的身份，因此可能会遭遇伪装。3）无法证明报文的完整性，所以有可能已遭篡改。 https:1)用SSL（安全套接层）对通信线路进行加密2）SSL有一种称为证书的手段，用于确定通信双方。通过使用证书，以证明通信方就是意料中的服务器，客户端持有证书即可完成个人身份的确认。3）通过校验数字签名，将一段文本先用Hash函数生成消息摘要，然后用发送者的私钥加密生成数字签名，与原文文一起传送给接收者。接收者通过校验数字签名来确定完成性。 https的缺点：1）https与http相比通信速度会更慢，SSL必须进行加密处理，服务器和客户端在加密解密的过程中会消耗更多的硬件资源导致处理速度变慢。2）https通信，证书是必不可少的，而证书是需要花钱的。 前端中比较常见的攻击手段XSS攻击xss：全称跨站脚本攻击（Cross-Site Scripting），简单的说就是攻击者通过在目标网站上注入恶意脚本并运行，获取用户的敏感信息如 Cookie、SessionID 等到攻击者自己的网站去。极大影响网站与用户数据安全。通过存在安全漏洞的web网站，注册到用户的浏览器内，渲染非法的HTML标签或者运行非法的JavaScript进行攻击的一种行为。 比如，攻击者在论坛中放一个看似安全的链接，骗取用户单击并窃取cookie中的用户隐私信息；或者攻击者在论坛中加一个恶意的表单，当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点 重点不在于跨站点，而在于脚本的执行 原因：当攻击者通过某种方式向浏览器页面注入了恶意代码，并且浏览器执行了这些代码。我们对url参数（或者说用户提交输入的地方）没有做充分的过滤，所以导致不合法的参数或者输入内容到了web服务器，最后当用户访问前端页面的时候呢，就可能将恶意代码拉过来重新执行了一遍。 危害： 挂马（木马病毒） 盗取用户Cookie DDOS（拒绝服务）客户端浏览器 钓鱼技巧，高级的钓鱼技巧 删除目标文章、恶意篡改数据、嫁祸 劫持用户web行为，甚至进一步渗透内网 渗透web2.0蠕虫（病毒） 蠕虫式的DDoS攻击 蠕虫式挂马攻击、刷广告、刷流量、破坏上网数据 解决措施： 总体思路 对输入做过滤；对输出进行编码；cookie设置http-only 渲染页面前都要先做 HTML 过滤，然后再渲染，对输入数据(如html标签&lt; &gt;进行转义 &lt; &gt; ），最后设置httpOnly。 在代码里对用户输入的地方和变量都需要仔细检查长度和对 &lt;，&gt;，;，&#39;，&quot;等字符做过滤。 其次，再把任何内容写到页面之前都必须进行编码，避免泄露html tag（比如把&lt;转义成&amp;lt;，如果是json的话，把\转义为\\，把/转义为\/）。在这一个层面做好，至少可以防止超过一半的XSS攻击。 cookie设置http-only 后台开发一定不要信任前端的任何代码 CSRF 攻击CSRF 攻击全称跨站请求伪造（Cross-site Request Forgery），简单的说就是攻击者盗用了你的身份，以你的名义发送恶意请求。CSRF的另一个特征是，攻击者无法直接窃取到用户的信息（Cookie，Header，网站内容等），仅仅是冒用Cookie中的信息。攻击者通过设置陷阱，强制对已经完成的认证用户进行非预期的个人信息或者设定信息等状态的更新。 CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账。造成的问题包括：个人隐私泄露以及财产安全 比如用户登录了一个网站后，立刻在另一个tab页面访问了攻击者用来制造攻击的网站，这个网站要求访问刚刚登陆的网站，并发送了一个恶意请求，这时候CSRF就产生了，比如这个制造攻击的网站使用一张图片，但是这种图片的链接却是可以修改数据库的，这时候攻击者就可以以用户的名义操作这个数据库 防御方式的话：使用验证码，检查https头部的refer，使用token 防御CSRF 攻击主要有三种策略：验证 HTTP Referer 字段；在请求地址中添加 token 并验证；在 HTTP 头中自定义属性并验证。 策略： CSRF自动防御策略：同源检测（Origin 和 Referer 验证）。CSRF主动防御措施：Token验证 或者 双重Cookie验证 以及配合Samesite Cookie。保证页面的幂等性，后端接口不要在GET页面中做用户操作。 登录受信任网站，并在本地生成cookie 在不登出A的情况下，访问危险网站B 防范服务器端的CSRF攻击有很多种方法，但总的思想都是一致的，就是在客户端页面中增加伪随机数。 up主魔王不造反： 尽量使用POST （因为GET太容易被别人攻击），但攻击者使用form表单你还是会被攻击 加入验证码，验证是用户行为（滑动或者输入验证码） 验证http头字段Referer，判断域名是否是同一个（但并不是万无一失的，发送请求的时候是可以篡改这个referer的） Anti CSRF Token 在form表单中或者头信息中传递token token存储在服务端 服务端通过拦截器验证有效性 校验失败的拒绝请求 加入自定义Header SQL注入攻击通过把SQL命令插入Web表单、输入域名或页面请求的查询字符串中，最终达到欺骗服务器执行恶意的SQL命令 策略： 从安全技术手段上来说，可以通过数据库防火墙实现对SQL注入攻击的防范，因为SQL注入攻击往往是通过应用程序来进攻，可以使用虚拟补丁技术实现对注入攻击的SQL特征识别，实现实时攻击阻断。 CSRF攻击和XSS攻击有啥区别XSS攻击用于获取信息，不需要提前知道其他用户页面的代码和数据包。CSRF攻击用于代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。 tokentoken主要有两个作用：①：防止表单重复提交(防止表单重复提交一般还是使用前后端都限制的方式，比如：在前端点击提交之后，将按钮置为灰色，不可再次点击，然后客户端和服务端的token各自独立存储，客户端存储在Cookie或者Form的隐藏域（放在Form隐藏域中的时候，需要每个表单）中，服务端存储在Session（单机系统中可以使用）或者其他缓存系统（分布式系统可以使用）中。②：用来作身份验证 HTTP 是一个无状态的协议，一次请求结束后，下次在发送服务器就不知道这个请求是谁发来的了（同一个 IP 不代表同一个用户），在 Web 应用中，用户的认证和鉴权是非常重要的一环，实践中有多种可用方案，并且各有千秋。 使用基于 Token 的身份验证方法，在服务端不需要存储用户的登录记录。大概的流程是这样的： 客户端使用用户名跟密码请求登录 服务端收到请求，去验证用户名与密码 验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端 客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里 客户端每次向服务端请求资源的时候需要带着服务端签发的 Token 服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据 token和session的区别为什么要用token，好好的用sessionID不好吗？（其实就是新技术与老技术，但是还是想弄懂）这个问题之前一直疑惑，今天搞懂了，整合了一下学习过程，先对比一下sessionID与token sessionID的生成方式浏览器第一次访问服务器时，服务器创建一个session，同时生成一个唯一的会话key，即sessionID。接着sessionID及session分别作为key和value保存到缓存中，也可以保存到数据库中，然后服务器把sessionID以cookie的形式发送给浏览器，浏览器下次访问服务器时直接携带上cookie中的sessionID，服务器再根据sessionID找到对应的session进行匹配这里我们注意到两点：1.sessionID会自动由浏览器带上 2.session是需要存储空间的 token的生成方式浏览器第一次访问服务器时，服务器根据传过来的唯一标识userId，通过一些算法，加一个密钥，生成一个token，接着通过base64编码将token返回给客户端。客户端将token保存起来，下次请求时需要带着token，服务器收到请求后，用相同的算法和密钥去验证token这里我们注意到两点：1.token需要代码才能带上 2.token可以不需要存储空间（JWT）（当然也有存入缓存的处理，特别是要进行revoke操作时），通过算法和密钥验证 JSON Web Token (JWT) 是一种开放标准 (RFC 7519) 定义了一种用于安全传输的紧凑、自包含（注：或自说明） 的Json结构， 被传输的信息可以通过JWT内容中的算法+密钥进行加密解密，来确保信息可信。JWT可以使用一个加密串 (使用HMAC 对称算法，或非对称算法RSA 与ECDSA) 区别以上我们提出来的注意点就可以看出两点区别了：1.浏览器方面，是否直接带上 2.服务器方面，是否需要存储空间。 共同点：都是保存了用户身份信息，都有过期时间。 不同点： session翻译为会话，token翻译为令牌。 session是空间换时间，token是时间换空间。 session和sessionid：服务器会保存一份，可能保存到缓存/数据库/文件。 token：服务器不需要记录任何东西，每次都是一个无状态的请求，每次都是通过解密来验证是否合法。 token 只是一个 key，不存放实际的数据，与这个 token 相关的数据还是存放在服务器上，例如 Session，Redis 等分布式缓存里，用 token 去请求对应的数据。 sessionid：一般是随机字符串，要到服务器检索id的有效性。出现请求：服务器重启饿内存中的session没了，数据库服务器挂了。 token 和 cookie 本质上没啥区别，只不过 token 只是一个字符串，访问的时候可以放在 url 的参数，header 里等，不像 cookie 那么重量级，而且移动端访问的时候 token 更方便，仅此而已。 总结广义上来说一切维护用户状态的技术都是session，然后sessionid与token就是老技术与技术 TCP 协议如何保证可靠传输 保证可靠性的重点就是滑动窗口机制，ACK &amp; 超时重传等机制都在滑动窗口的工作过程中体现。 TCP主要提供了检验和、序列号/确认应答、超时重传、最大消息长度、滑动窗口控制等方法实现了可靠性传输。 1. 停止等待协议每发送完一个分组，就停止发送，等待对方确认，收到确认后再发送下一个分组。 出现差错的情况：（1）A在发送之后设置一个定时器，若超过定时器时间还没有收到确认，就重新发送次分组（A发送的分组必须要留一个副本，为超时重传所用）。如果B检测收到的分组有错，就丢弃分组，什么也不做（TCP将保持它首部和数据的检验和CRC。这个检验和目的是检测数据在传输过程中的任何变化）。当发现在超过计时器时间还未收到确认信号，则采用超时重传功能重新发送。 （2）确认丢失：如果B发送的确认信号丢失后，A定时器超出时间，则重新发送这个分组，B丢弃这个分组，不向上层交付，同时向A重新发送确认。 （3）确认迟到： 流程图如上所示，A收到这个迟到的确认后会丢弃这个确认，什么都不做。 至此，就是停止等待协议中会出现的问题。而解决这些问题的重传机制，就是ARQ（Auto Repeat Request自动重传请求）协议，也就是重传的请求是自动的，不需要B请求A发送某一个丢失或者出错的数据。很显然，这种方式信道利用率很低，这个时候我们就采用连续ARQ协议。 2. 连续ARQ协议利用滑动窗口（以字节为单位），位于滑动窗口内的所有分组都可以连续的发送出去，而不需要逐个等待对方的确认。A每收到一个确认，就把发送窗口向前滑动一个分组的位置。B采用累积确认的方式，对按序到达的最后一个分组发送确认（就是最后这个分组的编号），就表示这个分组之前的所有分组都收到了。（1）优点：信道利用率高，容易实现，即使确认丢失，也不必重传。（2）缺点：不能向发送方反映出接收方已经正确收到的所有分组的信息，效率低。比如：发送方发送了5条消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫Go-Back-N（回退N），表示需要退回来重传已经发送过的N个消息。 3.保证数据的顺序性：TCP报文段作为IP数据来进行传输，而IP数据报的到达可能会失序，因此TCP到达也可能会失序，所以如果有必要，TCP将对收到的数据进行重新排序，将收到的数据以正确的顺序交给应用层。 4.TCP流量控制 让发送方的发送速率不要太快，通过滑动窗口来控制 坚持定时器 ：当接收到窗口为0的状态，则启动坚持定时器，每隔一段时间发送一个窗口探测报文（为解决死锁的局面而产生） 与拥塞控制的区别是点对点的通信量控制 5.TCP拥塞控制 是全局性的考虑，考虑的是整个网络 报文超时这被认为是拥塞 HTTP的首部字段包含哪些类型？你知道哪些请求头字段 &spades;&spades;&spades;通用首部字段请求报文和响应报文都会使用的字段 Date 创建报文的时间 / 发送该消息的日期和时间 Connection 连接的管理 / 客户端（浏览器）想要优先使用的连接类型 Cache-Control 缓存的控制 / 用来指定当前的请求/回复中的，是否使用缓存机制 Transfer-Encoding 报文主体的传输编码方式 请求首部字段请求报文会使用的字段 Host 请求资源所在服务器 Accept 可处理的媒体类型 / 可接受的响应内容类型（Content-Types） Accept-Charset 可接受的字符集 Accept-Encoding 可接受的内容编码 Accept-Language 可接受的自然语言 / 可接受的响应内容语言列表 Athorization 用户的认证信息 User-Agent 这个头信息识别发出请求的浏览器或其他客户端，并可以向不同类型的浏览器返回不同的内容 响应的首部字段响应报文时使用的字段 Accept-Ranges 可接受的字节范围 Location 令客户端重新定向到的URL Server HTTP服务器的安装信息 实体首部的字段请求报文与响应报文的实体部分使用的首部字段 Allow 资源可支持的HTTP方法 Content-Type 实体主图的类型 Content-Encoding 实体主体使用的自然语言 Content-Language 实体主体使用的编码方式 Content-Length 实体主体的字节数 Content-Range 实体主体的位置范围，一般用于发出部分请求时使用 Accept 这个头信息指定浏览器或其他客户端可以处理的 MIME 类型。有text/html,image/，/等几种常用类型。/*可以简单的概括为告诉服务器，客户端什么数据类型都支持Accept-Charset 这个头信息指定浏览器可以用来显示信息的字符集。例如 ISO-8859-1Accept-Encoding 这个头信息指定浏览器知道如何处理的编码类型。值 gzip 或 compress 是最常见的两种可能值Accept-Language 这个头信息指定客户端的首选语言，在这种情况下，Servlet 会产生多种语言的结果。例如，en、en-us、ru 等。Authorization 这个头信息用于客户端在访问受密码保护的网页时识别自己的身份。Connection 这个头信息指示客户端是否可以处理持久 HTTP 连接。持久连接允许客户端或其他浏览器通过单个请求来检索多个文件。值 Keep-Alive 意味着使用了持续连接。Content-Length 这个头信息只适用于 POST 请求，并给出 POST 数据的大小（以字节为单位）。Cookie 这 个头信息把之前发送到浏览器的 cookies 返回到服务器 / 由之前服务器通过Set-Cookie设置的一个HTTP协议Cookie。Host 这个头信息指定原始的 URL 中的主机和端口。 Origin 发起一个针对跨域资源共享的请求（该请求要求服务器在响应中加入一个Access-Control-Allow-Origin的消息头，表示访问控制所允许的来源） Upgrade 要求服务器升级到一个高版本协议 If-Modified-Since 这个头信息表示只有当页面在指定的日期后已更改时，客户端想要的页面。如果没有新的结果可以使用，服务器会发送一个 304 代码，表示 Not Modified 头信息。 Last-Modified 与If-Modified-Since都是用来记录页面的最后修改时间。当客户端访问页面时，服务器会将页面最后修改时间通过 Last-Modified 标识由服务器发往客户端，客户端记录修改时间，再次请求本地存在的cache页面时，客户端会通过 If-Modified-Since 头将先前服务器端发过来的最后修改时间戳发送回去，服务器端通过这个时间戳判断客户端的页面是否是最新的，如果不是最新的，则返回新的内容，如果是最新的，则 返回 304 告诉客户端其本地 cache 的页面是最新的，于是客户端就可以直接从本地加载页面了，这样在网络上传输的数据就会大大减少，同时也减轻了服务器的负担 If-None-Match 允许在对应的内容未被修改的情况下返回304未修改（ 304 Not Modified ），参考 超文本传输协议 的实体标记 If-Unmodified-Since 这个头信息是 If-Modified-Since 的对立面，它指定只有当文档早于指定日期时，操作才会成功。Referer 这个头信息指示所指向的 Web 页的 URL。例如，如果您在网页 1，点击一个链接到网页 2，当浏览器请求网页 2 时，网页 1 的 URL 就会包含在 Referer 头信息中。User-Agent 这个头信息识别发出请求的浏览器或其他客户端，并可以向不同类型的浏览器返回不同的内容。 登录注册怎么与后台交互 请求登录接口，成功则设置cookie, 如user=zhangsan 前端再请求其他接口，就会带着上述的cookie 服务端判断cookie有无user=zhangsan ,即可验证 cookie和session由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session。用唯一的一个标识session来标记用户，这个session是保存在服务端的。保存的方法通常有：内存、数据库、文件等。那么有了这个session，如何识别呢？就需要保sessionId保存在cookie中。因此可以看出：session：用来跟踪会话状态，保存在服务端，安全性更高。因为 session id 的存在，通常要借助 cookie 实现。cookie：是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。 cookie在跨域时是如何携带cookie的在解决跨域时，我们会采用很多解决跨域的方法。此处以cors为例。cors默认不发cookie。如果要发cookie，客户端需要设置withCredentials 属性为 true（withCredentials属性会包含来自远程域的请求的任何cookie，但这些cookie依然遵循同源策略），需要服务端使用Access-Control-Allow-Credentials: true 字段来允许携带cookie。 缓存有哪些 &spades;&spades;&spades;因为服务器上的资源不是一直固定不变的，大多数情况下它会更新，这个时候如果我们还访问本地缓存，那么对用户来说，那就相当于资源没有更新，用户看到的还是旧的资源；所以我们希望服务器上的资源更新了浏览器就请求新的资源，没有更新就使用本地的缓存，以最大程度的减少因网络请求而产生的资源浪费。 浏览器的缓存规则是在 http 协议头和 html 页面的 meta 标签中定义的。 缓存分为两种：强缓存和协商缓存，根据响应的header内容来决定 强缓存从缓存中取资源，但是如果有缓存的话就不经过服务器（即不发请求），直接从缓存中取。状态码200 强缓存相关字段有expires，cache-control。如果cache-control与expires同时存在的话，cache-control的优先级高于expires。 强缓存是指缓存的副本在有效期内，浏览器直接获取这个副本并渲染。强缓存主要涉及的 http 协议报头有：Expires，cache-control。 强缓存的过程：浏览器发起 http 请求，浏览器缓存中查找该请求的结果以及缓存标识，缓存副本在有效期内，该请求返回状态码 200，从 disk cache 或 memory cache （size 中显示 from disk cache 或 from memory cache）中返回。如果缓存副本并不在有效期内，浏览器将发起 http 请求到服务端，服务端返回请求结果和缓存规则，并将请求结果和缓存标识存在浏览器缓存中。 Expires：是HTTP/1的产物，是一个绝对的时间，如果浏览器时间还没有超过这个expires时间，代表缓存还有效。直接从缓存中读取资源。cache-control：是HTTP/1.1提出的。 协商缓存从缓存中取资源，但是需要给服务器发请求来由服务器告知缓存是否可用，然后从缓存中取，状态码是304 协商缓存相关字段有Last-Modified/If-Modified-Since，Etag/If-None-Match 协商缓存是在强缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程。 协商缓存的过程： 条件1：浏览器进行缓存过期判断 ；条件2：服务器判断文件时候被修改。如果两种条件的判断结果都是文件未修改过，服务器就会直接告诉浏览器，文件没有被修改过，可以继续使用缓存——304 Not Modified。此时，浏览器就会从本地缓存中获取请求资源的内容。 协商缓存主要涉及的 http 协议报头有：Last-Modified/If-Modified-Since，Etag/If-None-Match 注意只有get请求会被缓存，post请求不会 cookie、localStorage、sessionStorage有什么区别 &spades; &spades; &spades;Web Storage分为两种： sessionStorage 和localStorage ，即这两个是Storage的一个实例。 Web Storage的两个主要目标是： 提供一种在cookie之外存储会话数据的途径。 提供一种存储大量可以跨会话存在的数据的机制。 Web Storage带来的好处： 减少网络流量：一旦数据保存在本地之后，就可以避免再向服务器请求数据，因此减少不必要的数据请求，减少数据在浏览器和服务器间不必要的来回传递 快速显示数据：性能好，从本地读数据比通过网络从服务器上获得数据快得多，本地数据可以及时获得，再加上网页本身也可以有缓存，因此整个页面和数据都在本地的话，可以立即显示 临时存储：很多时候数据只需要在用户浏览一组页面期间使用，关闭窗口后数据就可以丢弃了，这种情况使用sessionStorage非常方便 cookie 4k容量 localStorage 没有储存时间限制，2-5MB左右 sessionStorage 网页会话结束时失效（刷新没问题，关闭失效） 共同点都是保存在浏览器端、且同源的 区别 cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递，而sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下 存储大小限制也不同，cookie数据不能超过4K，同时因为每次http请求都会携带cookie、所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大 数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭之前有效；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭 作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localstorage在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的 web Storage支持事件通知机制，可以将数据更新的通知发送给监听者 web Storage的api接口使用更方便，web storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie。 这篇博客写的不错：https://www.cnblogs.com/jing-tian/p/10991431.html indexDB与web Storage比较 indexDB是H5 数据库 优点：存储类型丰富 / 条件搜索优势明显 / 可以再work中使用 / 存储容量大 缺点：学习曲线陡峭 / 兼容性略严重 / 跨域问题有限制 一句话概括RESTFUL就是用URL定位资源，用HTTP描述操作 Cookie如何防范XSS攻击XSS（跨站脚本攻击）是指攻击者在返回的HTML中嵌入javascript脚本，为了减轻这些攻击，需要在HTTP头部配上，set-cookie： httponly-这个属性可以防止XSS,它会禁止javascript脚本来访问cookie。 secure - 这个属性告诉浏览器仅在请求为https的时候发送cookie。 结果应该是这样的：Set-Cookie=….. GET和POST的区别get参数通过url传递，post放在request body中。 get请求在url中传递的参数是有长度限制的，而post没有。 get比post更不安全，因为参数直接暴露在url中，所以不能用来传递敏感信息。 get请求只能进行url编码，而post支持多种编码方式 get请求会浏览器主动cache，而post支持多种编码方式。 get请求参数会被完整保留在浏览历史记录里，而post中的参数不会被保留。 GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。 GET产生一个TCP数据包；POST产生两个TCP数据包。 301和302的区别301 Moved Permanently 被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个URI之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。 302 Found 请求的资源现在临时从不同的URI响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 字面上的区别就是301是永久重定向，而302是临时重定向。 301比较常用的场景是使用域名跳转。302用来做临时跳转 比如未登陆的用户访问用户中心重定向到登录页面。 HTTP支持的方法GET, POST, HEAD, OPTIONS, PUT, DELETE, TRACE, CONNECT HTTP2.0 的特性http2.0的特性如下： 1、内容安全，应为http2.0是基于https的，天然具有安全特性，通过http2.0的特性可以避免单纯使用https的性能下降 2、二进制格式，http1.X的解析是基于文本的，http2.0将所有的传输信息分割为更小的消息和帧，并对他们采用二进制格式编码，基于二进制可以让协议有更多的扩展性，比如引入了帧来传输数据和指令 3、多路复用，这个功能相当于是长连接的增强，每个request请求可以随机的混杂在一起，接收方可以根据request的id将request再归属到各自不同的服务端请求里面，另外多路复用中也支持了流的优先级，允许客户端告诉服务器那些内容是更优先级的资源，可以优先传输， cache-control的值有哪些cache-control是一个通用消息头字段被用于HTTP请求和响应中，通过指定指令来实现缓存机制，这个缓存指令是单向的，常见的取值有private、no-cache、max-age、must-revalidate等，默认为private。 怎么看网站的性能如何检测页面加载时间一般有两种方式，一种是被动去测：就是在被检测的页面置入脚本或探针，当用户访问网页时，探针自动采集数据并传回数据库进行分析，另一种主动监测的方式，即主动的搭建分布式受控环境，模拟用户发起页面访问请求，主动采集性能数据并分析，在检测的精准度上，专业的第三方工具效果更佳，比如说性能极客 cookie安全策略在服务端设置cookie的时候设置http-only,这样就可以防止用户通过JS获取到cookie。对cookie的读写或发送一般有如下字段进行设置： http-only: 只允许http请求读取cookie，JS代码是无法读取cookie的（document.cookie会显示http-only的cookie项被自动过滤）。发送请求时自动发送cookie。 secure-cookie：只允许https请求读取，发送请求时自动发送cookie。 host-only：只允许主机域名与domain设置完成一致的网站才能访问改cookie。 cookie有哪些编码方式encodeURI（） 补充get和post请求在缓存方面的区别get请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存。 post不同，post做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。因此get请求适合于请求缓存。]]></content>
      <categories>
        <category>前端知识点总结</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端知识点总结——Vue]]></title>
    <url>%2F2020%2F06%2F09%2F%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94Vue%2F</url>
    <content type="text"><![CDATA[vue和react &spades; 相似之处 Virtual DOMVue.js(2.0版本)与React的其中最大一个相似之处，就是他们都使用了一种叫’Virtual DOM’的东西。所谓的Virtual DOM基本上说就是它名字的意思：虚拟DOM，DOM树的虚拟表现。它的诞生是基于这么一个概念：改变真实的DOM状态远比改变一个JavaScript对象的花销要大得多。 Virtual DOM是一个映射真实DOM的JavaScript对象，如果需要改变任何元素的状态，那么是先在Virtual DOM上进行改变，而不是直接改变真实的DOM。当有变化产生时，一个新的Virtual DOM对象会被创建并计算新旧Virtual DOM之间的差别。之后这些差别会应用在真实的DOM上。 组件化React与Vue都鼓励组件化应用。这本质上说，是建议你将你的应用分拆成一个个功能明确的模块，每个模块之间可以通过合适的方式互相联系。 PropsReact和Vue都有’props’的概念，这是properties的简写。props在组件中是一个特殊的属性，允许父组件往子组件传送数据。在React中，这是必须的，它依赖一个“单一数据源”作为它的“状态”。而在Vue中，props略有不同。它们一样是在组件中被定义，但Vue依赖于模板语法，你可以通过模板的循环函数更高效地展示传入的数据。 构建工具React和Vue都有自己的构建工具，你可以使用它快速搭建开发环境。React可以使用Create React App (CRA)，而Vue对应的则是vue-cli。两个工具都能让你得到一个根据最佳实践设置的项目模板。 配套框架Vue与React最后一个相似但略有不同之处是它们配套框架的处理方法。相同之处在于，两个框架都专注于UI层，其他的功能如路由、状态管理等都交由同伴框架进行处理。 而不同之处是在于它们如何关联它们各自的配套框架。Vue的核心团队维护着vue-router和vuex，它们都是作为官方推荐的存在。而React的react-router和react-redux则是由社区成员维护，它们都不是官方维护的。 主要区别 模板 vs JSXReact与Vue最大的不同是模板的编写。 状态管理 vs 对象属性如果你对React熟悉，你就会知道应用中的状态是（React）关键的概念。也有一些配套框架被设计为管理一个大的state对象，如Redux。此外，state对象在React应用中是不可变的，意味着它不能被直接改变（这也许不一定正确）。在React中你需要使用setState()方法去更新状态。 在Vue中，state对象并不是必须的，数据由data属性在Vue对象中进行管理。不需要使用如setState()之类的方法去改变它的状态，在Vue对象中，data参数就是应用中数据的保存者。 对于管理大型应用中的状态这一话题而言，Vue.js的作者尤雨溪曾说过，（Vue的）解决方案适用于小型应用，但对于对于大型应用而言不太适合。多数情况下，框架内置的状态管理是不足以支撑大型应用的，Redux或Vuex等状态管理方案是必须使用的。 原文链接：http://caibaojian.com/vue-vs-react.html vue相比react解决了什么问题vue好在哪里思想是前提。“html依赖css，css不要依赖html”，“html依赖js，js不要依赖html”，理解了上面的思想，再回头看vue，你就懂了！vue的效果：html引用 “数据”，html引用js。js是不引用html的。如果js引用html，那么html就不好修改和变化啦。html频繁改动是常态。js对数据操作，html根据数据进行渲染。js不要直接操作html！ 虚拟dom： virtual dom （也被称为vdom），他是由JavaScript模拟出来的具有和真实DOM结构的树形结构 MVVM MVVM是Model-View-ViewModel，是把一个系统分为了模型（model）、视图（view）和view-model三个部分。 vue在MVVM架构下，view和model之间没有直接的联系，但是view和view-model、model和view-model之间时交互的，当view数据发生变化时，可以通过view-model同步到model中，model数据变化也会同步到view中。这样一来，vue的代码量就会少很多，操作也会更加简便。 两者区别React组件是函数，所以写React组件其实就是在写函数，写一个什么样的函数呢？一个接收 props 作为参数的函数，至于 props 这个参数中包含什么那就您随意了，所以js这门语言所拥有的都可以看做是React拥有的，比如高阶组件不就是高阶函数嘛~ Vue的组件也是函数，只不过写Vue组件却不是在写函数，而是在写函数的参数，比如： 1234567export default &#123; name: 'FuckComp', created () &#123; console.log('fuck fuck fuck') &#125;, props: ['a', 'b']&#125; 这不就是一个普通的对象嘛，可以看到 props 只是参数的一部分。 以上是内容说明什么呢？打个比喻，比如实现： debounce(func, [wait=0], [options={}])函数。用React实现就像是你需要完全自己开发： 123function debounce (func, wait, options) &#123; // ... 具体实现你自己去写&#125; 而用Vue实现就像你仅仅需要传递一个配置对象： 123456// 你只需要告诉我你要的是什么，具体我帮你实现&#123; fn: func, wait: 0, options: &#123;&#125;&#125; 从这个角度来看的话我们还可以举一个不严谨的例子：把React比作nodejs，那么Vue就是Koa。 Vue说它简单，理由是：React组件是函数，Vue组件是高度封装的函数。 React说它拥有完全的JavaScript能力，理由也是：React组件是函数，Vue组件是高度封装的函数 所以你看，优点不优点的，最后不都看个人口味吗。 用Vue真的很爽就像在吃糖，但有时候React的灵活真的也能让你有种想要大展才华的快感。 总结 都是响应式框架，开发业务都没有任何问题。Vue适合于响应式框架的初学者，因为API很完全，不会的东西可以很快搜到答案，React适合对设计有所追求的开发者，因为React的API很少，对开发没有过多的约束，可以更大程度发挥前端创造性。另外RN相对于Weex也更加成熟一些。 Vue生命周期 Vue实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载Dom、渲染→更新→渲染、销毁等一系列过程，我们称这是Vue的生命周期。通俗说就是Vue实例从创建到销毁的过程，就是生命周期。 每一个组件或者实例都会经历一个完整的生命周期，总共分为三个阶段：初始化、运行中、销毁。 实例、组件通过new Vue() 创建出来之后会初始化事件和生命周期，然后就会执行beforeCreate钩子函数，这个时候，数据还没有挂载呢，只是一个空壳，无法访问到数据和真实的dom，一般不做操作 挂载数据，绑定事件等等，然后执行created函数，这个时候已经可以使用到数据，也可以更改数据,在这里更改数据不会触发updated函数，在这里可以在渲染前倒数第二次更改数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取 接下来开始找实例或者组件对应的模板，编译模板为虚拟dom放入到render函数中准备渲染，然后执行beforeMount钩子函数，在这个函数中虚拟dom已经创建完成，马上就要渲染,在这里也可以更改数据，不会触发updated，在这里可以在渲染前最后一次更改数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取 接下来开始render，渲染出真实dom，然后执行mounted钩子函数，此时，组件已经出现在页面中，数据、真实dom都已经处理好了,事件都已经挂载好了，可以在这里操作真实dom等事情… 当组件或实例的数据更改之后，会立即执行beforeUpdate，然后vue的虚拟dom机制会重新构建虚拟dom与上一次的虚拟dom树利用diff算法进行对比之后重新渲染，一般不做什么事儿 当更新完成后，执行updated，数据已经更改完成，dom也重新render完成，可以操作更新后的虚拟dom 当经过某种途径调用$destroy方法后，立即执行beforeDestroy，一般在这里做一些善后工作，例如清除计时器、清除非指令绑定的事件等等 组件的数据绑定、监听…去掉后只剩下dom空壳，这个时候，执行destroyed，在这里做善后工作也可以 vue中created和mounted的区别官方解释 created：在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，property 和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，$el property 目前尚不可用。 mouted：实例被挂载后调用，这时 el 被新创建的 vm.$el 替换了。如果根实例挂载到了一个文档内的元素上，当 mounted 被调用时 vm.$el 也在文档内。 注意 mounted 不会保证所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以在 mounted 内部使用 vm.$nextTick： 123456mounted: function () &#123; this.$nextTick(function () &#123; // Code that will run only after the // entire view has been rendered &#125;)&#125; 总结created：在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成视图。 mounted：在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作 vuex的工作原理 &spades;&spades; 参考学习地址https://www.jianshu.com/p/d95a7b8afa06 vuex实现原理我们简单过一遍源码 地址 https://github.com/vuejs/vuex 使用vuex中store中的数据，基本上离不开vue中一个常用的属性computed。官方一个最简单的例子如下 12345678910111213var vm = new Vue(&#123; el: '#example', data: &#123; message: 'Hello' &#125;, computed: &#123; // 计算属性的 getter reversedMessage: function () &#123; // `this` 指向 vm 实例 return this.message.split('').reverse().join() &#125; &#125;&#125;) 你是怎么认识vuex的？vuex可以理解为以一种开发模式或者框架。它是对Vue.js框架数据层面的扩展。通过状态（数据源）集中管理驱动组件的变化。应用的状态集中放在store中。改变的状态的方式提交mutations，这是个同步的事务。异步的逻辑应该封装在action中。 store是怎么注册的看了下面的源码就很清楚了， 我们看到vuex在vue 的生命周期中的初始化钩子前插入一段 Vuex 初始化代码。给 Vue 的实例注入一个 $store 的属性，这也就是为什么我们在 Vue 的组件中可以通过 this.$store.xxx 访问到 Vuex 的各种数据和状态 1234567891011121314151617181920212223242526272829303132333435// 源码位置 https://github.com/vuejs/vuex/blob/665455f8daf8512e7adbf63c2842bc0b1e39efdb/src/mixin.jsexport default function (Vue) &#123; const version = Number(Vue.version.split('.')[0]) if (version &gt;= 2) &#123; Vue.mixin(&#123; beforeCreate: vuexInit &#125;) &#125; else &#123; // override init and inject vuex init procedure // for 1.x backwards compatibility. const _init = Vue.prototype._init Vue.prototype._init = function (options = &#123;&#125;) &#123; options.init = options.init ? [vuexInit].concat(options.init) : vuexInit _init.call(this, options) &#125; &#125; /** * Vuex init hook, injected into each instances init hooks list. */ function vuexInit () &#123; const options = this.$options // store injection if (options.store) &#123; this.$store = typeof options.store === 'function' ? options.store() : options.store &#125; else if (options.parent &amp;&amp; options.parent.$store) &#123; this.$store = options.parent.$store &#125; &#125;&#125; mutations，commit 是怎么实现的1234567// 源码位置 https://github.com/vuejs/vuex/blob/665455f8daf8512e7adbf63c2842bc0b1e39efdb/src/store.js#L417function registerMutation (store, type, handler, path = []) &#123; const entry = store._mutations[type] || (store._mutations[type] = []) entry.push(function wrappedMutationHandler (payload) &#123; handler(getNestedState(store.state, path), payload) &#125;)&#125; registerMutation 是对 store 的 mutation 的初始化，它接受 4 个参数，store为当前 Store 实例，type为 mutation 的 key，handler 为 mutation 执行的回调函数，path 为当前模块的路径。mutation 的作用就是同步修改当前模块的 state ，函数首先通过 type 拿到对应的 mutation 对象数组， 然后把一个 mutation 的包装函数 push 到这个数组中，这个函数接收一个参数 payload，这个就是我们在定义 mutation 的时候接收的额外参数。这个函数执行的时候会调用 mutation 的回调函数，并通过 getNestedState(store.state, path) 方法得到当前模块的 state，和 playload 一起作为回调函数的参数 我们知道mutation是通过commit来触发的，这里我们也来看一下commit的定义 1234567891011121314151617181920212223242526272829303132333435// 源码位置 https://github.com/vuejs/vuex/blob/665455f8daf8512e7adbf63c2842bc0b1e39efdb/src/store.js#L82 commit (_type, _payload, _options) &#123; // check object-style commit const &#123; type, payload, options &#125; = unifyObjectStyle(_type, _payload, _options) const mutation = &#123; type, payload &#125; const entry = this._mutations[type] if (!entry) &#123; if (process.env.NODE_ENV !== 'production') &#123; console.error(`[vuex] unknown mutation type: $&#123;type&#125;`) &#125; return &#125; this._withCommit(() =&gt; &#123; entry.forEach(function commitIterator (handler) &#123; handler(payload) &#125;) &#125;) this._subscribers.forEach(sub =&gt; sub(mutation, this.state)) if ( process.env.NODE_ENV !== 'production' &amp;&amp; options &amp;&amp; options.silent ) &#123; console.warn( `[vuex] mutation type: $&#123;type&#125;. Silent option has been removed. ` + 'Use the filter functionality in the vue-devtools' ) &#125; &#125; commit 支持 3 个参数，type 表示 mutation 的类型，payload 表示额外的参数,根据 type 去查找对应的 mutation，如果找不到，则输出一条错误信息，否则遍历这个 type 对应的 mutation 对象数组，执行 handler(payload) 方法，这个方法就是之前定义的 wrappedMutationHandler(handler)，执行它就相当于执行了 registerMutation 注册的回调函数 辅助函数辅助函数的实现都差不太多，这里只讲解mapState 12345678910111213141516171819202122232425// 源码地址 https://github.com/vuejs/vuex/blob/665455f8daf8512e7adbf63c2842bc0b1e39efdb/src/helpers.js#L7export const mapState = normalizeNamespace((namespace, states) =&gt; &#123; const res = &#123;&#125; normalizeMap(states).forEach((&#123; key, val &#125;) =&gt; &#123; res[key] = function mappedState () &#123; let state = this.$store.state let getters = this.$store.getters if (namespace) &#123; const module = getModuleByNamespace(this.$store, 'mapState', namespace) if (!module) &#123; return &#125; state = module.context.state getters = module.context.getters &#125; return typeof val === 'function' ? val.call(this, state, getters) : state[val] &#125; // mark vuex getter for devtools res[key].vuex = true &#125;) return res&#125;) mapState在调用了 normalizeMap 函数后，把传入的 states 转换成由 {key, val} 对象构成的数组，接着调用 forEach 方法遍历这个数组，构造一个新的对象，这个新对象每个元素都返回一个新的函数 mappedState，函数对 val 的类型判断，如果 val 是一个函数，则直接调用这个 val 函数，把当前 store 上的 state 和 getters 作为参数，返回值作为 mappedState 的返回值；否则直接把 this.$store.state[val] 作为 mappedState 的返回值 为了更直观的理解，我们看下最终mapState的效果 123456789computed: mapState(&#123; name: state =&gt; state.name,&#125;)// 等同于computed: &#123; name: this.$store.state.name&#125; action和mutation的区别流程顺序“相应视图—&gt;修改State”拆分成两部分，视图触发Action，Action再触发Mutation。 角色定位基于流程顺序，二者扮演不同的角色。 Mutation：专注于修改State，理论上是修改State的唯一途径。 Action：业务代码、异步请求。 限制角色不同，二者有不同的限制。 Mutation：必须同步执行。 Action：可以异步，但不能直接操作State。 Vue获取标签属性的方式（ref）给标签或组件添加 ref 属性，在mounted()方法中，通过$.refs获取 123&lt;div ref="alex"&gt;&lt;/div&gt; &lt;p ref="a"&gt;&lt;/p&gt;&lt;Home ref="b"&gt;&lt;/Home&gt; 123//this.$refs.alex 获取原始的DOM对象//this.$refs.a//this.$refs.b 获取组件实例化对象 nextTick官方文档说明： 用法：在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。 疑问： DOM 更新循环是指什么？ 下次更新循环是什么时候？ 修改数据之后使用，是加快了数据更新进度吗？ 在什么情况下要用到？ 12345678910//改变数据vm.message = 'changed'//想要立即使用更新后的DOM。这样不行，因为设置message后DOM还没有更新console.log(vm.$el.textContent) // 并不会得到'changed'//这样可以，nextTick里面的代码会在DOM更新后执行Vue.nextTick(function()&#123; console.log(vm.$el.textContent) //可以得到'changed'&#125;) 简单总结事件循环： 同步代码执行 -&gt; 查找异步队列，推入执行栈，执行Vue.nextTick[事件循环1] -&gt;查找异步队列，推入执行栈，执行Vue.nextTick[事件循环2]… 总之，异步是单独的一个tick，不会和同步在一个 tick 里发生，也是 DOM 不会马上改变的原因。 应用场景需要在视图更新之后，基于新的视图进行操作 关于MVVM、MVCMVC几乎所有的App都只干这么一件事：将数据展示给用户看，并处理用户对界面的操作。 MVC的思想：一句话描述就是Controller负责将Model的数据用View显示出来，换句话说就是在Controller里面把Model的数据赋值给View，比如在controller中写document.getElementById(“box”).innerHTML = data[”title”]，只是还没有刻意建一个Model类出来而已。 Model（模型）：是应用程序中用于处理应用程序数据逻辑的部分。通常模型对象负责在数据库中存取数据。 View（视图）：是应用程序中处理数据显示的部分。通常视图是依据模型数据创建的。 Controller（控制器）：是应用程序中处理用户交互的部分。通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。 MVVCMVVM(Model-View-ViewModel), 源自于经典的 Model–View–Controller（MVC）模式。MVVM 的出现促进了 GUI 前端开发与后端业务逻辑的分离，极大地提高了前端开发效率。MVVM 的核心是 ViewModel 层，它就像是一个中转站（value converter），负责转换 Model 中的数据对象来让数据变得更容易管理和使用，该层向上与视图层进行双向数据绑定，向下与 Model 层通过接口请求进行数据交互，起呈上启下作用。View 层展现的不是 Model 层的数据，而是 ViewModel 的数据，由 ViewModel 负责与 Model 层交互，这就完全解耦了 View 层和 Model 层，这个解耦是至关重要的，它是前后端分离方案实施的最重要一环 参考链接：https://www.jianshu.com/p/8bc48f8fde75 MVVM：是Model-View-ViewModel的简写 M：对应于MVC的M；V：对应于MVC的V；VM：ViewModel，是把MVC里的controller的数据加载，加工功能分离出来 MVVM是Web前端一种非常流行的开发模式，利用MVVM可以使我们的代码更 加专注于处理业务逻辑而不是去关心DOM操作。目前著名的MVVM框架有VUE，avalon，angular等 MVVM设计模式的优点双向绑定技术，当Model变化时，View-Model会自动更新，View也会自动变化。很好的做到数据的一致性由于控制器的功能大都移动到View上处理，大大的对控制器进行了瘦身 View的功能进一步强化，具有控制的部分功能，若想无限增强它的功能，甚至控制器的全部功能几乎都可以迁移到各个View上（不过这样不可取，那样View干不了属于它职责范围内的事情）。 View可以像控制器一样具有自己都View-Model。 可以对View或ViewController的数据处理部分抽象出来一个函数处理model。 这样它们专职页面布局和页面跳转，它们必然更一步的简化。 MVVM设计模式的缺点数据绑定也使得bug很难被调试。比如你看到页面异常了，有可能是你的View的代码有bug，也可能是你的model的代码有问题。数据绑定使得一个位置的Bug被快速传递到别的位置，要定位原始出问题的地方就变得不那么容易了。 数据双向绑定不利于代码重用。客户端开发最常用的是View，但是数据双向绑定技术，让你在一个View都绑定了一个model，不同的模块model都不同。那就不能简单重用view了 一个大的模块中model也会很大，虽然使用方便了也很容易保证数据的一致性，但是长期持有，不释放内存就造成花费更多的内存。 总结 我说的直白点吧，mvc是将大量业务逻辑放在c层，会造成c层越来越臃肿，后端维护越来越难……mvvm有一个vm层，有了这层，就可以将部分业务逻辑转移到前端至于你说的学习mvvm框架……你学啥都无所谓，只是两种模式而已，瞬间就能互转那到底哪个好?要看业务，比如你就写一个小项目，就算所有业务逻辑放在后端也很好维护比如你前端强，那么将业务逻辑放在前端，也无可厚非 比如我，几年前写mvc，但是我主要做前端，所以现在是很乐意mvvm的 至于你要学啥，如果是前端，mvvm框架是必须要学的，因为整个前端没了三大框架，还有啥呢？ 但是你意在后端的话，前端只是打个辅助，那就无所谓了 Vue组件之间的通信父组件到子组件1234567//子组件props: &#123; col: &#123; type:String, default:'#000' &#125;&#125; 12//父组件&lt;template col="red"&gt;&lt;/template&gt; 子组件到父组件12//父组件 自定义了end事件&lt;template @end="ending"&gt;&lt;/template&gt; 12//子组件this.$emit("end", this.xxx) 子组件向子组件传递数据bus总线传值 非父子组件之间不能直接通讯，必须使用“代理人”，即中央数据总线过渡。 1var bus = new Vue(); A组件向B组件传值，A组件中要通过bus总线触发相应的事件； 1bus.$emit('sendtoTwo', this.one) B组件要在钩子函数中监听相应的事件。 123456mounted() &#123; // 监听sendtoTwo, 事件监听也可以写到created钩子函数 bus.$on('sendtoTwo', (data) =&gt; &#123; this.two = data; &#125;)&#125; Vuex传参为了便于开发，Vue 推出了一个状态管理工具 Vuex，可以很方便实现组件之间的参数传递 vuejs响应式原理 参考链接：https://cn.vuejs.org/v2/guide/reactivity.html 如何追踪变化当你把一个普通的 JavaScript 对象传入 Vue 实例作为 data 选项，Vue 将遍历此对象所有的 property，并使用 Object.defineProperty 把这些 property 全部转为 getter/setter。Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因。 检测变化的注意事项对于对象 Vue 无法检测 property 的添加或移除。由于 Vue 会在初始化实例时对 property 执行 getter/setter 转化，所以 property 必须在 data 对象上存在才能让 Vue 将它转换为响应式的。例如： 12345678var vm = new Vue(&#123; data:&#123; a:1 &#125;&#125;)// `vm.a` 是响应式的vm.b = 2// `vm.b` 是非响应式的 对于已经创建的实例，Vue 不允许动态添加根级别的响应式 property。但是，可以使用 Vue.set(object, propertyName, value) 方法向嵌套对象添加响应式 property。例如，对于： 1Vue.set(vm.someObject, 'b', 2) 您还可以使用 vm.$set 实例方法，这也是全局 Vue.set 方法的别名： 1this.$set(this.someObject,'b',2) 有时你可能需要为已有对象赋值多个新 property，比如使用 Object.assign() 或 _.extend()。但是，这样添加到对象上的新 property 不会触发更新。在这种情况下，你应该用原对象与要混合进去的对象的 property 一起创建一个新的对象。 12// 代替 `Object.assign(this.someObject, &#123; a: 1, b: 2 &#125;)`this.someObject = Object.assign(&#123;&#125;, this.someObject, &#123; a: 1, b: 2 &#125;) 对于数组 Vue 不能检测以下数组的变动： 当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue 当你修改数组的长度时，例如：vm.items.length = newLength 1234567var vm = new Vue(&#123; data: &#123; items: ['a', 'b', 'c'] &#125;&#125;)vm.items[1] = 'x' // 不是响应性的vm.items.length = 2 // 不是响应性的 为了解决第一类问题，以下两种方式都可以实现和 vm.items[indexOfItem] = newValue 相同的效果，同时也将在响应式系统内触发状态更新： 12// Vue.setVue.set(vm.items, indexOfItem, newValue) 12// Array.prototype.splicevm.items.splice(indexOfItem, 1, newValue) 你也可以使用 vm.$set 实例方法，该方法是全局方法 Vue.set 的一个别名： 1vm.$set(vm.items, indexOfItem, newValue) 为了解决第二类问题，你可以使用 splice： 1vm.items.splice(newLength) 声明响应式property由于 Vue 不允许动态添加根级响应式 property，所以你必须在初始化实例前声明所有根级响应式 property，哪怕只是一个空值： 123456789var vm = new Vue(&#123; data: &#123; // 声明 message 为一个空值字符串 message: '' &#125;, template: '&lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;'&#125;)// 之后设置 `message`vm.message = 'Hello!' 如果你未在 data 选项中声明 message，Vue 将警告你渲染函数正在试图访问不存在的 property。 异步更新队列可能你还没有注意到，Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替。 例如，当你设置 vm.someData = &#39;new value&#39;，该组件不会立即重新渲染。当刷新队列时，组件会在下一个事件循环“tick”中更新。多数情况我们不需要关心这个过程，但是如果你想基于更新后的 DOM 状态来做点什么，这就可能会有些棘手。虽然 Vue.js 通常鼓励开发人员使用“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们必须要这么做。为了在数据变化之后等待 Vue 完成更新 DOM，可以在数据变化之后立即使用 Vue.nextTick(callback)。这样回调函数将在 DOM 更新完成后被调用。例如： 1&lt;div id="example"&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt; 1234567891011var vm = new Vue(&#123; el: '#example', data: &#123; message: '123' &#125;&#125;)vm.message = 'new message' // 更改数据vm.$el.textContent === 'new message' // falseVue.nextTick(function () &#123; vm.$el.textContent === 'new message' // true&#125;) 在组件内使用 vm.$nextTick() 实例方法特别方便，因为它不需要全局 Vue，并且回调函数中的 this 将自动绑定到当前的 Vue 实例上： 1234567891011121314151617Vue.component('example', &#123; template: '&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;', data: function () &#123; return &#123; message: '未更新' &#125; &#125;, methods: &#123; updateMessage: function () &#123; this.message = '已更新' console.log(this.$el.textContent) // =&gt; '未更新' this.$nextTick(function () &#123; console.log(this.$el.textContent) // =&gt; '已更新' &#125;) &#125; &#125;&#125;) 因为 $nextTick() 返回一个 Promise 对象，所以你可以使用新的 ES2017 async/await 语法完成相同的事情： 12345678methods: &#123; updateMessage: async function () &#123; this.message = '已更新' console.log(this.$el.textContent) // =&gt; '未更新' await this.$nextTick() console.log(this.$el.textContent) // =&gt; '已更新' &#125;&#125; v-if和v-show的区别共同点：v-if 和 v-show 都能实现元素的显示隐藏 不同点： 1. v-show 只是简单的控制元素的 display 属性，而 v-if 才是条件渲染（条件为真，元素将会被渲染，条件为假，元素会被销毁） 2. v-show 有更高的首次渲染开销，而 v-if 的首次渲染开销要小的多 3. v-if 有更高的切换开销，v-show 切换开销小 4. v-if 有配套的 v-else-if 和 v-else，而 v-show 没有 5. v-if 可以搭配 template 使用，而 v-show 不行 总结 因此如果要非常的频繁切换，则使用v-show。如果在运行的时候很少改变，则使用v-if较好。 对vue双向数据绑定的理解vue数据双向绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的。 vue是通过Object.defineProperty()来实现数据劫持的。 一个监听器Observer，用来劫持并监听所有属性，如果有变动的，就通知订阅者 一个订阅者Watcher，可以收到属性的变化通知并执行相应的函数，从而更新视图 一个解析器Compile，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅器 https://www.cnblogs.com/chenhuichao/p/10818396.html]]></content>
      <categories>
        <category>前端知识点总结</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>前端框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端知识点总结——nodes.js]]></title>
    <url>%2F2020%2F06%2F09%2F%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94nodejs%2F</url>
    <content type="text"><![CDATA[nodejsnode.js是什么 单线程模型虽然对JavaScript构成了很大的限制，但也因此使它具备了其他语言不具备的优势。如果部署得好，JavaScript程序是不会出现堵塞的，这就是为什么node.js平台可以用很少的资源，应付大流量访问的原因。 Node.js是一个Javascript运行环境(runtime)。Node.js与JavaScript的区别是什么？本质： Javascript是一种web前端语言，主要用于web开发中，由浏览器解析执行 Node.js是一个可以快速构建网络服务及应用的平台，是用Javascript语言构建的服务平台，可用于后端建立服务器区别：Javascript 主要应用前端， 是编程语言 ， 客户端编程语言(需要浏览器的javascript解释器进行解释执行) 。node.js 主要应用后端 1个平台 运行环境(一个基于Chrome JavaScript运行时建立的平台，它是对Google V8引擎进行了封装的运行环境)简单的说node.js就是把浏览器的解释器封装起来作为服务器运行平台，用类似javascript的结构语法进行编程，在node.js上运行。 Node.js的优点、缺点优点： 1.事件驱动 2.异步编程 3.非阻塞模式的IO 4.轻量高效 缺点： 1.可靠性低 2.单进程，单线程，只支持单核cpu，不能充分的利用多核cpu服务器。一旦这个进程崩掉，那么整个web服务就崩掉了。 Node.js适用场景？Node.js不适用的场景？适用场景： 1.JSON APIL ——构建一个Rest/JSON API服务，node.js可以充分发挥其非堵塞IO模型以及javascript对JSON的功能支持 2.单页面、多Ajax请求应用——前端有大量的异步请求，需要服务器后端有极高的响应速度 3.基于node.js开发Unix命令行工具——node.js可以大量产生子进程，并以流的方式输出 4.流式数据——传统的web应用，通常会将HTTP 请求喝响应看成是原子事件。而node.js会充分利用流式数据这个特点，构建非常酷的应用 不适用场景：cpu使用率较重、io使用率较轻的应用 Node.js的基本语法基本语法与 javascript 一样这里我们使用exports导出一个函数,然后再另一文件中通过require导入入一个模块例如 ：在 a.js 中写一个函数var hello=function(){ console.log(‘hello’)}export.hello=hello;在 b.js 中 需要用hello这个函数var a=require(‘a’);a.hello()单线程Node的设计中就是将耗时长的操作代理给操作系统或者多线程，这部分操作就是磁盘I/O和网络I/O。所以Node中异步非常常见，因为要将耗时的操作从主线程上脱离。但是这些I/O线程并不怎么耗费CPU。无法利用多核CPU是指Node的主线程无法利用上硬件上额外的CPU。这就需要用到cluster来在机器上启动多个Node实例，将额外的CPU也使用上。异步 IO事件驱动REPLREPL（Read-Eval-Print Loop） 中文的话有翻译成“交互式解释器”或“交互式编程环境”的。 koa洋葱圈运行机制1234567891011121314151617181920const Koa = require('koa');const app = new Koa();app.use(async (ctx, next) =&gt; &#123; console.log(1); await next(); console.log(6);&#125;);app.use(async (ctx, next) =&gt; &#123; console.log(2); await next(); console.log(5);&#125;);app.use(async (ctx, next) =&gt; &#123; console.log(3); ctx.body = "hello world"; console.log(4);&#125;);app.listen(3000, () =&gt; &#123; console.log('listenning on 3000');&#125;); 上面的代码执行后会输出123456，就像一个洋葱一样，从外层进去，然后碰到next()就执行下一个中间件，执行完成后再返回回来。先假设我们已经实现了next为下个中间件这段代码，上面的执行逻辑就很清楚了，先输出1，然后进入下一个中间件，去处理2，同理最后后面都处理完成后处理5，5处理完成后第二个中间件结束，然后第一个中间件再处理6。 所以现在就是怎么实现这个代码。通过看Koa的源码我们可以发现它是通过koa-compose这个库实现的，代码很短，如下： 12345678910111213141516171819function compose (middleware) &#123; return function (context, next) &#123; // last called middleware # let index = -1 return dispatch(0) function dispatch (i) &#123; if (i &lt;= index) return Promise.reject(new Error('next() called multiple times')) index = i let fn = middleware[i] if (i === middleware.length) fn = next if (!fn) return Promise.resolve() try &#123; return Promise.resolve(fn(context, dispatch.bind(null, i + 1))); &#125; catch (err) &#123; return Promise.reject(err) &#125; &#125; &#125;&#125; 核心代码就是return Promise.resolve(fn(context, dispatch.bind(null, i + 1)));这里了，每次执行中间件时，会将第二个中间件作为函数的第二个参数传进去。这也就和上面的async (ctx, next) =&gt; {}写法对应上了，所以执行next()就可以执行下一个中间件了。 还是利用闭包和递归的性质，一个个执行，并且每次执行都是返回promise，所以最后得到的打印结果也是如我们所愿。那么路由的中间件是否调用就不是koa2管的，这个工作就交给了koa-router，这样koa2才可以保持精简彪悍的风格。 参考地址：https://www.jianshu.com/p/2639d43b0d9e express和koa区别 提到Node.js开发，不得不提目前炙手可热的2大框架express和koa。Express诞生已有时日，是一个简洁而灵活的web开发框架，使用简单而功能强大。Koa相对更为年轻，是Express框架原班人马基于ES6新特性重新开发的敏捷开发框架，现在可谓风头正劲，大有赶超Express之势。 虽然koa看上去比express少集成了很多功能，但是使用起来其实基本一致，因为中间件非常丰富全面，需要什么require进来就行了（不一定要像express那样先帮你require好），使用起来反而更加灵活。 请求 HTTP Request 服务器端需要进行什么处理，怎么处理以及处理的参数都依赖客户端发送的请求，两个框架都封装了HTTP Request对象，便于对这一部分进行处理。以下主要举例说明下对请求参数的处理，其它例如头信息、Cookie等请参考官方文档。两者除了写法上稍有区别，没太大区别。GET参数都可以直接通过Request对象获取，POST参数都需要引入中间件先parse，再取值。 路由Route 收到客户端的请求，服务需要通过识别请求的方法（HTTP Method: GET, POST, PUT…）和请求的具体路径(path)来进行不同的处理。这部分功能就是路由（Route）需要做的事情，说白了就是请求的分发，分发到不同的回调方法去处理。 这里需要说明2个问题，首先是app.get，在应用生命周期中也有一个app.get方法，用于获取项目配置。Express内部就是公用的一个方法，如果传入的只有1个参数就获取配置，2个参数就作为路由处理。其次是app.use(&#39;*&#39;, cb) 与app.all(&#39;*&#39;, cb) 的区别，前者是中间件方式，调用是有顺序的，不一定会执行到；后者是路由方式，肯定会执行到。 返回 HTTP Response 获取完请求参数、处理好了具体的请求、视图也准备就绪，下面就该返回给客户端了，那就是HTTP Response对象了。这部分也属于框架的基础部分，各种都做了封装实现，显著的区别是koa直接将输出绑定到了ctx.body属性上，另外输出JSON或JSONP需要引入中间件。 中间件 Middleware 对比了主要的几个框架功能方面的使用，其实区别最大，使用方式最不同的地方是在中间件的处理上。Express由于是在ES6特性之前的，中间件的基础原理还是callback方式的；而koa得益于generator特性和co框架（co会把所有generator的返回封装成为Promise对象），使得中间件的编写更加优雅。 Nginx原理 反向代理 反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端 反向代理服务器对于客户端而言它就像是原始服务器，并且客户端不需要进行任何特别的设置，代理的是“服务端” 正向代理是一个位于客户端和原始服务器(origin server)之间的服务器，代理的是”客户端“ 负载均衡 客户端发送的、Nginx 反向代理服务器接收到的请求数量，就是我们说的负载量。请求数量按照一定的规则进行分发，到不同的服务器处理的规则，就是一种均衡规则。所以将服务器接收到的请求按照规则分发的过程，称为负载均衡。 工作流程 用户通过域名发出访问Web服务器的请求，该域名被DNS服务器解析为反向代理服务器的IP地址 反向代理服务器接受用户的请求 反向代理服务器在本地缓存中查找请求的内容，找到后直接把内容发送给用户 如果本地缓存里没有用户所请求的信息内容，反向代理服务器会代替用户向源服务器请求同样的信息内容，并把信息内容发给用户，如果信息内容是缓存的还会把它保存到缓存中 优点 保护了真实的web服务器，保证了web服务器的资源安全 节约了有限的IP地址资源 减少WEB服务器压力，提高响应速度 其他：（1）请求的统一控制，包括设置权限、过滤规则等；（2）区分动态和静态可缓存内容；（3）实现负载均衡，内部可以采用多台服务器来组成服务器集群，外部还是可以采用一个地址访问；（4）解决Ajax跨域问题；（5）作为真实服务器的缓冲，解决瞬间负载量大的问题； 原理 Nginx有五大优点：模块化、事件驱动、异步、非阻塞、多进程单线程。由内核和模块组成的，其中内核完成的工作比较简单，仅仅通过查找配置文件将客户端请求映射到一个location block，然后又将这个location block中所配置的每个指令将会启动不同的模块去完成相应的工作。 Nginx本身做的工作实际很少，当它接到一个HTTP请求时，它仅仅是通过查找配置文件将此次请求映射到一个location block，而此location中所配置的各个指令则会启动不同的模块去完成工作，因此模块可以看做Nginx真正的劳动工作者。通常一个location中的指令会涉及一个handler模块和多个filter模块（当然，多个location可以复用同一个模块）。handler模块负责处理请求，完成响应内容的生成，而filter模块对响应内容进行处理。 用户根据自己的需要开发的模块都属于第三方模块。正是有了这么多模块的支撑，Nginx的功能才会如此强大。 参考地址：https://www.jianshu.com/p/6215e5d24553 手写中间件测试请求时间在实战项目中，经常需要记录下服务器的响应时间，也就是从服务器接收到HTTP请求，到最终返回给客户端之间所耗时长。在Koa应用中，利用中间件机制可以很方便的实现这一功能。代码如下所示： 12345678910111213141516171801 const koa = require('koa');02 const app = new koa();03 app.use(async (ctx, next) =&gt; &#123; // 记录服务器响应时间的中间件04 let stime = new Date().getTime(); // 记录当前时间戳05 await next(); // 事件控制权中转06 let etime = new Date().getTime(); // 所有中间件执行完成后记录当前时间07 ctx.response.type = 'text/html';08 ctx.response.body = '&lt;h1&gt;Hello World&lt;/h1&gt;';09 console.log(`请求地址: $&#123;ctx.path&#125;，响应时间：$&#123;etime - stime&#125;ms`);10 &#125;);11 app.use(async (ctx, next) =&gt; &#123;12 console.log('中间件 doSoming');13 await next();14 console.log('中间件执行 over');15 &#125;);16 app.listen(3000, () =&gt; &#123;17 console.log('server is running at http://localhost:3000');18 &#125;); 运行时行时是指一个程序在运行（或者在被执行）的依赖。也就是说，当你打开一个程序使它在电脑上运行的时候，那个程序就是处于运行时刻。在一些编程语言中，把某些可以重用的程序或者实例打包或者重建成为“运行库”。这些实例可以在它们运行的时候被连接或者被任何程序调用，同时依赖于运行时系统。 Node Js与JavaScript的区别及nodejs优缺点1.原生js运行文件依赖于浏览器； 2.nodejs运行文件的时候服务为终端； 3.原生js有兼容性问题，nodejs不存在兼容性问题； 4.nodejs可以进行本地的读写，服务器搭建，连接数据库等，而原生js无法做到。 nodejs的优点：在项目中相当于中间层的使用 缺点：不适合大量的运算]]></content>
      <categories>
        <category>前端知识点总结</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>node.js框架</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端知识点总结——React]]></title>
    <url>%2F2020%2F06%2F08%2F%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94React%2F</url>
    <content type="text"><![CDATA[虚拟DOM &amp;&amp; Diff算法虚拟dom是什么 它是一个Object对象模型，用来模拟真实dom节点的结构 虚拟dom的使用基本流程（前四步骤） 1.获取数据 2.创建vdom 通过render函数解析jsx，将其转换成 vdom结构 4.将vdom渲染成真实dom 5.数据更改了 6.使用diff算法比对两次vdom,生成patch对象 7.根据key将patch对象渲染到页面中改变的结构上，而其他没有改变的地方是不做任何修改的（ 虚拟dom的惰性原则 ） diff算法是什么Virtual DOM 的加速器 React 中醉值得称道的莫过于Virtual DOM与diff的完美结合，尤其是其高效的diff算法，可以帮助我们在页面蔌渲染的时候，计算出Virtual DOM真正变化的部分，并只针对该部分进行的原生DOM操作，而不是渲染整个页面，从而保证了每次操作后，页面的高效渲染。 virtual dom为何用diff算法？ DOM操作是昂贵的，应该尽可能减少DOM操作 找出本次必须更新的节点，其他的不用更新 这个“找出”的过程，就需要diff算法 一句话，virtual dom中应用diff算法是为了找出需要更新的节点 diff 策略下面是 React diff 算法的 3 个策略： 策略一：Web UI 中 DOM 节点跨层级的移动操作特别少。可以忽略不计。策略二：拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。策略三：对于同一层级的一组子节点，它们可以通过唯一 id 进行区分。 基于以上三个策略，React 分别对 tree diff、component diff 以及 element diff 进行算法优化。 diff算法运行结束后，返回是什么 返回一个key 注意：vue是一个mvvm框架，Vue高性能的原因之一就是vdom 需求：有一个变量count的初始值为0，经过一系列的运算,得到10001，然后将结果写入box中123456789101112131415161718&lt;div class='box'&gt;&lt;/div&gt;&lt;script&gt; var box = document.querySelect('.box') var count = 0 //console.time('a') //for(var i=0;i&lt;10001;i++)&#123; // count++ // box.innerHTML = count //这里操作了10000次dom //&#125; //console.timeEnd('a') /////////////////////////////////////////////////////// console.time('b') for(var i=0;i&lt;10001;i++)&#123; count++ &#125; box.innerHTML = count //正常写法操作一次dom console.timeEnd('b') &lt;/script&gt; 结论：1.更少的dom操作会更加减少时间花费，减少性能损耗 2.所以我们应该 先操作数据 再去操作dom 3.由以上结论慢慢的前端将一个新的概念引入在框架中 （这个概念就是虚拟dom） ant-design优点和缺点优点：组件非常全面，样式效果也都比较不错。 缺点：框架自定义程度低，默认UI风格修改困难。 redux用处在组件化的应用中，会有着大量的组件层级关系，深嵌套的组件与浅层父组件进行数据交互，变得十分繁琐困难。而redux，站在一个服务级别的角度，可以毫无阻碍地将应用的状态传递到每一个层级的组件中。redux就相当于整个应用的管家。 React和vueeact的最大特点就是简单并且与原生JavaScript非常接近。即给开发者带来的束缚非常少。一个功能的实现，如果你知道使用原生JavaScript如何实现，那么你就一定能够很轻松的知道使用react如何实现。 reactJs的组件交流React组件之间的交流方式可以分为以下三种 1、父组件向子组件传值:主要是利用props来进行交流 2、子组件向父组件传值：子组件通过控制自己的state然后告诉父组件的点击状态。然后在父组件中展示出来 3、没有任何嵌套关系的组件之间传值：如果组件之间没有任何关系，组件嵌套层次比较深（个人认为 2 层以上已经算深了），或者你为了一些组件能够订阅、写入一些信号，不想让组件之间插入一个组件，让两个组件处于独立的关系。对于事件系统，这里有 2 个基本操作步骤：订阅（subscribe）/监听（listen）一个事件通知，并发送（send）/触发（trigger）/发布（publish）/发送（dispatch）一个事件通知那些想要的组件。 说说自己理解的reactReact是用于构建用户界面的JavaScript库。React可以创建交互式UI。为应用程序中的每个状态建立的视图，并且React将在数据更改时进行更新，呈现正确的组件。另外，我们也可以构建管理自己状态的封装组件，然后将它们组合成复杂的UI。因为组件用JS编写而不是模板，所以可以通过应用传递数据，并使状态与DOM分离 dom是什么，你的理解文档对象模型（Document Object Model，简称DOM），是W3C组织推荐的处理可扩展标志语言的标准编程接口。在网页上，组织页面（或文档）的对象被组织在一个树形结构中，用来表示文档中对象的标准模型就称为DOM。 关于dom的api有什么节点创建型api，页面修改型API，节点查询型API，节点关系型api，元素属性型api，元素样式型api等 webpack和gulp区别（模块化与流的区别）gulp强调的是前端开发的工作流程，我们可以通过配置一系列的task，定义task处理的事务（例如文件压缩合并、雪碧图、启动server、版本控制等），然后定义执行顺序，来让gulp执行这些task，从而构建项目的整个前端开发流程。 webpack是一个前端模块化方案，更侧重模块打包，我们可以把开发中的所有资源（图片、js文件、css文件等）都看成模块，通过loader（加载器）和plugins（插件）对资源进行处理，打包成符合生产环境部署的前端资源。 vue react angularjs jqueryJQuery与另外几者最大的区别是，JQuery是事件驱动，其他两者是数据驱动。 JQuery业务逻辑和UI更改混在一起， UI里面还参杂这交互逻辑，让本来混乱的逻辑更加混乱。 Angular，vue是双向绑定，而React不是 其他还有设计理念上的区别等]]></content>
      <categories>
        <category>前端知识点总结</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>前端框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[位运算]]></title>
    <url>%2F2020%2F06%2F08%2F%E4%BD%8D%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[按位与运算符（&amp;）参加运算的两个数，按二进制位进行“与”运算。运算规则：只有两个数的二进制同时为1，结果才为1，否则为0。（负数按补码形式参加按位与运算）即 0 &amp; 0= 0 ，0 &amp; 1= 0，1 &amp; 0= 0， 1 &amp; 1= 1。 例：3 &amp;5 即 00000011 &amp; 00000101 = 00000001 ，所以 3 &amp; 5的值为1。 按位或运算符（|）参加运算的两个数，按二进制位进行“或”运算。运算规则：参加运算的两个数只要两个数中的一个为1，结果就为1。即 0 | 0= 0 , 1 | 0= 1 ， 0 | 1= 1 , 1 | 1= 1 。 例：2 | 4 即 00000010 | 00000100 = 00000110 ，所以2 | 4的值为 6 。 异或运算符（^）参加运算的两个数，按二进制位进行“异或”运算。运算规则：参加运算的两个数，如果两个相应位为“异”（值不同），则该位结果为1，否则为0。即 0 ^ 0=0 ， 0 ^ 1= 1 ， 1 ^ 0= 1 ， 1 ^ 1= 0 。 例： 2 ^ 4 即 00000010 ^ 00000100 =00000110 ，所以 2 ^ 4 的值为6 。]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用openpyxl处理excel表格]]></title>
    <url>%2F2020%2F06%2F07%2F%E4%BD%BF%E7%94%A8openpyxl%E5%A4%84%E7%90%86excel%E8%A1%A8%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[前言 邹同学是国贸专业的，听她说其他同学处理数据都是手动，真实骇人听闻啊，遂昨晚花了点时间研究了下，跑了个小demo，这里分享给大家，也随便记录下自己的python学习之旅 首先申明笔者并不了解python，代码不规范的地方还请多多理解 需求 给定一个文件夹finance_export，下边的有很多个excel表格，现在需要将excel表格不重要的信息过滤出去，然后合并到一张新表中 第三方库 OpenPYXL 和 os 这个demo只用到了以下两个库（不得不说python是真的好用啊，啥样的库都有，方便又高效） OpenPYXL是一个用于读/写Excel2010 XLSX/XLSM/XLTX/XLTM文件的python库。它的诞生是由于缺少从Python（OfficeOpenXML格式）本地读/写的现有库。 os模块提供了非常丰富的方法用来处理文件和目录。 实现首先找一个目录，准备好这样的几个文件夹 每个文件的目录结构和作用如图，当然你可以去源码中修改 test3.py 定义了一个函数，方便主程序调用。这个函数用于修改单张表数据的，接收一个参数（单张表的地址）,处理完成后保存在指定的文件夹下边，如下所示。 123456789101112131415161718192021222324252627282930313233343536#一个函数，调用是在merge.py下，传过来的是单张表的地址，如C:\Users\LanxiangC2\Desktop\study\tsouling_data\myblog\finance_export\Canada.xlsxef deal_one(url): import openpyxl as xl # 单张列表处理数据并另存为 # 思路如下 # wb2为新文件 wb1为操作的数据 wb2 = xl.Workbook() wb = xl.load_workbook(url) ws = wb.active ws2 = wb2.active # 连个文件我们都取到第一个表单 sheet = wb.worksheets[0] sheet2 = wb2.worksheets[0] # 提取表中的关键元素并保存，作为一会每行的第一个元素 export_country = sheet["C3"].value # 删掉不重要的行 这里是1到9 sheet.delete_rows(1,9) # 删掉第二列 因为不知道是什么鬼 sheet.delete_cols(2) # 插入第一列 此时第一列为空白 sheet.insert_cols(1,1) # 接下来我们先对每行的第一个元素赋值 之前保存的export_country for row_idx in range(1, sheet.max_row): # 第一行第一个元素赋值 sheet["A&#123;&#125;".format(row_idx)] = export_country # 然后拷贝每一个元素到新的表中去 for col_idx in range(1, sheet.max_column): tmp = ws.cell(row =row_idx, column = col_idx).value ws2.cell(row = row_idx, column = col_idx, value = tmp) # 分别保存看结果 wb.save('./newdata1/'+ export_country +'_new.xlsx') wb2.save('./newdata/'+ export_country +'_new.xlsx') print(export_country +'.xlsx操作完成') merge.py 这个程序呢首先获取到原始数据下的所有表的名字，然后循环处理每一个文件，调用上一个程序传入单张表的地址。之后开始合并操作，合并时新建一个表，没合并一个表，记录下当前表的行数，避免下次合并时覆盖，不用说也是用循环，如下所示。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#引入上一个程序test2import test2import openpyxl as xlimport osprint('开始处理每一张表--------------------------------------')#path是你自己的路径path = 'C:/Users/LanxiangC2/Desktop/study/tsouling_data/finance_export/'file_list = os.listdir(path) # 获取这个文件夹下所有的excel文档print(file_list)#循环操作每一张表for file in file_list: test2.deal_one(path + file)print('每一张表处理完毕--------------------------------------')print('现在开始合并操作++++++++++++++++++++++++++++++++++++++')#path2是你自己的路径path2 = 'C:/Users/LanxiangC2/Desktop/study/tsouling_data/newdata/'wb3 = xl.Workbook() #新建一个表，这个表存放的是最终的数据结果ws3 = wb3.active #设置为当前操作空间sheet3 = wb3.worksheets[0] #默认获取的也是第一个表单sheetlist = os.listdir(path2) # 获取这个文件夹下所有的excel文档row_count = 0 #记录下新的表单合并到多少行了,避免重复覆盖掉了#循环记录list下的每一个表的内容for name in list: #读取单张表并拿到表单内容 wb = xl.load_workbook(path2 + name) ws = wb.active sheet = wb.worksheets[0] #print(str(name) + '的列数:' + str(sheet.max_column)) #循环读取这张表的数据，两个循环，行循环一次列循环一次 for row_idx in range(1, sheet.max_row + 1): for col_idx in range(1, sheet.max_column + 1): #记录数值到新的表里 tmp = ws.cell(row =row_idx, column = col_idx).value ws3.cell(row = row_idx + row_count, column = col_idx, value = tmp) #记录下新的表单合并到多少行了,避免重复覆盖掉了 row_count += sheet.max_rowprint(row_count)print('合并操作结束++++++++++++++++++++++++++++++++++++++')#保存到指定路径wb3.save('./final_new/data.xlsx')print('success!所有操作操作完成') 完结撒花！ 等等还是运行一下看看效果吧，希望不会被打脸，文件根目录下python merge.py，回车 没有报错！成功。可以看到几行代码就实现了对n张表的数据处理，并且生成了1847行的一张新表，要是手动的话，emmm。手动@邹同学啊，pyton是个好东西赶快学起来。 总结 openpyxl对Excel表格的创建与写操作例程 以下参考作者卡图卢斯博客地址：https://blog.csdn.net/u014647208/article/details/78684812 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155#encoding: utf8 from openpyxl import Workbook#创建一个工作薄#使用openpyxl没有必要先在系统中新建一个.xlsx，我们需要做的只需要引Workbook这个类，接着开始调用它。#-----------------------------------------------------------------------------------wb = Workbook()#-----------------------------------------------------------------------------------#一个工作簿(workbook)在创建的时候同时至少也新建了一张工作表(worksheet)。你可以通过openpyxl.workbook.Workbook.active()调用得到正在运行的工作表。#-----------------------------------------------------------------------------------ws = wb.active"""注意：该函数调用工作表的索引(_active_sheet_index)，默认是0。除非你修改了这个值，否则你使用该函数一直是在对第一张工作表进行操作。"""#-----------------------------------------------------------------------------------#使用openpyxl.workbook.Workbook.create_sheet()新建一张表#-----------------------------------------------------------------------------------ws1 = wb.create_sheet() #默认插在工作簿末尾ws2 = wb.create_sheet(0) #插入在工作簿的第一个位置#-----------------------------------------------------------------------------------#在创建工作表的时候系统自动命名。他们按照序列依次命名 (Sheet, Sheet1, Sheet2, ...)。你可以通过调用下面的属性修改工作表的名称：#-----------------------------------------------------------------------------------ws.title = "New Title" #系统第一张表默认的名称Sheet#-----------------------------------------------------------------------------------#标签栏的背景色默认为白色。你可以通过提供一个RRGGBB颜色码改变标签栏的字体#-----------------------------------------------------------------------------------#ws.sheet_properties.tabColor = "1072BA"ws.sheet_properties.tabColor = "ff0033" #红色#-----------------------------------------------------------------------------------#一旦你获取工作表的名字，你可以通过workbook的key或者openpyxl.workbook.Workbook.get_sheet_by_name() 方法得到该工作表#-----------------------------------------------------------------------------------ws3 = wb["New Title"]ws4 = wb.get_sheet_by_name("New Title")print(ws is ws3 is ws4)#-----------------------------------------------------------------------------------#你可以通过openpyxl.workbook.Workbook.get_sheet_names() 方法得到工作簿的所有工作表。#-----------------------------------------------------------------------------------print(wb.get_sheet_names())#-----------------------------------------------------------------------------------#你也可以循环得到所有的工作表#-----------------------------------------------------------------------------------for sheet in wb: print(sheet.title)#-----------------------------------------------------------------------------------#单元格可以直接根据他们的索引直接获得#-----------------------------------------------------------------------------------c = ws['A4']print(type(c))print(c)#-----------------------------------------------------------------------------------#通过上述的语句，将返回在A4处的单元格，如果不存在将在A4新建一个。 单元格的#-----------------------------------------------------------------------------------ws['A4'] = 4#------------------------------------------------------------------------------------------------------------------#还提供 openpyxl.worksheet.Worksheet.cell() 方法获取单元格#-----------------------------------------------------------------------------------c = ws.cell("A4")print(c)#-----------------------------------------------------------------------------------#也可以根据行列值获取单元格#-----------------------------------------------------------------------------------d = ws.cell(row = 4, column = 2)print(d)print("d:",type(d))"""注意：当一个工作表被创建是，其中不包含单元格。只有当单元格被获取是才被创建。这种方式我们不会创建我们从不会使用的单元格，从而减少了内存消耗。"""#-----------------------------------------------------------------------------------#警告：由于上述特性，你如果遍历了单元格而非想要使用它们也将会在内存当中创建。比如下面：#-----------------------------------------------------------------------------------for i in range(1,101): for j in range(1,101): ws.cell(row = i, column = j)"""上述代码将会在内存中创建100*100个单元格。当然，这里也有方法来清理这些不想要的单元格，在后续我们将会介绍。""" #-----------------------------------------------------------------------------------#使用切片获取多个单元格#-----------------------------------------------------------------------------------cell_range = ws['A1':'C2']#-----------------------------------------------------------------------------------#使用openpyxl.worksheet.Worksheet.iter_rows() 方法获得多个单元格#-----------------------------------------------------------------------------------tuple(ws.iter_rows('A1:C2'))print(tuple(ws.iter_rows('A1:C2')))list(ws.iter_rows('A1:C2'))print(list(ws.iter_rows('A1:C2')))for row in ws.iter_rows('A1:C2'): for cell in row: print(cell)#-----------------------------------------------------------------------------------#如果你需要迭代文件中所有的行或者列，你可以使用,openpyxl.worksheet.Worksheet.rows()#-----------------------------------------------------------------------------------ws['C9'] = 'hello world'#-----------------------------------------------------------------------------------#一旦我们有一个openpyxl.cell.Cell，我们可以直接为该单元格赋值#-----------------------------------------------------------------------------------c = ws['C8']c.value = "nihao"print(c.value)print(ws['C8'].value)d.value = 3.14print(d.value)#-----------------------------------------------------------------------------------#你也可以使用Python中的其他类型和格式#-----------------------------------------------------------------------------------#wb = Workbook(guess_types=True)c.value = '12%'print(c.value)import datetimed.value = datetime.datetime.now()print (d.value)c.value = '31.50'print(c.value)#-----------------------------------------------------------------------------------#保存工作簿最简单最安全的方式是使用openpyxl.workbook.Workbook的openpyxl.workbook.Workbook.save() 方法#-----------------------------------------------------------------------------------wb.save("TonyDemoExcle.xlsx")"""特别警告：这个操作将会在没有认识提示的情况下用现在写的内容，覆盖掉原文件中的所有内容"""#-----------------------------------------------------------------------------------#你也可以 as_template=True，将文件保存称为一个模板#-----------------------------------------------------------------------------------wb = load_workbook('TonyDemoExcle1.xlsx')wb.save('TonyDemoExcle1.xltx', as_template=True)#-----------------------------------------------------------------------------------#和写入文件的方式相同，你可以引入openpyxl.load_workbook()来打开一个已经存在的工作簿#-----------------------------------------------------------------------------------from openpyxl import load_workbookwb2 = load_workbook('test.xlsx')print(wb2.get_sheet_names())]]></content>
      <categories>
        <category>python学习之旅</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组中的逆序对]]></title>
    <url>%2F2020%2F06%2F05%2F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9%2F</url>
    <content type="text"><![CDATA[题目描述：在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007 参考博客：https://cuijiahua.com/blog/2018/01/basis_35.html javascript实现代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556function InversePairs(data)&#123; // write code here if (data.length === 0 ) &#123; return 0 &#125; let copy = [].concat(data) //归并排序 function mergeCount (data, copy , left, right) &#123; if (left === right) &#123; return 0 &#125; let mid = (left + right) &gt;&gt; 1 let leftCount = mergeCount(data, copy, left, mid) let rightCount = mergeCount(data, copy, mid+1, right) //定义左右数组的指针 从左往右 let pl = left let pr = mid + 1 //定义辅助数组的指针 let idx = left // 定义左右之间的的逆序对 let betweenCount = 0 while (pl &lt;= mid &amp;&amp; pr &lt;= right) &#123; if (data[pl] &gt; data[pr]) &#123; // 计算就在这一步哦 核心关键点 betweenCount += mid - pl + 1 copy[idx++] = data[pr++] &#125;else &#123; copy[idx++] = data[pl++] &#125; &#125; // 把没填入辅助队列的填入 while (pl &lt;= mid) &#123; copy[idx++] = data[pl++] &#125; while (pr &lt;= right) &#123; copy[idx++] = data[pr++] &#125; for (let i = left; i &lt;= right; i++) &#123; data[i] = copy[i] &#125; return (rightCount + leftCount + betweenCount) &#125; let count = mergeCount(data, copy , 0, data.length -1) return count % 1000000007&#125; module.exports = &#123; InversePairs : InversePairs&#125;;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[找第N个丑数]]></title>
    <url>%2F2020%2F06%2F05%2F%E6%89%BE%E7%AC%ACN%E4%B8%AA%E4%B8%91%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 先看看我自己的代码吧 1234567891011121314151617181920212223242526272829303132333435363738394041function GetUglyNumber_Solution(index)&#123; //找一个数的质因子列表 let getPrimes = (num) =&gt; &#123; let recur = (num) =&gt; &#123; let arr = [] //找质因子 for (let i=2, len = num/2 +1 ; i &lt; len; i++)&#123; if (num % i === 0 &amp;&amp; !recur(i).length) &#123; arr.push(i) &#125; &#125; return arr &#125; return recur(num) &#125; let res = [1] let i = 2 while( res.length &lt; index) &#123; let primes = getPrimes(i) //即这个数没有质因数 if (primes.length === 0) &#123; if (i === 2 || i=== 3|| i ===5) &#123; res.push(i) &#125; &#125; else &#123; let valide = true primes.forEach((item) =&gt; &#123; if (item !== 2 &amp;&amp; item !==3 &amp;&amp; item !==5) &#123; valide = false &#125; &#125;) if (valide) &#123; res.push(i) &#125; &#125; i++ &#125; return res[index - 1]&#125; 结果运行超时，嚎嚎大哭有木有。 然后请教了下讨论区的同学，看了下他们的分享 123456789101112131415161718192021class Solution &#123;public: int GetUglyNumber_Solution(int index) &#123; // 0-6的丑数分别为0-6 if(index &lt; 7) return index; //p2，p3，p5分别为三个队列的指针，newNum为从队列头选出来的最小数 int p2 = 0, p3 = 0, p5 = 0, newNum = 1; vector&lt;int&gt; arr; arr.push_back(newNum); while(arr.size() &lt; index) &#123; //选出三个队列头最小的数 newNum = min(arr[p2] * 2, min(arr[p3] * 3, arr[p5] * 5)); //这三个if有可能进入一个或者多个，进入多个是三个队列头最小的数有多个的情况 if(arr[p2] * 2 == newNum) p2++; if(arr[p3] * 3 == newNum) p3++; if(arr[p5] * 5 == newNum) p5++; arr.push_back(newNum); &#125; return newNum; &#125;&#125;; 其思路如下 通俗易懂的解释： 首先从丑数的定义我们知道，一个丑数的因子只有2,3,5，那么丑数p = 2 ^ x * 3 ^ y * 5 ^ z，换句话说一个丑数一定由另一个丑数乘以2或者乘以3或者乘以5得到，那么我们从1开始乘以2,3,5，就得到2,3,5三个丑数，在从这三个丑数出发乘以2,3,5就得到4，6,10,6，9,15,10,15,25九个丑数，我们发现这种方\*得到重复的丑数，而且我们题目要求第N个丑数，这样的方法得到的丑数也是无序的。那么我们可以维护三个队列：** （1）丑数数组： 1 乘以2的队列：2 乘以3的队列：3 乘以5的队列：5 选择三个队列头最小的数2加入丑数数组，同时将该最小的数乘以**2,3,5**放入三个队列； （2）丑数数组：1,2 乘以2的队列：4 乘以3的队列：3，6 乘以5的队列：5，10 选择三个队列头最小的数3加入丑数数组，同时将该最小的数乘以2,3,5放入三个队列； （3）丑数数组：1,2,3 乘以2的队列：4,6 乘以3的队列：6,9 乘以5的队列：5,10,15 选择三个队列头里最小的数4加入丑数数组，同时将该最小的数乘以2,3,5放入三个队列； （4）丑数数组：1,2,3,4 乘以2的队列：6，8 乘以3的队列：6,9,12 乘以5的队列：5,10,15,20 选择三个队列头里最小的数5加入丑数数组，同时将该最小的数乘以**2,3,5，放入三个队列； （5）丑数数组：1,2,3,4,5 乘以2的队列：6,8,10， 乘以3的队列：6,9,12,15 乘以5的队列：10,15,20,25 选择三个队列头里最小的数6加入丑数数组，但我们发现，有两个队列头都为6，所以我们弹出两个队列头，同时将12,18,30放入三个队列； …………………… 疑问： 1.为什么分三个队列？ 丑数数组里的数一定是有序的，因为我们是从丑数数组里的数乘以2,3,5选出的最小数，一定比以前未乘以2,3,5大，同时对于三个队列内部，按先后顺序乘以2,3,5分别放入，所以同一个队列内部也是有序的； 2.为什么比较三个队列头部最小的数放入丑数数组？ 因为三个队列是有序的，所以取出三个头中最小的，等同于找到了三个队列所有数中最小的。 实现思路： 我们没有必要维护三个队列，只需要记录三个指针显示到达哪一步；“|”表示指针,arr表示丑数数组； （1）1 |2 |3 |5 目前指针指向0,0,0，队列头arr[0] * 2 = 2, arr[0] * 3 = 3, arr[0] * 5 = 5 （2）1 2 2 |4 |3 6 |5 10 目前指针指向1,0,0，队列头arr[1] * 2 = 4, arr[0] * 3 = 3, arr[0] * 5 = 5 （3）1 2 3 2| 4 6 3 |6 9 |5 10 15 目前指针指向1,1,0，队列头arr[1] * 2 = 4, arr[1] * 3 = 6, arr[0] * 5 = 5 ……………… 啊，再次嚎嚎大哭有木有！大佬，大佬！]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[部署静态页面到服务器]]></title>
    <url>%2F2020%2F06%2F04%2F%E9%83%A8%E7%BD%B2%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[秋招将至，一名前端小白无时不刻不在幻想如何才能在众多简历中脱颖而出 想说一句非科班出身的太难了，我搞了好半天才把静态页面部署到服务器上，说个题外话，买服务器的时候我还在纠结买哪个公司的，担心到时候面试官问到会很尴尬呀（哈哈，梦回高考之前在想去北大还是清华啦）。先给自己拟定一个流程图吧（emmmm，不知道能不能行呀）。 WinScp和Xchell WinSCP是一个Windows环境下使用SSH的开源图形化SFTP客户端。同时支持SCP协议。它的主要功能就是在本地与远程计算机间安全的复制文件。winscp也可以链接其他系统,比如linux系统。 没错安装这个软件正是为了和我的win本对接，方便又好用 Xshell是一个强大的安全终端模拟软件，它支持SSH1, SSH2, 以及Microsoft Windows 平台的TELNET 协议。Xshell 通过互联网到远程主机的安全连接以及它创新性的设计和特色帮助用户在复杂的网络环境中享受他们的工作。 Xshell很方便地模拟服务器上的终端，不错的工具，这里我都装上了，接下来就是对服务器进行配置了啦 Nginx安装和配置 Nginx (engine x) 是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务。Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点（俄文：Рамблер）开发的，第一个公开版本0.1.0发布于2004年10月4日。 我的服务器操作系统选用的是ubuntu，其他系统朋友们请自行查阅哦 安装 1sudo apt-get install nginx 配置 1cat /etc/nginx/nginx.conf 以下代码提供 http 服务相关的配置参数，一般默认配置就可以，主要配置在于 http 上下文里的 server 上下文 12345678910111213141516171819http &#123; sendfile on; keepalive_timeout 65; types_hash_max_size 2048; include /etc/nginx/mime.types; default_type application/octet-stream; server &#123; # 监听本机所有 ip 上的 80 端口 listen 80; # 域名, &quot;_&quot; 代表获取匹配所有 server_name localhost; # 站点根目录 root /usr/share/nginx/html default_type text/html; # 可有多个 location 用于配置路由地址 location / &#123; index index.html; &#125;&#125; 这里关注location配置，nginx会根据匹配规则去root根目录下寻找，这里我的根目录地址是/usr/share/nginx/html,存放配置文件的地址是/etc/nginx/nginx.conf 启动 利用配置文件启动nginx 1nginx -c /etc/nginx/nginx.conf 重装载命令 使用 reload 方法不用重启服务，直接重新加载配置文件，客户端感觉不到服务异常，实现平滑切换。当然你也可以重新启动 nginx 服务。 1nginx -s reload 重启 nginx -s reload1sudo service nginx restart 停止 1sudo nginx -s stop 另外，想查看下进程 123456#查看非root启动的程序ps -U root -u root -N#系统中的每个进程ps -A ps -e#top命令提供了运行中系统的动 部署静态页面nginx配置完成后就可以放置我的静态网页到服务器上啦，想想还有点小激动呢，先输入我的域名试下吧，地址栏输入www.lanxiangc2.cn，点击确定，bingo！ 启动成功啦！接下来按照对nginx的设置放置一个静态网页到指定的目录下，输入www.lanxiangc2.cn/homeworkdemo，点击回车，bingo！ 忙活了半天总算是没有瞎忙活啊，接下来就着手好好准备作品和demo吧，加油！！！]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>部署</tag>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉搜索树转化为双向链表]]></title>
    <url>%2F2020%2F06%2F04%2F%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E5%8C%96%E4%B8%BA%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[昨天遇到一道这样的题，‘输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。’，想了很久才弄明白。 思路就是利用中序遍历，然后根据二叉搜索树的特性去递归。代码如下。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/* function TreeNode(x) &#123; this.val = x; this.left = null; this.right = null;&#125; */function Convert(pRootOfTree)&#123; // write code here//1.将左子树构造成双链表，并返回链表头节点。///2.定位至左子树双链表最后一个节点。//3.如果左子树链表不为空的话，将当前root追加到左子树链表。//4.将右子树构造成双链表，并返回链表头节点。//5.如果右子树链表不为空的话，将该链表追加到root节点之后。//6.根据左子树链表是否为空确定返回的节点。 if(pRootOfTree == null)&#123;return null;&#125; if(pRootOfTree.right == null &amp;&amp; pRootOfTree.left == null) &#123;return pRootOfTree;&#125; // 1.将左子树构造成双链表，并返回链表头节点 var left = Convert(pRootOfTree.left); var p =left; // 2.定位至左子树双链表最后一个节点 while(p!=null &amp;&amp; p.right!=null)&#123;p = p.right;&#125; // 3.如果左子树链表不为空的话，将当前pRootOfTree追加到左子树链表 if(left!=null)&#123; p.right = pRootOfTree; pRootOfTree.left = p; &#125; // 4.将右子树构造成双链表，并返回链表头节点 // 5.如果右子树链表不为空的话，将该链表追加到pRootOfTree节点之后 var right = Convert(pRootOfTree.right); if(right)&#123; right.left = pRootOfTree; pRootOfTree.right = right; &#125; //递归函数的返回值 return left!==null?left:pRootOfTree; &#125; module.exports = &#123; Convert : Convert&#125;;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速判断空数组和空对象]]></title>
    <url>%2F2020%2F06%2F03%2F%E5%BF%AB%E9%80%9F%E5%88%A4%E6%96%AD%E7%A9%BA%E6%95%B0%E7%BB%84%E5%92%8C%E7%A9%BA%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[判断空数组1JSON.stringify(data) == "[]" 1arr != false 1arr == false 判断对象1JSON.stringify(data) == "&#123;&#125;" 12Object.prototype.isPrototypeOf(obj) Object.keys(obj).length === 0 1234// 将json对象转化为json字符串，再判断该字符串是否为"&#123;&#125;"var data = &#123;&#125;;var b = (JSON.stringify(data) == "&#123;&#125;");alert(b);//true 123456789// for in 循环判断var obj = &#123;&#125;;var b = function() &#123; for(var key in obj) &#123; return false; &#125; return true;&#125;alert(b());//true 12345// jquery的isEmptyObject方法// 此方法是jquery将(for in)进行封装，使用时需要依赖jqueryvar data = &#123;&#125;;var b = $.isEmptyObject(data);alert(b);//true 1234//Object.getOwnPropertyNames()方法 此方法是使用Object对象的getOwnPropertyNames方法，获取到对象中的属性名，存到一个数组中，返回数组对象，我们可以通过判断数组的length来判断此对象是否为空var data = &#123;&#125;;var arr = Object.getOwnPropertyNames(data);alert(arr.length == 0);//true 1234//使用ES6的Object.keys()方法 与前方法类似，是ES6的新方法, 返回值也是对象中属性名组成的数组var data = &#123;&#125;;var arr = Object.keys(data);alert(arr.length == 0);//true]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[for循环中的变量保存]]></title>
    <url>%2F2019%2F12%2F27%2Ffor%E5%BE%AA%E7%8E%AF%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%E4%BF%9D%E5%AD%98%2F</url>
    <content type="text"><![CDATA[今天的web前端学习打算用for循环给ul下的li标签绑定DOM0级事件，如下 12345&lt;ul&gt; &lt;li&gt;标题1&lt;/li&gt; &lt;li&gt;标题2&lt;/li&gt; &lt;li&gt;标题3&lt;/li&gt;&lt;/ul&gt; 12345678// 获取元素var items = document.getElementsByTagName('li')// for循环绑定事件for(var i = 0, len = items.length; i &lt; len; i++) &#123; items[i].onclick = function () &#123; alert('这是标题' + i) &#125;&#125; 以上的代码不用我解释了把，想实现的效果是点击哪个标题就弹出我点击了标题几。 可是问题出现了,我点击标题1，这时弹出“这是标题3”，我当时就不乐意了啊这明明就是标题1啊！！！ 本着实事求是的精神，我和这短短的几行程序进行了思想上的博弈，真理上的探究，直到我蓝牙鼠标彻底没电。（开个玩笑，凑个字数，23333） 那就查资料看看为啥把，原来这是因为for循环这段程序啊在脚本生成的时候就会执行，导致的结果虽然给每个li标签都绑定了事件，但是i的值却一直保存为循环的最大值也就是3，所以无论你点击标题几它都会弹出“这是标题3”。 我试了下，果然如此呀，既然这样那就想办法保存下来i的值不就好啦。（所以说现在的程序还是不够智能啊，黑人问号脸(lll￢ω￢)）。 1234567891011// 获取元素var items = document.getElementsByTagName('li')// for循环绑定事件for(var i = 0, len = items.length; i &lt; len; i++) &#123; // 函数自执行的方法 (function (i) &#123; items[i].onclick = function () &#123; alert('这是标题' + i) &#125; &#125;)(i)&#125; 这里我是用的匿名函数自执行的办法，使i变量得到保存，原理的话大家自行查阅了。 试一下效果，点击标题1，居然弹出”这时标题0”。emmm，小白就是小白啊，i是从0开始累加的呀，粗心粗心！！！Whatever问题总算是解决了嘛，还是很开心的呀。 在网上查阅了下另外的办法也是可以解决的哦，比如你自定义属性保存嘛，这时最容易想到的啦；还有通过闭包的方法返回并保存i的值；以及用ES6语法中的let代替var关键字等等。 我就不一一试了，宿舍11点半门禁了，我也不写了，哈哈，溜了溜了~~]]></content>
      <tags>
        <tag>前端学习</tag>
        <tag>问题记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[节点新增模块]]></title>
    <url>%2F2019%2F06%2F26%2F%E8%8A%82%E7%82%B9%E6%96%B0%E5%A2%9E%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[1整体介绍节点新增模块按照功能设计主要分为三个模块，对应的三个功能如下 1.1操作流程图节点新增模块在web前端分为三个区域，每个区域的作用如下 待配置节点区域 检索待配置节点 查看待配置节点 已配置节点区域 查看已配置节点 操作区域 配置新增加的节点 修改已配置的节点 由此得到的操作流程图如下 1.2详细部署图 1.3时序图 1.4设计原型 2检索功能模块对于检索功能模块的泳道流程图如下，前端页面设计请参考上方的原型设计，数据交互是通过STOMP协议与RabbitMQ建立webSocket双向连接来实现的 泳道流程图 相关JS代码 建立连接对象（还未发起连接） 1this.socket = new SockJS('http://cn.cquzxy.top:15674/stomp') 获取 STOMP 子协议的客户端对象 1this.stompClient = Stomp.over(this.socket) 向服务器发起websocket连接并发送CONNECT帧 123456789this.stompClient.connect(&#123;'login': 'cqu', 'passcode': '2201'&#125;, frame =&gt; &#123; this.connected = true this.stompClient.subscribe('/exchange/addnode/response', tick =&gt; &#123; var message = JSON.parse(tick.body) &#125;) &#125;, error =&gt; &#123; this.connected = false &#125;) 以上代码中的message即为web前端所需要的Json格式代码{MAC: &#39;XXX&#39;, IP: &#39;XXX&#39;},另外STOMP 客户端要想接收来自服务器推送的消息，必须先订阅相应的URL，即发送一个 SUBSCRIBE 帧，然后才能不断接收来自服务器的推送消息 连接成功后，客户端可使用 send() 方法向服务器发送信息addnode 123var quote = &#123;type: 'addnode'&#125;this.stompClient.subscribe('/exchange/addnode/request', tick =&gt; &#123;&#125;)this.stompClient.send('/exchange/addnode/request', &#123;&#125;, JSON.stringify(quote)) 要停止接收消息，客户机可以对返回的对象使用unsubscribe()方法 1this.stompClient.unsubscribe() 3配置功能模块配置功能模块的主要功能是对新加入的节点进行参数配置，该部分只涉及VueJS和Django之间的交互 泳道流程图 相关JS代码 定义默认的URL 1axios.defaults.baseURL = 'http://192.168.1.10:8000' 创建方法名为POST的http请求 12345678axios.post('/nodes/') .then(response =&gt; &#123; context.commit('nodesConf', response.data) console.log(response) &#125;) .catch(error =&gt; &#123; console.log(error) &#125;) 得到的response.data即为后端返回的JSON格式的已配置节点 4修改功能模块配置功能模块的主要功能是对已有参数的节点进行参数修改，该部分只涉及VueJS和Django之间的交互 在节点显示到修改共有两两次与Django的交互： 加载已配置节点列表——通过axios.get()方法获取JSON数据 修改节点的配置参数——通过axio.patch()方法提交http请求 泳道流程图 相关JS代码 1.通过axios.get()发送http请求以获取储存在后端的已配置节点列表信息 12345678axios.get('/nodes/') .then(response =&gt; &#123; context.commit('retrieveNodesConf', response.data) console.log(response) &#125;) .catch(error =&gt; &#123; console.log(error) &#125;) 得到的response.data即为所需要的JSON格式数据 2.通过axios.patch()发送http请求以修改单个节点的配置信息，例如 1234567891011axios.patch('/nodes/', &#123; positionx: 5, positiony: 5, &#125;) .then(response =&gt; &#123; context.commit('nodesConf', response.data) console.log(response) &#125;) .catch(error =&gt; &#123; console.log(error) &#125;) 以上代码中{positionx: 5, positiony: 5}为修改信息，得到的response.data为修改后的节点的配置信息]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>节点管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web前端设计]]></title>
    <url>%2F2019%2F06%2F26%2Fweb%E5%89%8D%E7%AB%AF%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[1 项目设计的整体设计框架如下 2 web前端设计框架如下 数据在用户、网络前端和后端之间的信息传输过程如下 就网页前端而言，主要问题有以下三方面 组成元素 功能 VueJs 页面UI设计、数据展示设计 HTTP REST API 前端通过HTTP RSTE API与Django交互数据 RabbitMQ 前端通过WebSocket与节点临时数据进行实时交互 因此，前端设计任务会主要围绕以上三个方面进行模块化设计，以达到与信息在用户、前端和后台之间正常传输的整体测试目的 3 web前端框架及相关技术在项目中的应用本部分主要描述了web前端开发中所应用的一些前端技术和在与Django和RabbitMQ交互过程中的实现方法 3.1VueJs框架的使用Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。 官网地址详情：https://cn.vuejs.org/v2/guide/ 全局安装 1npm install --g vue 全局安装vue-cli 1npm install --global vue-cli 创建一个基于webpack模块的新项目 1vue init webpack hlc-project 进行Vue项目的配置 12345678910111213141516171819202122This will install Vue 2.x version of the template.For Vue 1.x use: vue init webpack#1.0 hlc-project? Project name hlc-project? Project description A Vue.js project? Author runoob &lt;test@runoob.com&gt;? Vue build standalone? Use ESLint to lint your code? Yes? Pick an ESLint preset Standard? Setup unit tests with Karma + Mocha? Yes? Setup e2e tests with Nightwatch? Yes vue-cli · Generated &quot;hlc-project&quot;. To get started: cd my-project npm install npm run dev Documentation can be found at https://vuejs-templates.github.io/webpac 3.2vuetify的使用何为vuetify 一个vue ui库，提供vue组件供使用。根据 Google Material Design 指南实现。Vuetify支持SSR(服务端渲染)，SPA(单页应用程序)，PWA(渐进式web应用程序)和标准HTML页面。 官网学习地址：https://vuetifyjs.com/zh-Hans/ 安装vuetify 1vue add vuetify 使用vuetify 1234import Vue from &apos;vue&apos;import Vuetify from &apos;vuetify&apos;Vue.use(Vuetify) 3.2 与Django REST的交互——axiosDjango REST框架是一个用于构建Web api的强大而灵活的工具包。Web可浏览API对于开发人员来说是一个巨大的可用性胜利，它可用于身份验证策略，包括OAuth1a和OAuth2的包，还支持ORM和非ORM数据源的序列化。 Django REST framework的官网学习地址在这里：https://www.django-rest-framework.org/ 3.2.1何为axiosAxios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中 它的特点如下： 从浏览器中创建 XMLHttpRequests 从 node.js 创建 http 请求 支持 Promise API 拦截请求和响应 转换请求数据和响应数据 取消请求 自动转换 JSON 数据 客户端支持防御 XSRF axios中文官网学习地址：https://www.kancloud.cn/yunye/axios/234845 3.2.2安装和使用axios这里我是用的是npm进行安装 1$ npm install axios 然后在Vue中的vuex（或者是store.js）中引入 1import axios from 'axios' 通过向 axios 传递相关配置来创建请求 axios(config)123456789// 发送 POST 请求axios(&#123; method: 'post', url: '/user/12345', data: &#123; firstName: 'Fred', lastName: 'Flintstone' &#125;&#125;); axios(url[, config]) 12// 发送 GET 请求（默认的方法）axios('/user/12345') 为方便起见，为所有支持的请求方法提供了别名： axios.request(config) axios.get(url[, config]) axios.delete(url[, config]) axios.head(url[, config]) axios.post(url[, data[, config]]) axios.put(url[, data[, config]]) axios.patch(url[, data[, config]]) 在使用别名方法时， url、method、data 这些属性都不必在配置中指定。通过以上方法的使用我们基本可以实现与Django之间的交互，对数据库的数据进行增删查改功能的操作。详情请参考上方的官网进行学习和使用。 3.3与RabbitMQ的交互——SockJS和Stomp3.3.1安装和使用SockJSSockJS是一个浏览器JavaScript库，它提供了一个类似websocket的对象。SockJS提供了一个连贯的、跨浏览器的Javascript API，它在浏览器和web服务器之间创建了一个低延迟、全双工、跨域的通信通道。 SockJS首先尝试使用本地WebSockets。如果失败，它可以使用各种特定于浏览器的传输协议，并通过类似websocket的抽象来表示它们。 SockJS适用于所有现代浏览器和不支持WebSocket协议的环境——例如，在受限的企业代理之后。 SockJS-client 的使用原则： API应该尽可能地遵循HTML5 Websockets API。 所有传输都必须支持开箱即用的跨域连接。这是可能的，并建议在不同于您的主网站的服务器上托管SockJS服务器。 每个主流浏览器至少支持一种流协议。 流传输应该跨域工作，并且应该支持cookie(用于基于cookie的粘性会话)。 轮询传输被用作限制代理背后的旧浏览器和主机的备份。 连接的建立应该是快速和轻量级的。 内部没有Flash(不需要打开端口843 -它不通过代理工作，不需要主机的“crossdomain.xml“，不需要等待3秒来检测问题) 这里我是用的是npm进行安装 1npm install sockjs-client 在然后在Vue中的vuex（或者是store.js）中引入 1import SockJS from 'sockjs-client' 之后就可以在&lt;script&gt;中建立与SockJS服务器之间的连接，例如 1this.socket = new SockJS('http://cn.cquzxy.top:15674/stomp') 详细使用参考：https://www.npmjs.com/package/sockjs-client 3.3.2安装和使用stompjs什么是stomp?STOMP是一个简单的面向文本的消息传递协议。它定义了一个可互操作的线路格式，以便任何可用的STOMP客户机都可以与任何STOMP消息代理通信，以提供简单和语言和平台之间广泛的消息互操作性STOMP web站点有一个STOMP客户机和服务器实现的列表。 什么是WebSocket API?WebSockets是“用于Web的TCP”。 WebSocket API使web应用程序能够以一种直接的方式处理与服务器端进程的双向通信。开发人员一直在使用XMLHttpRequest(“XHR”)来实现这一目的，但是XHR使开发来回与服务器通信的web应用程序变得不必要地复杂。XHR基本上是异步HTTP，由于需要使用诸如长挂GET之类的复杂技术将数据从服务器发送到浏览器，所以简单的任务很快就会变得复杂。与XMLHttpRequest相反，WebSockets在浏览器中提供了一个真正的双向通信通道。获得WebSocket连接后，可以通过调用send()方法将数据从浏览器发送到服务器，并通过onmessage事件处理程序将数据从服务器接收到浏览器。 除了新的WebSocket API之外，还有一个浏览器用来与服务器通信的新协议(“WebSocket协议”)。该协议不是原始TCP，因为它需要提供浏览器的“同源”安全模型。它也不是HTTP，因为WebSocket流量与HTTP的请求-响应模型不同。使用新的WebSocket协议的WebSocket通信应该使用更少的带宽，因为与一系列的XHR和挂起GET不同，一旦建立了单个连接，就不会交换头信息。要使用这个新的API和协议，并利用更简单的编程模型和更高效的网络流量，确实需要一个新的服务器实现来进行通信。 这里我是用的是npm进行安装 1npm install stompjs 在然后在Vue中的vuex（或者是store.js）中引入 1import Stomp from 'stompjs' 使用SockJS项目提供的使用方式如下，它可以使用多种特定于浏览器的传输协议 12var ws = new SockJS(url);var client = Stomp.over(ws); connect()方法接受不同数量的参数，以提供一个在大多数情况下都可以使用的简单API client.connect(login, passcode, connectCallback)client.connect(login, passcode, connectCallback, errorCallback)client.connect(login, passcode, connectCallback, errorCallback, host) 要断开客户机与服务器的连接，可以调用它的disconnect()方法。断开是异步的:要在断开有效时得到通知，断开方法接受一个可选的回调参数。 client.disconnect(function() {alert(&quot;See you next time!&quot;);} 当客户机连接到服务器时，它可以使用send()方法发送STOMP消息。该方法接受与STOMP目的地对应的强制目的地参数。它还接受两个可选参数:header，一个JavaScript对象，包含额外的消息header和一个String对象。 1client.send("/queue/test", &#123;priority: 9&#125;, "Hello, STOMP"); 您可以使用subscribe()方法订阅目的地。该方法接受两个强制参数:destination，一个对应于destination和回调的字符串，一个带有一个消息参数的函数和一个可选参数标头，一个用于附加标头的JavaScript对象。 1var subscription = client.subscribe("/queue/test", callback); 要停止接收消息，客户机可以对subscribe()方法返回的对象使用unsubscribe()方法。例如 123var subscription = client.subscribe(...); ... subscription.unsubscribe(); STOMP消息的主体必须是一个字符串。如果希望发送和接收JSON对象，可以使用JSON.stringify()和JSON.parse()将JSON对象转换为字符串，反之亦然。 1234567var quote = &#123;symbol: 'APPL', value: 195.46&#125;;client.send("/topic/stocks", &#123;&#125;, JSON.stringify(quote));client.subcribe("/topic/stocks", function(message) &#123; var quote = JSON.parse(message.body); alert(quote.symbol + " is at " + quote.value);&#125;; 关于stompjs的详细学习地址：http://jmesnil.net/stomp-websocket/doc/]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>整体设计</tag>
        <tag>主要框架和工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[节点管理模块]]></title>
    <url>%2F2019%2F06%2F14%2F%E8%8A%82%E7%82%B9%E7%AE%A1%E7%90%86%E7%94%A8%E6%88%B7%E9%9C%80%E6%B1%82%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[1用户需求分析1用户对象管理员 2节点管理模块整体流程图 文章参考：用户需求分析整体流程图 2产品原型设计1节点配置1新增节点管理1节点添加授权功能设计 基本目标功能 实现形式 检测新增节点 检测新增节点按钮 了解待检测节点信息 添加待检测节点信息表 节点授权 授权按钮 节点不授权 不授权按钮 查看节点新增信息 添加节点授权新增信息表 2节点新增用例逻辑框图12345678910111213@startumlstartwhile (检测节点是否加入?) is (yes) :浏览节点信息; :选择待加入节点; :添加新节点信息; :增添; while (继续增添节点?) is (no) stop endwhile (yes)endwhile (no)stop@enduml 3节点授权界面原型设计2节点配置信息查看1节点配置信息查看功能设计 基本目标功能 实现形式 查看系统已有的节点 添加已有节点信息列表 查看各个节点对应的详细信息 点击节点弹出详情2. 2节点配置信息查看界面原型设计2节点调试1节点在线可视化1节点在线情况功能设计 基本目标功能 实现形式 查看所有节点的在线情况 节点在线矩阵图 2节点在线情况界面原型设计###3节点信息查看 1节点工作队列查看功能设计 基本实现功能 实现形式 查看节点的工作队列 添加每个节点的对列表 2节点工作队列界面原型设计#### 4节点网络负载1节点网络负载界面功能设计 基本实现功能 实现形式 查看节点网络负载 各个节点的负载图、整个网络的负载图 2节点网络负载界面用例逻辑框图1234567891011121314151617181920@startumlstartif(测试场景是否存在?) then (no) stopelse (yes) :选择测试场景; if(是否查看总的网络负载?) then (yes) :选择数据状态; :查看总的节点工作状态图; elseif(查看节点队列) then (yes) :输入节点编号; :查看节点队列状态和数据速率; elseif(查看单个节点的网络负载) then (yes) :输入节点编号; :查看单个节点工作状态图; else (nothing) endif stop @enduml 3节点网络负载界面原型设计5节点工作状态1节点工作状态界面功能设计 基本实现功能 实现形式 查看节点工作状态 各个节点目前工作状态的信息显示 2节点工作状态用例逻辑框图1234567891011121314151617 @startumlstartif(测试场景是否存在?) then (no) stopelse (yes) : 选择测试场景;while(测试场景下是否有节点 ? ) is (yes) :选择工作节点; :查看工作状态; if(继续查看?) then (no) stop else(yes) endifendwhile (no) stop @enduml 3节点工作状态查看界面原型设计3前端代码的实现]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>节点管理</tag>
        <tag>UI设计</tag>
        <tag>需求分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue和Django之间的数据交互]]></title>
    <url>%2F2019%2F06%2F04%2FDjango%E5%92%8CVue%2F</url>
    <content type="text"><![CDATA[使用 axios 访问 API我们有很多种方式可以从 API 请求信息，但是最好首先确认这些数据看起来长什么样，以便进一步确定如何展示它。为此，我们会调用一次这个 API 并输出结果，以便我们能够看清楚它。比如创建一个 data 里的属性以最终放置信息，然后将会在 mounted 生命周期钩子中获取数据并赋值过去： 12345678910111213new Vue(&#123; el: '#app', data () &#123; return &#123; info: null &#125; &#125;, mounted () &#123; axios .get('https://api.coindesk.com/v1/bpi/currentprice.json') .then(response =&gt; (this.info = response)) &#125;&#125;) 123&lt;div id="app"&gt; &#123;&#123; info &#125;&#125;&lt;/div&gt; 但是我们得到的数据往往是这样的 1&#123; "data": &#123; "time": &#123; "updated": "Jun 4, 2019 13:24:00 UTC", "updatedISO": "2019-06-04T13:24:00+00:00", "updateduk": "Jun 4, 2019 at 14:24 BST" &#125;, "disclaimer": "This data was produced from the CoinDesk Bitcoin Price Index (USD). Non-USD currency data converted using hourly conversion rate from openexchangerates.org", "chartName": "Bitcoin", "bpi": &#123; "USD": &#123; "code": "USD", "symbol": "&amp;#36;", "rate": "7,989.8900", "description": "United States Dollar", "rate_float": 7989.89 &#125;, "GBP": &#123; "code": "GBP", "symbol": "&amp;pound;", "rate": "6,299.7246", "description": "British Pound Sterling", "rate_float": 6299.7246 &#125;, "EUR": &#123; "code": "EUR", "symbol": "&amp;euro;", "rate": "7,111.7452", "description": "Euro", "rate_float": 7111.7452 &#125; &#125; &#125;, "status": 200, "statusText": "", "headers": &#123; "content-type": "application/javascript", "cache-control": "max-age=15", "expires": "Tue, 04 Jun 2019 13:25:07 UTC" &#125;, "config": &#123; "transformRequest": &#123;&#125;, "transformResponse": &#123;&#125;, "timeout": 0, "xsrfCookieName": "XSRF-TOKEN", "xsrfHeaderName": "X-XSRF-TOKEN", "maxContentLength": -1, "headers": &#123; "Accept": "application/json, text/plain, */*" &#125;, "method": "get", "url": "https://api.coindesk.com/v1/bpi/currentprice.json" &#125;, "request": &#123;&#125; &#125; 我们已经得到了一些数据。但是它看起来还比较乱，所以我们会更好的展示它并添加一些错误处理，以防出现异常情况或请求超时。 vue-axios安装vue-axios1npm install --save axios vue-axios 引入12345import Vue from 'vue'import axios from 'axios'import VueAxios from 'vue-axios' Vue.use(VueAxios, axios) 使用我们可以以如下三种方式在项目中引入vue-axios1234567891011Vue.axios.get(api).then((response) =&gt; &#123; console.log(response.data)&#125;) this.axios.get(api).then((response) =&gt; &#123; console.log(response.data)&#125;) this.$http.get(api).then((response) =&gt; &#123; console.log(response.data)&#125;) 错误处理很多时候我们可能并没有从 API 获取想要的数据。这可能是由于很多种因素引起的，比如 axios 调用可能由于多种原因而失败，包括但不限于： API 不工作了； 请求发错了； API 没有按我们预期的格式返回信息。 当发送这个请求的时候，我们应该检查一下这些情况，并在所有情况下都返回相应的信息以便处理这些问题。在 axios 中，我们会通过使用 catch 来做这件事。 1.catch(error =&gt; console.log(error)) 项目应用本项目中的应用示例： 12345678910retrieveNodes (context) &#123; axios.get('/nodes/') .then(response =&gt; &#123; context.commit('retrieveNodes', response.data.results) console.log(response.data.results) &#125;) .catch(error =&gt; &#123; console.log(error) &#125;) &#125; 可以得到如下json格式的数据 123456789101112131415161718192021222324252627282930[ &#123; "node_id": 1, "ip": "127.0.0.1", "mac_addr": "07-16-76-00-02-86", "node_status": "ON", "wk_status": "IDLE" &#125;, &#123; "node_id": 2, "ip": "127.0.0.2", "mac_addr": "07-16-76-00-02-87", "node_status": "ON", "wk_status": "IDLE" &#125;, &#123; "node_id": 3, "ip": "127.0.0.3", "mac_addr": "07-16-76-00-02-88", "node_status": "OFF", "wk_status": "IDLE" &#125;, &#123; "node_id": 4, "ip": "127.0.0.3", "mac_addr": "07-16-76-00-02-88", "node_status": "OFF", "wk_status": "IDLE" &#125;] 参考资料使用axio访问api]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>项目设计</tag>
        <tag>节点管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网页前端基本功能的设计]]></title>
    <url>%2F2019%2F05%2F28%2F%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%E7%9A%84%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[Page 1：场景选择根据测试地区的不同，显示不同的节点布局。 可选场景有：Expressway/Primary Highway/Secondary Road/Tertiary Highway/Four-stage Highway，场景选择用传递到后端，主要用于前端限制参数配置可选范围。 Page 2 （节点管理页面）：节点的实时管理节点管理页面主要功能： 展示节点实时的状态信息 用于选择节点安排任务 节点的选择包括：1）选择任务使用的节点 2）选择节点类型——通信环境节点/测试用例节点，用于限制配置参数 不同状态节点（如，处于接收/发送状态，在线状态）应该用不同的颜色/样式表示 Page 3 （任务配置页面）：节点的配置 节点的选择与配置应该可以单个配置也可以批量配置 12345678910111213141516171819202122232425262728//节点的json格式：(所有50个节点)&#123; &quot;nodes&quot;:[ &#123; &quot;id&quot;:1, &quot;nodeState&quot;:&#123; &quot;node_status&quot;:&quot;offline/online&quot;, &quot;w_status&quot;:&quot;idling/pending/waiting/running/finishing/completed&quot;, &quot;tr_status&quot;: &quot;Tx/Rx&quot;, &quot;node_message&quot;:&quot;This is an example message.&quot;, &#125;, &quot;node_config&quot;:&#123; &quot;tr_status&quot;:&quot;Tx/Rx&quot;， &quot;radio&quot;:&quot;1/2&quot;, &quot;Power&quot;:-127 ～ 128, &quot;dataRate&quot;:&quot;R6Mbps12BPSK&quot;, &quot;channel&quot;:&quot;172/174/176/178/180/182/184&quot;, &quot;destMacAddr&quot;:&quot;(e.g.)00-23-5A-15-99-42&quot;, &quot;psid&quot;:0 ～ 0xFFFFFFFF, &quot;payload&quot;:&quot;(e.g.)This is a test payload.&quot;, &quot;payloadLength&quot;:(e.g.)23, &quot;periodic&quot;:true/false, &quot;repeatTimes&quot;:10, &quot;repeatRate&quot;:100, &#125;, &#125;, ... ]&#125; params 描述 tr_status 收发状态 radio 选择工作的Radio Power 发送/接收功率 dataRate 发送速率 channel 发送/接收信道 destMacAddr 目的MAC地址 psid 标识服务类型 payload 负载内容 payloadLength 负载长度 如果不对节点进行配置，则使用节点的默认配置信息（根据场景&amp;节点类型的选择，前端生成默认配置信息显示在节点配置页面）; 当勾选的场景，节点类型或者收发状态不同，返回的参数默认配置会不同，并且可配置的参数不同（不可配置参数禁选）; 配置完成后即生成了一个任务，若需要配置多个任务，则重复2-3步骤。 Page 4（任务页面）：生成任务配置信息、实时显示画面等 展示任务详情:包括任务实时状态以及任务相馆配置; 在此页面可以对任务进行管理（改变优先级，任务执行时间，删除，中止/暂停/重启等） 任务属性 任务属性描述 url ‘/tasks/‘ method GET data JSON(如下所示) params taskID:任务编号currentState:taskStatus:任务状态tx_statistics:整体发包数量rx_statistics:整体收包数量net_PDL:网络丢包率net_delay:网络平均时延config:(见1.4.2PARAM表) 123456789101112131415Tasks: [ &#123; taskID: 1, scence: &apos;&apos;, currentState: &#123; taskStatus: &apos;pending/waiting/running/finishing/completed&apos;, tx_statistics: 1000, rx_statistics: 800, net_PDL: 0.4, net_delay: &apos;2ms&apos; &#125;, config: &#123; &#125; &#125;]]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>项目设计</tag>
        <tag>流程安排</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VueJs框架]]></title>
    <url>%2F2019%2F05%2F28%2Ffront-end-UI%2F</url>
    <content type="text"><![CDATA[本部分主要利用了HTML、CSS和Javascript等知识，借助Vue2.0热门框架进行Web前后端分离的前端的开发工作。 VueJs框架的使用Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。 官网地址详情：https://cn.vuejs.org/v2/guide/ 全局安装 1npm install --g vue 全局安装vue-cli 1npm install --global vue-cli 创建一个基于webpack模块的新项目 1vue init webpack hlc-project 进行Vue项目的配置 12345678910111213141516171819202122This will install Vue 2.x version of the template.For Vue 1.x use: vue init webpack#1.0 hlc-project? Project name hlc-project? Project description A Vue.js project? Author runoob &lt;test@runoob.com&gt;? Vue build standalone? Use ESLint to lint your code? Yes? Pick an ESLint preset Standard? Setup unit tests with Karma + Mocha? Yes? Setup e2e tests with Nightwatch? Yes vue-cli · Generated &quot;hlc-project&quot;. To get started: cd my-project npm install npm run dev Documentation can be found at https://vuejs-templates.github.io/webpac vuetify的使用何为vuetify 一个vue ui库，提供vue组件供使用。根据 Google Material Design 指南实现。Vuetify支持SSR(服务端渲染)，SPA(单页应用程序)，PWA(渐进式web应用程序)和标准HTML页面。 安装vuetify 1vue add vuetify 使用vuetify 1234import Vue from &apos;vue&apos;import Vuetify from &apos;vuetify&apos;Vue.use(Vuetify)]]></content>
      <categories>
        <category>web前端技术学习</category>
      </categories>
      <tags>
        <tag>web前端工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端设计方案]]></title>
    <url>%2F2019%2F05%2F27%2Ffront-to-end%2F</url>
    <content type="text"><![CDATA[VueJs+WebSocket+HTTP REST API ​ 数据在用户、网络前端和后端之间的信息传输过程如下 就网页前端而言，主要问题有以下三方面 组成元素 功能 VueJs 页面UI设计、数据展示设计 HTTP REST API 前端通过HTTP RSTE API与Django交互数据 RabbitMQ 前端通过WebSocket与节点临时数据进行实时交互 因此，前端设计任务会主要围绕以上三个方面进行模块化设计，以达到与信息在用户、前端和后台之间正常传输的整体测试目的]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>项目设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F05%2F26%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>

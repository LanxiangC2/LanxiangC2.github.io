<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[快速判断空数组和空对象]]></title>
    <url>%2F2020%2F06%2F03%2F%E5%BF%AB%E9%80%9F%E5%88%A4%E6%96%AD%E7%A9%BA%E6%95%B0%E7%BB%84%E5%92%8C%E7%A9%BA%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[判断空数组1JSON.stringify(data) == "[]" 1arr != false 1arr == false 判断对象1JSON.stringify(data) == "&#123;&#125;" 12Object.prototype.isPrototypeOf(obj) Object.keys(obj).length === 0 1234// 将json对象转化为json字符串，再判断该字符串是否为"&#123;&#125;"var data = &#123;&#125;;var b = (JSON.stringify(data) == "&#123;&#125;");alert(b);//true 123456789// for in 循环判断var obj = &#123;&#125;;var b = function() &#123; for(var key in obj) &#123; return false; &#125; return true;&#125;alert(b());//true 12345// jquery的isEmptyObject方法// 此方法是jquery将(for in)进行封装，使用时需要依赖jqueryvar data = &#123;&#125;;var b = $.isEmptyObject(data);alert(b);//true 1234//Object.getOwnPropertyNames()方法 此方法是使用Object对象的getOwnPropertyNames方法，获取到对象中的属性名，存到一个数组中，返回数组对象，我们可以通过判断数组的length来判断此对象是否为空var data = &#123;&#125;;var arr = Object.getOwnPropertyNames(data);alert(arr.length == 0);//true 1234//使用ES6的Object.keys()方法 与前方法类似，是ES6的新方法, 返回值也是对象中属性名组成的数组var data = &#123;&#125;;var arr = Object.keys(data);alert(arr.length == 0);//true]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[for循环中的变量保存]]></title>
    <url>%2F2019%2F12%2F27%2Ffor%E5%BE%AA%E7%8E%AF%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%E4%BF%9D%E5%AD%98%2F</url>
    <content type="text"><![CDATA[今天的web前端学习打算用for循环给ul下的li标签绑定DOM0级事件，如下 12345&lt;ul&gt; &lt;li&gt;标题1&lt;/li&gt; &lt;li&gt;标题2&lt;/li&gt; &lt;li&gt;标题3&lt;/li&gt;&lt;/ul&gt; 12345678// 获取元素var items = document.getElementsByTagName('li')// for循环绑定事件for(var i = 0, len = items.length; i &lt; len; i++) &#123; items[i].onclick = function () &#123; alert('这是标题' + i) &#125;&#125; 以上的代码不用我解释了把，想实现的效果是点击哪个标题就弹出我点击了标题几。 可是问题出现了,我点击标题1，这时弹出“这是标题3”，我当时就不乐意了啊这明明就是标题1啊！！！ 本着实事求是的精神，我和这短短的几行程序进行了思想上的博弈，真理上的探究，直到我蓝牙鼠标彻底没电。（开个玩笑，凑个字数，23333） 那就查资料看看为啥把，原来这是因为for循环这段程序啊在脚本生成的时候就会执行，导致的结果虽然给每个li标签都绑定了事件，但是i的值却一直保存为循环的最大值也就是3，所以无论你点击标题几它都会弹出“这是标题3”。 我试了下，果然如此呀，既然这样那就想办法保存下来i的值不就好啦。（所以说现在的程序还是不够智能啊，黑人问号脸(lll￢ω￢)）。 1234567891011// 获取元素var items = document.getElementsByTagName('li')// for循环绑定事件for(var i = 0, len = items.length; i &lt; len; i++) &#123; // 函数自执行的方法 (function (i) &#123; items[i].onclick = function () &#123; alert('这是标题' + i) &#125; &#125;)(i)&#125; 这里我是用的匿名函数自执行的办法，使i变量得到保存，原理的话大家自行查阅了。 试一下效果，点击标题1，居然弹出”这时标题0”。emmm，小白就是小白啊，i是从0开始累加的呀，粗心粗心！！！Whatever问题总算是解决了嘛，还是很开心的呀。 在网上查阅了下另外的办法也是可以解决的哦，比如你自定义属性保存嘛，这时最容易想到的啦；还有通过闭包的方法返回并保存i的值；以及用ES6语法中的let代替var关键字等等。 我就不一一试了，宿舍11点半门禁了，我也不写了，哈哈，溜了溜了~~]]></content>
      <tags>
        <tag>前端学习</tag>
        <tag>问题记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[节点新增模块]]></title>
    <url>%2F2019%2F06%2F26%2F%E8%8A%82%E7%82%B9%E6%96%B0%E5%A2%9E%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[1整体介绍节点新增模块按照功能设计主要分为三个模块，对应的三个功能如下 1.1操作流程图节点新增模块在web前端分为三个区域，每个区域的作用如下 待配置节点区域 检索待配置节点 查看待配置节点 已配置节点区域 查看已配置节点 操作区域 配置新增加的节点 修改已配置的节点 由此得到的操作流程图如下 1.2详细部署图 1.3时序图 1.4设计原型 2检索功能模块对于检索功能模块的泳道流程图如下，前端页面设计请参考上方的原型设计，数据交互是通过STOMP协议与RabbitMQ建立webSocket双向连接来实现的 泳道流程图 相关JS代码 建立连接对象（还未发起连接） 1this.socket = new SockJS('http://cn.cquzxy.top:15674/stomp') 获取 STOMP 子协议的客户端对象 1this.stompClient = Stomp.over(this.socket) 向服务器发起websocket连接并发送CONNECT帧 123456789this.stompClient.connect(&#123;'login': 'cqu', 'passcode': '2201'&#125;, frame =&gt; &#123; this.connected = true this.stompClient.subscribe('/exchange/addnode/response', tick =&gt; &#123; var message = JSON.parse(tick.body) &#125;) &#125;, error =&gt; &#123; this.connected = false &#125;) 以上代码中的message即为web前端所需要的Json格式代码{MAC: &#39;XXX&#39;, IP: &#39;XXX&#39;},另外STOMP 客户端要想接收来自服务器推送的消息，必须先订阅相应的URL，即发送一个 SUBSCRIBE 帧，然后才能不断接收来自服务器的推送消息 连接成功后，客户端可使用 send() 方法向服务器发送信息addnode 123var quote = &#123;type: 'addnode'&#125;this.stompClient.subscribe('/exchange/addnode/request', tick =&gt; &#123;&#125;)this.stompClient.send('/exchange/addnode/request', &#123;&#125;, JSON.stringify(quote)) 要停止接收消息，客户机可以对返回的对象使用unsubscribe()方法 1this.stompClient.unsubscribe() 3配置功能模块配置功能模块的主要功能是对新加入的节点进行参数配置，该部分只涉及VueJS和Django之间的交互 泳道流程图 相关JS代码 定义默认的URL 1axios.defaults.baseURL = 'http://192.168.1.10:8000' 创建方法名为POST的http请求 12345678axios.post('/nodes/') .then(response =&gt; &#123; context.commit('nodesConf', response.data) console.log(response) &#125;) .catch(error =&gt; &#123; console.log(error) &#125;) 得到的response.data即为后端返回的JSON格式的已配置节点 4修改功能模块配置功能模块的主要功能是对已有参数的节点进行参数修改，该部分只涉及VueJS和Django之间的交互 在节点显示到修改共有两两次与Django的交互： 加载已配置节点列表——通过axios.get()方法获取JSON数据 修改节点的配置参数——通过axio.patch()方法提交http请求 泳道流程图 相关JS代码 1.通过axios.get()发送http请求以获取储存在后端的已配置节点列表信息 12345678axios.get('/nodes/') .then(response =&gt; &#123; context.commit('retrieveNodesConf', response.data) console.log(response) &#125;) .catch(error =&gt; &#123; console.log(error) &#125;) 得到的response.data即为所需要的JSON格式数据 2.通过axios.patch()发送http请求以修改单个节点的配置信息，例如 1234567891011axios.patch('/nodes/', &#123; positionx: 5, positiony: 5, &#125;) .then(response =&gt; &#123; context.commit('nodesConf', response.data) console.log(response) &#125;) .catch(error =&gt; &#123; console.log(error) &#125;) 以上代码中{positionx: 5, positiony: 5}为修改信息，得到的response.data为修改后的节点的配置信息]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>节点管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web前端设计]]></title>
    <url>%2F2019%2F06%2F26%2Fweb%E5%89%8D%E7%AB%AF%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[1 项目设计的整体设计框架如下 2 web前端设计框架如下 数据在用户、网络前端和后端之间的信息传输过程如下 就网页前端而言，主要问题有以下三方面 组成元素 功能 VueJs 页面UI设计、数据展示设计 HTTP REST API 前端通过HTTP RSTE API与Django交互数据 RabbitMQ 前端通过WebSocket与节点临时数据进行实时交互 因此，前端设计任务会主要围绕以上三个方面进行模块化设计，以达到与信息在用户、前端和后台之间正常传输的整体测试目的 3 web前端框架及相关技术在项目中的应用本部分主要描述了web前端开发中所应用的一些前端技术和在与Django和RabbitMQ交互过程中的实现方法 3.1VueJs框架的使用Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。 官网地址详情：https://cn.vuejs.org/v2/guide/ 全局安装 1npm install --g vue 全局安装vue-cli 1npm install --global vue-cli 创建一个基于webpack模块的新项目 1vue init webpack hlc-project 进行Vue项目的配置 12345678910111213141516171819202122This will install Vue 2.x version of the template.For Vue 1.x use: vue init webpack#1.0 hlc-project? Project name hlc-project? Project description A Vue.js project? Author runoob &lt;test@runoob.com&gt;? Vue build standalone? Use ESLint to lint your code? Yes? Pick an ESLint preset Standard? Setup unit tests with Karma + Mocha? Yes? Setup e2e tests with Nightwatch? Yes vue-cli · Generated &quot;hlc-project&quot;. To get started: cd my-project npm install npm run dev Documentation can be found at https://vuejs-templates.github.io/webpac 3.2vuetify的使用何为vuetify 一个vue ui库，提供vue组件供使用。根据 Google Material Design 指南实现。Vuetify支持SSR(服务端渲染)，SPA(单页应用程序)，PWA(渐进式web应用程序)和标准HTML页面。 官网学习地址：https://vuetifyjs.com/zh-Hans/ 安装vuetify 1vue add vuetify 使用vuetify 1234import Vue from &apos;vue&apos;import Vuetify from &apos;vuetify&apos;Vue.use(Vuetify) 3.2 与Django REST的交互——axiosDjango REST框架是一个用于构建Web api的强大而灵活的工具包。Web可浏览API对于开发人员来说是一个巨大的可用性胜利，它可用于身份验证策略，包括OAuth1a和OAuth2的包，还支持ORM和非ORM数据源的序列化。 Django REST framework的官网学习地址在这里：https://www.django-rest-framework.org/ 3.2.1何为axiosAxios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中 它的特点如下： 从浏览器中创建 XMLHttpRequests 从 node.js 创建 http 请求 支持 Promise API 拦截请求和响应 转换请求数据和响应数据 取消请求 自动转换 JSON 数据 客户端支持防御 XSRF axios中文官网学习地址：https://www.kancloud.cn/yunye/axios/234845 3.2.2安装和使用axios这里我是用的是npm进行安装 1$ npm install axios 然后在Vue中的vuex（或者是store.js）中引入 1import axios from 'axios' 通过向 axios 传递相关配置来创建请求 axios(config)123456789// 发送 POST 请求axios(&#123; method: 'post', url: '/user/12345', data: &#123; firstName: 'Fred', lastName: 'Flintstone' &#125;&#125;); axios(url[, config]) 12// 发送 GET 请求（默认的方法）axios('/user/12345') 为方便起见，为所有支持的请求方法提供了别名： axios.request(config) axios.get(url[, config]) axios.delete(url[, config]) axios.head(url[, config]) axios.post(url[, data[, config]]) axios.put(url[, data[, config]]) axios.patch(url[, data[, config]]) 在使用别名方法时， url、method、data 这些属性都不必在配置中指定。通过以上方法的使用我们基本可以实现与Django之间的交互，对数据库的数据进行增删查改功能的操作。详情请参考上方的官网进行学习和使用。 3.3与RabbitMQ的交互——SockJS和Stomp3.3.1安装和使用SockJSSockJS是一个浏览器JavaScript库，它提供了一个类似websocket的对象。SockJS提供了一个连贯的、跨浏览器的Javascript API，它在浏览器和web服务器之间创建了一个低延迟、全双工、跨域的通信通道。 SockJS首先尝试使用本地WebSockets。如果失败，它可以使用各种特定于浏览器的传输协议，并通过类似websocket的抽象来表示它们。 SockJS适用于所有现代浏览器和不支持WebSocket协议的环境——例如，在受限的企业代理之后。 SockJS-client 的使用原则： API应该尽可能地遵循HTML5 Websockets API。 所有传输都必须支持开箱即用的跨域连接。这是可能的，并建议在不同于您的主网站的服务器上托管SockJS服务器。 每个主流浏览器至少支持一种流协议。 流传输应该跨域工作，并且应该支持cookie(用于基于cookie的粘性会话)。 轮询传输被用作限制代理背后的旧浏览器和主机的备份。 连接的建立应该是快速和轻量级的。 内部没有Flash(不需要打开端口843 -它不通过代理工作，不需要主机的“crossdomain.xml“，不需要等待3秒来检测问题) 这里我是用的是npm进行安装 1npm install sockjs-client 在然后在Vue中的vuex（或者是store.js）中引入 1import SockJS from 'sockjs-client' 之后就可以在&lt;script&gt;中建立与SockJS服务器之间的连接，例如 1this.socket = new SockJS('http://cn.cquzxy.top:15674/stomp') 详细使用参考：https://www.npmjs.com/package/sockjs-client 3.3.2安装和使用stompjs什么是stomp?STOMP是一个简单的面向文本的消息传递协议。它定义了一个可互操作的线路格式，以便任何可用的STOMP客户机都可以与任何STOMP消息代理通信，以提供简单和语言和平台之间广泛的消息互操作性STOMP web站点有一个STOMP客户机和服务器实现的列表。 什么是WebSocket API?WebSockets是“用于Web的TCP”。 WebSocket API使web应用程序能够以一种直接的方式处理与服务器端进程的双向通信。开发人员一直在使用XMLHttpRequest(“XHR”)来实现这一目的，但是XHR使开发来回与服务器通信的web应用程序变得不必要地复杂。XHR基本上是异步HTTP，由于需要使用诸如长挂GET之类的复杂技术将数据从服务器发送到浏览器，所以简单的任务很快就会变得复杂。与XMLHttpRequest相反，WebSockets在浏览器中提供了一个真正的双向通信通道。获得WebSocket连接后，可以通过调用send()方法将数据从浏览器发送到服务器，并通过onmessage事件处理程序将数据从服务器接收到浏览器。 除了新的WebSocket API之外，还有一个浏览器用来与服务器通信的新协议(“WebSocket协议”)。该协议不是原始TCP，因为它需要提供浏览器的“同源”安全模型。它也不是HTTP，因为WebSocket流量与HTTP的请求-响应模型不同。使用新的WebSocket协议的WebSocket通信应该使用更少的带宽，因为与一系列的XHR和挂起GET不同，一旦建立了单个连接，就不会交换头信息。要使用这个新的API和协议，并利用更简单的编程模型和更高效的网络流量，确实需要一个新的服务器实现来进行通信。 这里我是用的是npm进行安装 1npm install stompjs 在然后在Vue中的vuex（或者是store.js）中引入 1import Stomp from 'stompjs' 使用SockJS项目提供的使用方式如下，它可以使用多种特定于浏览器的传输协议 12var ws = new SockJS(url);var client = Stomp.over(ws); connect()方法接受不同数量的参数，以提供一个在大多数情况下都可以使用的简单API client.connect(login, passcode, connectCallback)client.connect(login, passcode, connectCallback, errorCallback)client.connect(login, passcode, connectCallback, errorCallback, host) 要断开客户机与服务器的连接，可以调用它的disconnect()方法。断开是异步的:要在断开有效时得到通知，断开方法接受一个可选的回调参数。 client.disconnect(function() {alert(&quot;See you next time!&quot;);} 当客户机连接到服务器时，它可以使用send()方法发送STOMP消息。该方法接受与STOMP目的地对应的强制目的地参数。它还接受两个可选参数:header，一个JavaScript对象，包含额外的消息header和一个String对象。 1client.send("/queue/test", &#123;priority: 9&#125;, "Hello, STOMP"); 您可以使用subscribe()方法订阅目的地。该方法接受两个强制参数:destination，一个对应于destination和回调的字符串，一个带有一个消息参数的函数和一个可选参数标头，一个用于附加标头的JavaScript对象。 1var subscription = client.subscribe("/queue/test", callback); 要停止接收消息，客户机可以对subscribe()方法返回的对象使用unsubscribe()方法。例如 123var subscription = client.subscribe(...); ... subscription.unsubscribe(); STOMP消息的主体必须是一个字符串。如果希望发送和接收JSON对象，可以使用JSON.stringify()和JSON.parse()将JSON对象转换为字符串，反之亦然。 1234567var quote = &#123;symbol: 'APPL', value: 195.46&#125;;client.send("/topic/stocks", &#123;&#125;, JSON.stringify(quote));client.subcribe("/topic/stocks", function(message) &#123; var quote = JSON.parse(message.body); alert(quote.symbol + " is at " + quote.value);&#125;; 关于stompjs的详细学习地址：http://jmesnil.net/stomp-websocket/doc/]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>整体设计</tag>
        <tag>主要框架和工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[节点管理模块]]></title>
    <url>%2F2019%2F06%2F14%2F%E8%8A%82%E7%82%B9%E7%AE%A1%E7%90%86%E7%94%A8%E6%88%B7%E9%9C%80%E6%B1%82%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[1用户需求分析1用户对象管理员 2节点管理模块整体流程图 文章参考：用户需求分析整体流程图 2产品原型设计1节点配置1新增节点管理1节点添加授权功能设计 基本目标功能 实现形式 检测新增节点 检测新增节点按钮 了解待检测节点信息 添加待检测节点信息表 节点授权 授权按钮 节点不授权 不授权按钮 查看节点新增信息 添加节点授权新增信息表 2节点新增用例逻辑框图12345678910111213@startumlstartwhile (检测节点是否加入?) is (yes) :浏览节点信息; :选择待加入节点; :添加新节点信息; :增添; while (继续增添节点?) is (no) stop endwhile (yes)endwhile (no)stop@enduml 3节点授权界面原型设计2节点配置信息查看1节点配置信息查看功能设计 基本目标功能 实现形式 查看系统已有的节点 添加已有节点信息列表 查看各个节点对应的详细信息 点击节点弹出详情2. 2节点配置信息查看界面原型设计2节点调试1节点在线可视化1节点在线情况功能设计 基本目标功能 实现形式 查看所有节点的在线情况 节点在线矩阵图 2节点在线情况界面原型设计###3节点信息查看 1节点工作队列查看功能设计 基本实现功能 实现形式 查看节点的工作队列 添加每个节点的对列表 2节点工作队列界面原型设计#### 4节点网络负载1节点网络负载界面功能设计 基本实现功能 实现形式 查看节点网络负载 各个节点的负载图、整个网络的负载图 2节点网络负载界面用例逻辑框图1234567891011121314151617181920@startumlstartif(测试场景是否存在?) then (no) stopelse (yes) :选择测试场景; if(是否查看总的网络负载?) then (yes) :选择数据状态; :查看总的节点工作状态图; elseif(查看节点队列) then (yes) :输入节点编号; :查看节点队列状态和数据速率; elseif(查看单个节点的网络负载) then (yes) :输入节点编号; :查看单个节点工作状态图; else (nothing) endif stop @enduml 3节点网络负载界面原型设计5节点工作状态1节点工作状态界面功能设计 基本实现功能 实现形式 查看节点工作状态 各个节点目前工作状态的信息显示 2节点工作状态用例逻辑框图1234567891011121314151617 @startumlstartif(测试场景是否存在?) then (no) stopelse (yes) : 选择测试场景;while(测试场景下是否有节点 ? ) is (yes) :选择工作节点; :查看工作状态; if(继续查看?) then (no) stop else(yes) endifendwhile (no) stop @enduml 3节点工作状态查看界面原型设计3前端代码的实现]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>节点管理</tag>
        <tag>UI设计</tag>
        <tag>需求分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue和Django之间的数据交互]]></title>
    <url>%2F2019%2F06%2F04%2FDjango%E5%92%8CVue%2F</url>
    <content type="text"><![CDATA[使用 axios 访问 API我们有很多种方式可以从 API 请求信息，但是最好首先确认这些数据看起来长什么样，以便进一步确定如何展示它。为此，我们会调用一次这个 API 并输出结果，以便我们能够看清楚它。比如创建一个 data 里的属性以最终放置信息，然后将会在 mounted 生命周期钩子中获取数据并赋值过去： 12345678910111213new Vue(&#123; el: '#app', data () &#123; return &#123; info: null &#125; &#125;, mounted () &#123; axios .get('https://api.coindesk.com/v1/bpi/currentprice.json') .then(response =&gt; (this.info = response)) &#125;&#125;) 123&lt;div id="app"&gt; &#123;&#123; info &#125;&#125;&lt;/div&gt; 但是我们得到的数据往往是这样的 1&#123; "data": &#123; "time": &#123; "updated": "Jun 4, 2019 13:24:00 UTC", "updatedISO": "2019-06-04T13:24:00+00:00", "updateduk": "Jun 4, 2019 at 14:24 BST" &#125;, "disclaimer": "This data was produced from the CoinDesk Bitcoin Price Index (USD). Non-USD currency data converted using hourly conversion rate from openexchangerates.org", "chartName": "Bitcoin", "bpi": &#123; "USD": &#123; "code": "USD", "symbol": "&amp;#36;", "rate": "7,989.8900", "description": "United States Dollar", "rate_float": 7989.89 &#125;, "GBP": &#123; "code": "GBP", "symbol": "&amp;pound;", "rate": "6,299.7246", "description": "British Pound Sterling", "rate_float": 6299.7246 &#125;, "EUR": &#123; "code": "EUR", "symbol": "&amp;euro;", "rate": "7,111.7452", "description": "Euro", "rate_float": 7111.7452 &#125; &#125; &#125;, "status": 200, "statusText": "", "headers": &#123; "content-type": "application/javascript", "cache-control": "max-age=15", "expires": "Tue, 04 Jun 2019 13:25:07 UTC" &#125;, "config": &#123; "transformRequest": &#123;&#125;, "transformResponse": &#123;&#125;, "timeout": 0, "xsrfCookieName": "XSRF-TOKEN", "xsrfHeaderName": "X-XSRF-TOKEN", "maxContentLength": -1, "headers": &#123; "Accept": "application/json, text/plain, */*" &#125;, "method": "get", "url": "https://api.coindesk.com/v1/bpi/currentprice.json" &#125;, "request": &#123;&#125; &#125; 我们已经得到了一些数据。但是它看起来还比较乱，所以我们会更好的展示它并添加一些错误处理，以防出现异常情况或请求超时。 vue-axios安装vue-axios1npm install --save axios vue-axios 引入12345import Vue from 'vue'import axios from 'axios'import VueAxios from 'vue-axios' Vue.use(VueAxios, axios) 使用我们可以以如下三种方式在项目中引入vue-axios1234567891011Vue.axios.get(api).then((response) =&gt; &#123; console.log(response.data)&#125;) this.axios.get(api).then((response) =&gt; &#123; console.log(response.data)&#125;) this.$http.get(api).then((response) =&gt; &#123; console.log(response.data)&#125;) 错误处理很多时候我们可能并没有从 API 获取想要的数据。这可能是由于很多种因素引起的，比如 axios 调用可能由于多种原因而失败，包括但不限于： API 不工作了； 请求发错了； API 没有按我们预期的格式返回信息。 当发送这个请求的时候，我们应该检查一下这些情况，并在所有情况下都返回相应的信息以便处理这些问题。在 axios 中，我们会通过使用 catch 来做这件事。 1.catch(error =&gt; console.log(error)) 项目应用本项目中的应用示例： 12345678910retrieveNodes (context) &#123; axios.get('/nodes/') .then(response =&gt; &#123; context.commit('retrieveNodes', response.data.results) console.log(response.data.results) &#125;) .catch(error =&gt; &#123; console.log(error) &#125;) &#125; 可以得到如下json格式的数据 123456789101112131415161718192021222324252627282930[ &#123; "node_id": 1, "ip": "127.0.0.1", "mac_addr": "07-16-76-00-02-86", "node_status": "ON", "wk_status": "IDLE" &#125;, &#123; "node_id": 2, "ip": "127.0.0.2", "mac_addr": "07-16-76-00-02-87", "node_status": "ON", "wk_status": "IDLE" &#125;, &#123; "node_id": 3, "ip": "127.0.0.3", "mac_addr": "07-16-76-00-02-88", "node_status": "OFF", "wk_status": "IDLE" &#125;, &#123; "node_id": 4, "ip": "127.0.0.3", "mac_addr": "07-16-76-00-02-88", "node_status": "OFF", "wk_status": "IDLE" &#125;] 参考资料使用axio访问api]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>项目设计</tag>
        <tag>节点管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网页前端基本功能的设计]]></title>
    <url>%2F2019%2F05%2F28%2F%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%E7%9A%84%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[Page 1：场景选择根据测试地区的不同，显示不同的节点布局。 可选场景有：Expressway/Primary Highway/Secondary Road/Tertiary Highway/Four-stage Highway，场景选择用传递到后端，主要用于前端限制参数配置可选范围。 Page 2 （节点管理页面）：节点的实时管理节点管理页面主要功能： 展示节点实时的状态信息 用于选择节点安排任务 节点的选择包括：1）选择任务使用的节点 2）选择节点类型——通信环境节点/测试用例节点，用于限制配置参数 不同状态节点（如，处于接收/发送状态，在线状态）应该用不同的颜色/样式表示 Page 3 （任务配置页面）：节点的配置 节点的选择与配置应该可以单个配置也可以批量配置 12345678910111213141516171819202122232425262728//节点的json格式：(所有50个节点)&#123; &quot;nodes&quot;:[ &#123; &quot;id&quot;:1, &quot;nodeState&quot;:&#123; &quot;node_status&quot;:&quot;offline/online&quot;, &quot;w_status&quot;:&quot;idling/pending/waiting/running/finishing/completed&quot;, &quot;tr_status&quot;: &quot;Tx/Rx&quot;, &quot;node_message&quot;:&quot;This is an example message.&quot;, &#125;, &quot;node_config&quot;:&#123; &quot;tr_status&quot;:&quot;Tx/Rx&quot;， &quot;radio&quot;:&quot;1/2&quot;, &quot;Power&quot;:-127 ～ 128, &quot;dataRate&quot;:&quot;R6Mbps12BPSK&quot;, &quot;channel&quot;:&quot;172/174/176/178/180/182/184&quot;, &quot;destMacAddr&quot;:&quot;(e.g.)00-23-5A-15-99-42&quot;, &quot;psid&quot;:0 ～ 0xFFFFFFFF, &quot;payload&quot;:&quot;(e.g.)This is a test payload.&quot;, &quot;payloadLength&quot;:(e.g.)23, &quot;periodic&quot;:true/false, &quot;repeatTimes&quot;:10, &quot;repeatRate&quot;:100, &#125;, &#125;, ... ]&#125; params 描述 tr_status 收发状态 radio 选择工作的Radio Power 发送/接收功率 dataRate 发送速率 channel 发送/接收信道 destMacAddr 目的MAC地址 psid 标识服务类型 payload 负载内容 payloadLength 负载长度 如果不对节点进行配置，则使用节点的默认配置信息（根据场景&amp;节点类型的选择，前端生成默认配置信息显示在节点配置页面）; 当勾选的场景，节点类型或者收发状态不同，返回的参数默认配置会不同，并且可配置的参数不同（不可配置参数禁选）; 配置完成后即生成了一个任务，若需要配置多个任务，则重复2-3步骤。 Page 4（任务页面）：生成任务配置信息、实时显示画面等 展示任务详情:包括任务实时状态以及任务相馆配置; 在此页面可以对任务进行管理（改变优先级，任务执行时间，删除，中止/暂停/重启等） 任务属性 任务属性描述 url ‘/tasks/‘ method GET data JSON(如下所示) params taskID:任务编号currentState:taskStatus:任务状态tx_statistics:整体发包数量rx_statistics:整体收包数量net_PDL:网络丢包率net_delay:网络平均时延config:(见1.4.2PARAM表) 123456789101112131415Tasks: [ &#123; taskID: 1, scence: &apos;&apos;, currentState: &#123; taskStatus: &apos;pending/waiting/running/finishing/completed&apos;, tx_statistics: 1000, rx_statistics: 800, net_PDL: 0.4, net_delay: &apos;2ms&apos; &#125;, config: &#123; &#125; &#125;]]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>项目设计</tag>
        <tag>流程安排</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VueJs框架]]></title>
    <url>%2F2019%2F05%2F28%2Ffront-end-UI%2F</url>
    <content type="text"><![CDATA[本部分主要利用了HTML、CSS和Javascript等知识，借助Vue2.0热门框架进行Web前后端分离的前端的开发工作。 VueJs框架的使用Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。 官网地址详情：https://cn.vuejs.org/v2/guide/ 全局安装 1npm install --g vue 全局安装vue-cli 1npm install --global vue-cli 创建一个基于webpack模块的新项目 1vue init webpack hlc-project 进行Vue项目的配置 12345678910111213141516171819202122This will install Vue 2.x version of the template.For Vue 1.x use: vue init webpack#1.0 hlc-project? Project name hlc-project? Project description A Vue.js project? Author runoob &lt;test@runoob.com&gt;? Vue build standalone? Use ESLint to lint your code? Yes? Pick an ESLint preset Standard? Setup unit tests with Karma + Mocha? Yes? Setup e2e tests with Nightwatch? Yes vue-cli · Generated &quot;hlc-project&quot;. To get started: cd my-project npm install npm run dev Documentation can be found at https://vuejs-templates.github.io/webpac vuetify的使用何为vuetify 一个vue ui库，提供vue组件供使用。根据 Google Material Design 指南实现。Vuetify支持SSR(服务端渲染)，SPA(单页应用程序)，PWA(渐进式web应用程序)和标准HTML页面。 安装vuetify 1vue add vuetify 使用vuetify 1234import Vue from &apos;vue&apos;import Vuetify from &apos;vuetify&apos;Vue.use(Vuetify)]]></content>
      <categories>
        <category>web前端技术学习</category>
      </categories>
      <tags>
        <tag>web前端工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端设计方案]]></title>
    <url>%2F2019%2F05%2F27%2Ffront-to-end%2F</url>
    <content type="text"><![CDATA[VueJs+WebSocket+HTTP REST API ​ 数据在用户、网络前端和后端之间的信息传输过程如下 就网页前端而言，主要问题有以下三方面 组成元素 功能 VueJs 页面UI设计、数据展示设计 HTTP REST API 前端通过HTTP RSTE API与Django交互数据 RabbitMQ 前端通过WebSocket与节点临时数据进行实时交互 因此，前端设计任务会主要围绕以上三个方面进行模块化设计，以达到与信息在用户、前端和后台之间正常传输的整体测试目的]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>项目设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F05%2F26%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>

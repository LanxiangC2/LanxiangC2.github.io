<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[前端知识点总结——算法与数据结构]]></title>
    <url>%2F2020%2F06%2F09%2F%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[排序算法了解哪些冒泡排序 插入排序 选择排序 快速排序 归并排序 手写桶排序桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点： 在额外空间充足的情况下，尽量增大桶的数量 使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中 同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。 什么时候最快当输入的数据可以均匀的分配到每一个桶中。 什么时候最慢当输入的数据被分配到了同一个桶中。 JavaScript 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445function bucketSort(arr, bucketSize) &#123; if (arr.length === 0) &#123; return arr; &#125; var i; var minValue = arr[0]; var maxValue = arr[0]; for (i = 1; i &lt; arr.length; i++) &#123; if (arr[i] &gt; maxValue) &#123; // 输入数据的最大值 maxValue = arr[i]; &#125; if (arr[i] &lt; minValue) &#123; // 输入数据的最小值 minValue = arr[i] &#125; &#125; //桶的初始化 var DEFAULT_BUCKET_SIZE = 5; // 设置桶的默认数量为5 bucketSize = bucketSize || DEFAULT_BUCKET_SIZE; var bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1; var buckets = new Array(bucketCount); for (i = 0; i &lt; buckets.length; i++) &#123; buckets[i] = []; // 二维数组 &#125; //利用映射函数将数据分配到各个桶中 for (i = 0; i &lt; arr.length; i++) &#123; buckets[Math.floor((arr[i] - minValue) / bucketSize)].push(arr[i]); &#125; arr.length = 0; for (i = 0; i &lt; buckets.length; i++) &#123; // 对每个桶进行排序，这里的排序方法自己选择哦铁汁 insertionSort(buckets[i]); for (var j = 0; j &lt; buckets[i].length; j++) &#123; arr.push(buckets[i][j]); &#125; &#125; return arr;&#125;function sortArr () &#123;...&#125;]]></content>
      <categories>
        <category>前端知识点总结</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端知识点总结——JavaScript]]></title>
    <url>%2F2020%2F06%2F09%2F%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94JavaScript%2F</url>
    <content type="text"><![CDATA[apply bind call的区别call 、bind 、 apply 这三个函数的第一个参数都是 this 的指向对象 第二个参数差别来了 call的参数是直接放进去的，第二第三第n个参数全都用逗号分隔，直接放到后面 obj.myFun.call(db,&#39;成都&#39;, ... ,&#39;string&#39; )； apply的所有参数都必须放在一个数组里面传进去 obj.myFun.apply(db,[&#39;成都&#39;, ..., &#39;string&#39; ]); bind除了返回是函数以外，它 的参数和call 一样。 123obj.myFun.call(db,'成都','上海')； // 德玛 年龄 99 来自 成都去往上海obj.myFun.apply(db,['成都','上海']); // 德玛 年龄 99 来自 成都去往上海 obj.myFun.bind(db,'成都','上海')(); // 德玛 年龄 99 来自 成都去往上海 Event LoopEvent Loop 是一个很重要的概念，指的是计算机系统的一种运行机制。 JavaScript语言就采用这种机制，来解决单线程运行带来的一些问题。 想要理解Event Loop，就要从程序的运行模式讲起。运行以后的程序叫做“进程”（process），一般情况下，一个进程一次只能执行一个任务。 如果有很多任务需要执行，不外乎三种解决方法。 （1）排队。因为一个进程一次只能执行一个任务，只好等前面的任务执行完了，再执行后面的任务。 （2）新建进程。使用fork命令，为每个任务新建一个进程。 （3）新建线程。因为进程太耗费资源，所以如今的程序往往允许一个进程包含多个线程，由线程去完成任务。 进程和线程的详细解释，请看这里 以JavaScript语言为例，它是一种单线程语言，所有任务都在一个线程上完成，即采用上面的第一种方法。一旦遇到大量任务或者遇到一个耗时的任务，网页就会出现”假死”，因为JavaScript停不下来，也就无法响应用户的行为。 你也许会问，JavaScript为什么是单线程，难道不能实现为多线程吗？ 这跟历史有关系。JavaScript从诞生起就是单线程。==原因大概是不想让浏览器变得太复杂，因为多线程需要共享资源、且有可能修改彼此的运行结果，对于一种网页脚本语言来说，这就太复杂了。 JavaScript 的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript 的主要用途是与用户互动，以及操作 DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript 同时有两个线程，一个线程在某个 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？ 后来就约定俗成，JavaScript为一种单线程语言。（Worker API可以实现多线程，但是JavaScript本身始终是单线程的。） 如果某个任务很耗时，比如涉及很多I/O（输入/输出）操作，那么线程的运行大概是下面的样子。 上图的绿色部分是程序的运行时间，红色部分是等待时间。可以看到，由于I/O操作很慢，所以这个线程的大部分运行时间都在空等I/O操作的返回结果。这种运行方式称为”同步模式”（synchronous I/O）或”堵塞模式”（blocking I/O）。 如果采用多线程，同时运行多个任务，那很可能就是下面这样。 上图表明，多线程不仅占用多倍的系统资源，也闲置多倍的资源，这显然不合理。Event Loop就是为了解决这个问题而提出的。 “Event Loop是一个程序结构，用于等待和发送消息和事件。（a programming construct that waits for and dispatches events or messages in a program.）” 简单说，就是在程序中设置两个线程：一个负责程序本身的运行，称为”主线程”；另一个负责主线程与其他进程（主要是各种I/O操作）的通信，被称为”Event Loop线程”（可以译为”消息线程”）。 上图主线程的绿色部分，还是表示运行时间，而橙色部分表示空闲时间。每当遇到I/O的时候，主线程就让Event Loop线程去通知相应的I/O程序，然后接着往后运行，所以不存在红色的等待时间。等到I/O程序完成操作，Event Loop线程再把结果返回主线程。主线程就调用事先设定的回调函数，完成整个任务。 js 引擎执行异步代码而不用等待，是因有为有 消息队列和事件循环。 消息队列：消息队列是一个先进先出的队列，它里面存放着各种消息。 事件循环：事件循环是指主线程重复从消息队列中取消息、执行的过程。 实际上，主线程只会做一件事情，就是从消息队列里面取消息、执行消息，再取消息、再执行。当消息队列为空时，就会等待直到消息队列变成非空。而且主线程只有在将当前的消息执行完成后，才会去取下一个消息。这种机制就叫做事件循环机制，取一个消息并执行的过程叫做一次循环。 可以看到，由于多出了橙色的空闲时间，所以主线程得以运行更多的任务，这就提高了效率。这种运行方式称为”异步模式“（asynchronous I/O）或”非堵塞模式”（non-blocking mode）。 这正是JavaScript语言的运行方式。单线程模型虽然对JavaScript构成了很大的限制，但也因此使它具备了其他语言不具备的优势。如果部署得好，JavaScript程序是不会出现堵塞的，这就是为什么node.js平台可以用很少的资源，应付大流量访问的原因。 参考作者：阮一峰，链接地址：http://www.ruanyifeng.com/blog/2013/10/event_loop.html 跨域以及处理方法怎样才会造成跨域问题: 调用接口的时候，当你调用接口的 域名|协议|端口 和你浏览器的 域名|协议|端口 不一致时，就会造成跨域问题。 JSONP123&lt;script src="http://www.a.com/script/1.js"&gt;&lt;/script&gt;&lt;img src="http://www.b.com/1.jpg"&gt;&lt;link href="http://www.c.com/1.css"&gt; 这种标签是不会遇到’跨域’问题的，严格上来说，这不是跨域，跨域是指在脚本代码中向非同源域发送HTTP请求，这只是跨站资源请求 那么我们可以试试看用这种跨站资源请求的方式来实现跨域HTTP请求 原理动态创建标签，然后利用中的src属性不受同源策略的影响约束来跨域获取数据 1234567891011121314151617181920212223242526272829303132333435363738function getJsonp (url, callback) &#123; if (!url) &#123;return &#125; //定义一个数组随机生成函数名 var a = ['a' , 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'] var r1 = Math.floor(Math.random()*10) var r2 = Math.floor(Math.random()*10) var r3 = Math.floor(Math.random()*10) //下边两行表明是在getJsonp这个函数下定义了一个随机的名字作为回调函数名字 var name = 'getJsonp' + a[r1] + a[r2] + a[r3] var cbname = 'getJsonp.' + name if (url.indexOf('?') === -1) &#123; url += '?jsonp=' + cbname &#125;else &#123; url += '&amp;jsonp=' + cbname &#125; console.log(url) //定义脚本 var script = document.createElement('script') getJsonp[name] = function(e) &#123; try&#123; //e为得到的数据 callback &amp;&amp; callback(e) &#125;catch (e)&#123; // &#125;finally&#123; //最后删除该函数与script元素 delete getJsonp[name] script.parentNode.removeChild(script) &#125; &#125; script.src = url document.getElementsByTagName('head')[0].appendChild(script)&#125;//跨域调用getJsonp('http://class.imooc.com/api/jsonp', function(response)&#123; console.log(response)&#125;) 简单一点，可以这样获取 1234567891011121314function myjsonp(obj) &#123; //定义一个处理Jsonp返回数据的回调函数 //直接在window["callback"] = function () &#123;&#125;定义回调更简单 myjsonp["callback"] = function(object) &#123; console.log(object) &#125; var script = document.createElement("script"); //组合请求URL script.src = obj.url + "?jsonp=myjsonp.callback"; document.getElementsByTagName("body")[0].appendChild(script); &#125;myjsonp(&#123; url:"http://class.imooc.com/api/jsonp",&#125;); CORS 对比 JSONP JSONP只能实现GET请求，而CORS支持所有类型的HTTP请求 使用CORS，开发者可以使用普通的XMLHttpRequest发起请求和获得数据，比起JSONP有更好的错误处理 JSONP主要被老的浏览器支持，它们往往不支持CORS，而绝大多数现代浏览器都已经支持了CORS CORS的整个过程都由浏览器自动完成，前端无需做任何设置，跟平时发送ajax请求并无差异。所以，实现CORS的关键在于服务器，只要服务器实现CORS接口，就可以实现跨域通信。 对于简单请求，浏览器会直接发送CORS请求，具体说来就是在header中加入origin请求头字段。同样，在响应头中，返回服务器设置的相关CORS头部字段，Access-Control-Allow-Origin字段为允许跨域请求的源。请求时浏览器在请求头的Origin中说明请求的源，服务器收到后发现允许该源跨域请求，则会成功返回。这里需要注意的是，尽管请求失败，但返回的状态码依然可能为200。 CORS字段介绍：Access-Control-Allow-Methods、Access-Control-Allow-Headers、Access-Control-Allow-Credentials、Access-Control-Max-Age 代码实例 前端代码与发送普通请求没有差异，我们只需在服务端设置即可，以node为例： 123456789var express = require('express');var app = express();var allowCrossDomain = function (req, res, next) &#123; res.header('Access-Control-Allow-Origin', 'http://localhost:3001'); res.header('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE'); res.header('Access-Control-Allow-Headers', 'Content-Type'); next();&#125;app.use(allowCrossDomain); 自定义首部字段为Content-Type的非简单请求则会被正常访问，当然，你也可以将Access-control-Allow-Methods和Access-Control-Allow-Headers这两个配置删掉，删掉之后，将仅支持简单请求进行跨域。 通过修改document.domain来跨子域如果主域相同，可以通过修改document.domain实现跨域。将子域和主域的document.domain设为同一个主域。前提条件是这两个域名必须属于同一个基础域名，而且协议、端口都要一致，否则无法利用document.domain实现跨域。 通过修改window.name来进行跨域window对象有一个name属性，该属性有个特征：在一个窗口（window）的生命周期内，窗口中载入的所有页面都是共享一个window.name的，每个页面对window.name都有读写的权限。载入过的所有页面的window对象，将持有地存储name属性 服务器端设置代理可以实现跨域Nginx代理 使用HTML5中新引进的window.postMessage方法来跨域传送数据通过Flash可以实现跨域手写一个ajax，不依赖第三方库123456789101112var xhr = new XMLHttpRequest();xhr.open("get", "http://www.somewhere-else.com/page", true);xhr.onreadystateChange = function() &#123; if(xhr.readyState === 4) &#123; if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt;= 300 || xhr.status === 304) &#123; alert(xhr.responseText); &#125; else &#123; alert("error ", xhr.status); &#125; &#125;&#125;xhr.send(null);]]></content>
      <categories>
        <category>前端知识点总结</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端知识点总结——ES6]]></title>
    <url>%2F2020%2F06%2F09%2F%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94ES6%2F</url>
    <content type="text"><![CDATA[对ES6有什么了解 从以下几个方面去聊 let和const 解构赋值 ES6拓展 Promise Class Promise介绍一下 解决异步执行。另外回调函数和事件也可以解决异步执行的问题 回调与Promise12345678910111213141516function f() &#123; return new Promise(resolve =&gt; &#123; setTimeout(function () &#123; resolve(); &#125;, 1000) &#125;)&#125;f().then(function() &#123; console.log(1);return f();&#125;).then(function () &#123; console.log(2)&#125;)...... promise新建后立即执行，所以首先输出的是promise，然后then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行。 对比回调和Promise的流程控制回调函数不会重复地执行；调用的resolve全为自己所书写的流程，很大程度改善了反转控制的问题 错误处理 then方法中的第二个参数，即为失败时做的事情 1234567891011121314151617// then(resolve, reject)function f() &#123; return new Promise((resolve,reject)=&gt; &#123; if (val) &#123; resolve() &#125;else&#123; reject() &#125; &#125;)&#125;f(false).then(function() &#123; console.log(1);return f(); //对应resolve（）&#125;,function () &#123; console.log(2); //对应reject（）&#125;)... catch then()方法中无reject()的失败处理则往下走，直至被catch捕获 12345f(false).then()&#123;&#125;.then()&#123;&#125;....catch(e =&gt; &#123;...&#125; finally 不论成功或者失败，finally中的内容一定执行 Promise中的三种状态状态的改变不可逆，一旦决议就不能再修改，总的来说呢，就是Promise对于错误处理机制的理解。如果错误已经捕获了，那么错误不会继续传递下去。如果错误没有被捕获，那么错误会隐式传递下去，直到有错误处理函数来捕获这个错误。 pending（进行中）——&gt; fulfilled（已成功） pending（进行中）——&gt; rejected（已失败） Promise.all() 可以把多个Promise实例包装成一个新的Promise实例 1Promise.all([Promise1, Promise2, Promise3, Promise4, Promise5]) 所有成功则决议成功 Promise.all([]) 直接决议为成功 Promise.race([…, …, …,])只要有一个决议了（成功或者失败），j就返回；传入数组无反应 Promise.resolve()和Promise.reject() 传入一个普通的值 传递一个Promise实例 传递一个thenable 12345let obj = &#123; then (cb) &#123;&#125; oth () &#123;&#125;&#125;Promise.resolve(obj).then(data =&gt;&#123;&#125;) 小案例 页面中有个板块需要多张图片加载完后才能进行展示 1234567891011121314const loadImg = src =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; const img = new Image(); img.src = src; img.onload = () =&gt; &#123;resolve(img)&#125; img.onerror = (e) =&gt; &#123;reject(e)&#125; &#125;)&#125;const imgs =['url', 'url', 'url']Promise.all(imgs.map(src =&gt; loadImg(src))).then(arr =&gt; &#123; arr.forEach(img =&gt; &#123; document.body.appendChild(img) &#125;)&#125;) async和await源码(手写async await的最简实现)介绍 优缺点 优点。相对于promise，async/await处理 then 的调用链，代码要清晰很多，几乎和同步代码一样 缺点。滥用 await 可能会导致性能问题，因为 await 会阻塞代码 async 顾名思义，就是异步的意思， 看上去是一个异步标识，就是告诉我们这个函数中有异步执行的代码。 await 等待右侧表达式的结果，这个结果是promise对象或者其他值。如果它等到的不是一个 promise 对象，那 await 表达式的运算结果就是它等到的东西。如果它等到的是一个 promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。 12345678910111213141516171819202122async function getData_1 () &#123; return '100'&#125;function getData_2 () &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve('200') &#125;, 2000) &#125;)&#125;async function run () &#123; const data_1 = await getData_1(); console.log(data_1); const data_2 = await getData_2(); console.log(data_2);&#125;run (); ==getData_1 前面即使不声明async，使用await也是可以的， 因为await 啥都能等！== ==1.如果等到的是promise， 它就把promise的resolve的参数返回，== ==2.如果等到的是普通东西，就直接返回这个东西。== 就像上面的data_1 , 就算 getData_1 没有async 它的结果也一样的。在run函数中， data_1 后的代码需要getData_1 执行完毕才会执行， data_1 得出以后， data_2其实会2秒之后才会得出， 但是此时，它会等2秒，直到data_2得出以后，才会执行后面的console 解题 async函数是generator函数的语法糖，那么到底是怎么样一个糖呢？让我们来一层层的剥开它的糖衣。 前言 如果让你手写async函数的实现，你是不是会觉得很复杂？这篇文章带你用20行搞定它的核心。 经常有人说async函数是generator函数的语法糖，那么到底是怎么样一个糖呢？让我们来一层层的剥开它的糖衣。 有的同学想说，既然用了generator函数何必还要实现async呢？ 这篇文章的目的就是带大家理解清楚async和generator之间到底是如何相互协作，管理异步的。 示例 123456789101112const getData = () =&gt; new Promise(resolve =&gt; setTimeout(() =&gt; resolve("data"), 1000))async function test() &#123; const data = await getData() console.log('data: ', data); const data2 = await getData() console.log('data2: ', data2); return 'success'&#125;// 这样的一个函数 应该再1秒后打印data 再过一秒打印data2 最后打印successtest().then(res =&gt; console.log(res)) 思路 对于这个简单的案例来说，如果我们把它用generator函数表达，会是怎么样的呢？ 12345678function* testG() &#123; // await被编译成了yield const data = yield getData() console.log('data: ', data); const data2 = yield getData() console.log('data2: ', data2); return 'success'&#125; 我们知道，generator函数是不会自动执行的，每一次调用它的next方法，会停留在下一个yield的位置。 利用这个特性，我们只要编写一个自动执行的函数，就可以让这个generator函数完全实现async函数的功能。 1234567891011121314const getData = () =&gt; new Promise(resolve =&gt; setTimeout(() =&gt; resolve("data"), 1000)) var test = asyncToGenerator( function* testG() &#123; // await被编译成了yield const data = yield getData() console.log('data: ', data); const data2 = yield getData() console.log('data2: ', data2); return 'success' &#125;)test().then(res =&gt; console.log(res)) 那么大体上的思路已经确定了， asyncToGenerator接受一个generator函数，返回一个promise， 关键就在于，里面用yield来划分的异步流程，应该如何自动执行。 如果是手动执行 在编写这个函数之前，我们先模拟手动去调用这个generator函数去一步步的把流程走完，有助于后面的思考。 12345678function* testG() &#123; // await被编译成了yield const data = yield getData() console.log('data: ', data); const data2 = yield getData() console.log('data2: ', data2); return 'success'&#125; 我们先调用testG生成一个迭代器 12// 返回了一个迭代器var gen = testG() 然后开始执行第一次next 123// 第一次调用next 停留在第一个yield的位置// 返回的promise里 包含了data需要的数据var dataPromise = gen.next() 这里返回了一个promise，就是第一次getData()所返回的promise，注意 1const data = yield getData() 这段代码要切割成左右两部分来看，第一次调用next，其实只是停留在了yield getData()这里， data的值并没有被确定。 那么什么时候data的值会被确定呢？ 下一次调用next的时候，传的参数会被作为上一个yield前面接受的值 也就是说，我们再次调用gen.next(&#39;这个参数才会被赋给data变量&#39;)的时候 1234567891011//data`的值才会被确定为`'这个参数才会被赋给data变量'gen.next('这个参数才会被赋给data变量')// 然后这里的data才有值const data = yield getData()// 然后打印出dataconsole.log('data: ', data);// 然后继续走到下一个yieldconst data2 = yield getData() 然后往下执行，直到遇到下一个yield，继续这样的流程… 这是generator函数设计的一个比较难理解的点，但是为了实现我们的目标，还是得去学习它~ 借助这个特性，如果我们这样去控制yield的流程，是不是就能实现异步串行了？ 1234567891011121314151617181920212223242526272829const getData = () =&gt; new Promise(resolve =&gt; setTimeout(() =&gt; resolve("data"), 1000))function* testG() &#123; // await被编译成了yield const data = yield getData() console.log('data: ', data); const data2 = yield getData() console.log('data2: ', data2); return 'success'&#125;var gen = testG()var dataPromise = gen.next()dataPromise.then((value1) =&gt; &#123; // data1的value被拿到了 继续调用next并且传递给data var data2Promise = gen.next(value1) // console.log('data: ', data); // 此时就会打印出data data2Promise.value.then((value2) =&gt; &#123; // data2的value拿到了 继续调用next并且传递value2 gen.next(value2) // console.log('data2: ', data2); // 此时就会打印出data2 &#125;)&#125;) 这样的一个看着像callback hell的调用，就可以让我们的generator函数把异步安排的明明白白。 实现 有了这样的思路，实现这个高阶函数就变得很简单了。 先整体看一下结构，有个印象，然后我们逐行注释讲解。 1234567891011121314151617181920212223function asyncToGenerator(generatorFunc) &#123; return function() &#123; const gen = generatorFunc.apply(this, arguments) return new Promise((resolve, reject) =&gt; &#123; function step(key, arg) &#123; let generatorResult try &#123; generatorResult = gen[key](arg) &#125; catch (error) &#123; return reject(error) &#125; const &#123; value, done &#125; = generatorResult if (done) &#123; return resolve(value) &#125; else &#123; return Promise.resolve(value).then(val =&gt; step('next', val), err =&gt; step('throw', err)) &#125; &#125; step("next") &#125;) &#125;&#125;复制代码 不多不少，22行。 接下来逐行讲解。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071function asyncToGenerator(generatorFunc) &#123; // 返回的是一个新的函数 return function() &#123; // 先调用generator函数 生成迭代器 // 对应 var gen = testG() const gen = generatorFunc.apply(this, arguments) // 返回一个promise 因为外部是用.then的方式 或者await的方式去使用这个函数的返回值的 // var test = asyncToGenerator(testG) // test().then(res =&gt; console.log(res)) return new Promise((resolve, reject) =&gt; &#123; // 内部定义一个step函数 用来一步一步的跨过yield的阻碍 // key有next和throw两种取值，分别对应了gen的next和throw方法 // arg参数则是用来把promise resolve出来的值交给下一个yield function step(key, arg) &#123; let generatorResult // 这个方法需要包裹在try catch中 // 如果报错了 就把promise给reject掉 外部通过.catch可以获取到错误 try &#123; generatorResult = gen[key](arg) &#125; catch (error) &#123; return reject(error) &#125; // gen.next() 得到的结果是一个 &#123; value, done &#125; 的结构 const &#123; value, done &#125; = generatorResult if (done) &#123; // 如果已经完成了 就直接resolve这个promise // 这个done是在最后一次调用next后才会为true // 以本文的例子来说 此时的结果是 &#123; done: true, value: 'success' &#125; // 这个value也就是generator函数最后的返回值 return resolve(value) &#125; else &#123; // 除了最后结束的时候外，每次调用gen.next() // 其实是返回 &#123; value: Promise, done: false &#125; 的结构， // 这里要注意的是Promise.resolve可以接受一个promise为参数 // 并且这个promise参数被resolve的时候，这个then才会被调用 return Promise.resolve( // 这个value对应的是yield后面的promise value ).then( // value这个promise被resove的时候，就会执行next // 并且只要done不是true的时候 就会递归的往下解开promise // 对应gen.next().value.then(value =&gt; &#123; // gen.next(value).value.then(value2 =&gt; &#123; // gen.next() // // // 此时done为true了 整个promise被resolve了 // // 最外部的test().then(res =&gt; console.log(res))的then就开始执行了 // &#125;) // &#125;) function onResolve(val) &#123; step("next", val) &#125;, // 如果promise被reject了 就再次进入step函数 // 不同的是，这次的try catch中调用的是gen.throw(err) // 那么自然就被catch到 然后把promise给reject掉啦 function onReject(err) &#123; step("throw", err) &#125;, ) &#125; &#125; step("next") &#125;) &#125;&#125; 参考作者：晨曦时梦见兮，链接：https://juejin.im/post/5e79e841f265da5726612b6e 迭代器 生成器了解吗ES6 新引入了 Generator 函数，可以通过 yield 关键字，把函数的执行流挂起，为改变执行流程提供了可能，从而为异步编程提供解决方案。 基本用法 Generator 函数组成Generator 有两个区分于普通函数的部分： 一是在 function 后面，函数名之前有个 * ； 函数内部有 yield 表达式。 其中 * 用来表示函数为 Generator 函数，yield 用来定义函数内部的状态。 12345678function* func()&#123; console.log("one"); yield '1'; console.log("two"); yield '2'; console.log("three"); return '3'; &#125; 调用 Generator 函数和调用普通函数一样，在函数名后面加上()即可，但是 Generator 函数不会像普通函数一样立即执行，而是返回一个指向内部状态对象的指针，所以要调用遍历器对象Iterator 的 next 方法，指针就会从函数头部或者上一次停下来的地方开始执行。 1234f.next(); // one // &#123;value: "1", done: false&#125; f.next(); // two // &#123;value: "2", done: false&#125; f.next(); // three // &#123;value: "3", done: true&#125; f.next(); // &#123;value: undefined, done: true&#125; 第一次调用 next 方法时，从 Generator 函数的头部开始执行，先是打印了 one ,执行到 yield 就停下来，并将yield 后边表达式的值 ‘1’，作为返回对象的 value 属性值，此时函数还没有执行完， 返回对象的 done 属性值是 false。 第二次调用 next 方法时，同上步 。 第三次调用 next 方法时，先是打印了 three ，然后执行了函数的返回操作，并将 return 后面的表达式的值，作为返回对象的 value 属性值，此时函数已经结束，多以 done 属性值为true 。 第四次调用 next 方法时， 此时函数已经执行完了，所以返回 value 属性值是 undefined ，done 属性值是 true 。如果执行第三步时，没有 return 语句的话，就直接返回 {value: undefined, done: true}。 函数返回的遍历器对象的方法next 方法 一般情况下，next 方法不传入参数的时候，yield 表达式的返回值是 undefined 。当 next 传入参数的时候，该参数会作为上一步yield的返回值。 12345678function* sendParameter()&#123; console.log("strat"); var x = yield '2'; console.log("one:" + x); var y = yield '3'; console.log("two:" + y); console.log("total:" + (x + y)); &#125; 12345678//next不传参var sendp1 = sendParameter(); sendp1.next(); // strat // &#123;value: "2", done: false&#125;sendp1.next(); // one:undefined // &#123;value: "3", done: false&#125; sendp1.next(); // two:undefined // total:NaN // &#123;value: undefined, done: true&#125; //next传参 var sendp2 = sendParameter(); sendp2.next(10); // strat // &#123;value: "2", done: false&#125; sendp2.next(20); // one:20 // &#123;value: "3", done: false&#125; sendp2.next(30); // two:30 // total:50 // &#123;value: undefined, done: true&#125; 除了使用 next ，还可以使用 for… of 循环遍历 Generator 函数生产的 Iterator 对象。 return 方法 return 方法返回给定值，并结束遍历 Generator 函数。 return 方法提供参数时，返回该参数；不提供参数时，返回 undefined 。 1234567891011121314151617function* foo()&#123; yield 1; yield 2; yield 3; &#125; var f = foo(); f.next(); // &#123;value: 1, done: false&#125; f.return("foo"); // &#123;value: "foo", done: true&#125; f.next(); // &#123;value: undefined, done: true&#125; //throw 方法 throw 方法可以再 Generator 函数体外面抛出异常，再函数体内部捕获。 var g = function* () &#123; try &#123; yield; &#125; catch (e) &#123; console.log('catch inner', e); &#125; &#125;; var i = g(); i.next(); try &#123; i.throw('a'); i.throw('b'); &#125; catch (e) &#123; console.log('catch outside', e); &#125; // catch inner a // catch outside b 遍历器对象抛出了两个错误，第一个被 Generator 函数内部捕获，第二个因为函数体内部的catch 函数已经执行过了，不会再捕获这个错误，所以这个错误就抛出 Generator 函数体，被函数体外的 catch 捕获。 yield* 表达式 yield* 表达式表示 yield 返回一个遍历器对象，用于在 Generator 函数内部，调用另一个 Generator 函数。 1234567891011121314151617181920function* callee() &#123; console.log('callee: ' + (yield)); &#125; function* caller() &#123; while (true) &#123; yield* callee(); &#125; &#125; const callerObj = caller(); callerObj.next(); // &#123;value: undefined, done: false&#125;callerObj.next("a"); // callee: a // &#123;value: undefined, done: false&#125; callerObj.next("b"); // callee: b // &#123;value: undefined, done: false&#125; // 等同于 function* caller() &#123; while (true) &#123; for (var value of callee) &#123; yield value; &#125; &#125; &#125; 使用场景实现 Iterator 为不具备 Iterator 接口的对象提供遍历方法。 12345678910function* objectEntries(obj) &#123; const propKeys = Reflect.ownKeys(obj); for (const propKey of propKeys) &#123; yield [propKey, obj[propKey]]; &#125; &#125; const jane = &#123; first: 'Jane', last: 'Doe' &#125;; for (const [key,value] of objectEntries(jane)) &#123; console.log(`$&#123;key&#125;: $&#123;value&#125;`); &#125; // first: Jane // last: Doe Reflect.ownKeys() 返回对象所有的属性，不管属性是否可枚举，包括 Symbol。 jane 原生是不具备 Iterator 接口无法通过 for… of遍历。这边用了 Generator 函数加上了 Iterator 接口，所以就可以遍历 jane 对象了。 for in /for of 区别遍历数组通常用for循环ES5的话也可以使用forEach，ES5具有遍历数组功能的还有map、filter、some、every、reduce、reduceRight等，只不过他们的返回结果不一样。但是==使用foreach遍历数组的话，使用break不能中断循环，使用return也不能返回到外层函数== for in遍历数组的毛病 index索引为字符串型数字，不能直接进行几何运算 遍历顺序有可能不是按照实际数组的内部顺序 使用for in会遍历数组所有的可枚举属性，包括原型。例如上栗的原型方法method和name属性 ==所以for in更适合遍历对象，不要使用for in遍历数组== 那么除了使用for循环，如何更简单的正确的遍历数组达到我们的期望呢（即不遍历method和name），ES6中的for of更胜一筹 12345var myArray=[1,2,4,5,6,7]myArray.name="数组";for (var value of myArray) &#123; console.log(value);&#125; ==记住，for in遍历的是数组的索引（即键名），而for of遍历的是数组元素值== for of遍历的只是数组内的元素，而不包括数组的原型属性method和索引name for-of是ES6新增的功能 for-of这个方法避开了for-in循环的所有缺陷 与forEach()不同的是，它可以正确响应break、continue和return语句 for-of循环不仅支持数组，还支持大多数类数组对象，例如DOM NodeList对象。for-of循环也支持字符串遍历 遍历对象1234567891011Object.prototype.method=function()&#123; console.log(this);&#125;var myObject=&#123; a:1, b:2, c:3&#125;for (var key in myObject) &#123; console.log(key);&#125; for in 可以遍历到myObject的原型方法method,如果不想遍历原型方法和属性的话，可以在循环内部判断一下,==hasOwnPropery方法可以判断某属性是否是该对象的实例属性==，或者==通过ES5的Object.keys(myObject)获取对象的实例属性组成的数组，不包括原型方法和属性== 123456789for (var key in myObject) &#123; if（myObject.hasOwnProperty(key))&#123; console.log(key); &#125;&#125;for (var key of Object.keys(someObject)) &#123; console.log(key + ": " + someObject[key]);&#125; 总结 ==for…of适用遍历数/数组对象/字符串/map/set等拥有迭代器对象的集合。但是不能遍历对象，因为没有迭代器对象。与forEach()不同的是，它可以正确响应break、continue和return语句== ==for…of循环不支持普通对象，但如果你想迭代一个对象的属性，你可以用for…in循环（这也是它的本职工作）或内建的Object.keys()方法== 补充js的对象遍历 JS对象遍历for-in遍历 for-in是为遍历对象而设计的，不适用于遍历数组。(遍历数组的缺点：数组的下标index值是数字，for-in遍历的index值”0”,”1”,”2”等是字符串) for-in循环存在缺陷：循环会遍历对象自身的和继承的可枚举属性(不含Symbol属性) 1234for (var index in arr)&#123; console.log(arr[index]); console.log(index);&#125; 使用Object.keys()遍历 返回一个数组,包括对象自身的(不含继承的)所有可枚举属性(不含Symbol属性). 1234var obj = &#123;'0':'a','1':'b','2':'c'&#125;;Object.keys(obj).forEach(function(key)&#123; console.log(key,obj[key]);&#125;); 使用Object.getOwnPropertyNames(obj)遍历 返回一个数组,包含对象自身的所有属性(不含Symbol属性,但是包括不可枚举属性). 1234var obj = &#123;'0':'a','1':'b','2':'c'&#125;;Object.getOwnPropertyNames(obj).forEach(function(key)&#123; console.log(key,obj[key]);&#125;); 使用Reflect.ownKeys(obj)遍历 返回一个数组,包含对象自身的所有属性,不管属性名是Symbol或字符串,也不管是否可枚举. 1234var obj = &#123;'0':'a','1':'b','2':'c'&#125;;Reflect.ownKeys(obj).forEach(function(key)&#123; console.log(key,obj[key]);&#125;);]]></content>
      <categories>
        <category>前端知识点总结</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端知识点总结——网络]]></title>
    <url>%2F2020%2F06%2F09%2F%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[对称加密和非对称加密 对称加密 对称加密指的就是加密和解密使用同一个秘钥，所以叫做对称加密。对称加密只有一个秘钥，作为私钥。 非对称加密 非对称加密指的是：加密和解密使用不同的秘钥，一把作为公开的公钥，另一把作为私钥。公钥加密的信息，只有私钥才能解密。私钥加密的信息，只有公钥才能解密。（A、B两把钥匙是拥有一定数学关系的一组秘钥） 区别 对称加密算法相比非对称加密算法来说，加解密的效率要高得多。但是缺陷在于对于秘钥的管理上，以及在非安全信道中通讯时，密钥交换的安全性不能保障。所以在实际的网络环境中，会将两者混合使用。 HTTP和HTTPS的区别 超文本传输协议HTTP协议 被用于在Web浏览器和网站服务器之间传递信息，==HTTP协议以明文方式发送内容==，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，==因此，HTTP协议不适合传输一些敏感信 息==，比如：信用卡号、密码、账户金额、交易信息等。 安全套接字层超文本传输协议HTTPS 为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS，为了数据传输的安全，==HTTPS在HTTP的基 础上加入了SSL/TLS协议==，SSL/TLS依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。 客户端在使用HTTPS方式与Web服务器通信时的步骤 客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。 Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。 客户端的浏览器与Web服务器开始协商SSL/TLS连接的安全等级，也就是信息加密的等级。 客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。 Web服务器利用自己的私钥解密出会话密钥。 Web服务器利用会话密钥加密与客户端之间的通信。 主要区别 ==https协议需要到CA申请证书，一般免费证书较少，因而需要一定费用。== ==http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl/tls加密传输协议。== ==http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。== ==http的连接很简单，是无状态的；HTTPS协议是由SSL/TLS+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。==]]></content>
      <categories>
        <category>前端知识点总结</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端知识点总结——Vue]]></title>
    <url>%2F2020%2F06%2F09%2F%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94Vue%2F</url>
    <content type="text"><![CDATA[vue和react 相似之处 Virtual DOMVue.js(2.0版本)与React的其中最大一个相似之处，就是他们都使用了一种叫’Virtual DOM’的东西。所谓的Virtual DOM基本上说就是它名字的意思：虚拟DOM，DOM树的虚拟表现。它的诞生是基于这么一个概念：改变真实的DOM状态远比改变一个JavaScript对象的花销要大得多。 Virtual DOM是一个映射真实DOM的JavaScript对象，如果需要改变任何元素的状态，那么是先在Virtual DOM上进行改变，而不是直接改变真实的DOM。当有变化产生时，一个新的Virtual DOM对象会被创建并计算新旧Virtual DOM之间的差别。之后这些差别会应用在真实的DOM上。 组件化React与Vue都鼓励组件化应用。这本质上说，是建议你将你的应用分拆成一个个功能明确的模块，每个模块之间可以通过合适的方式互相联系。 PropsReact和Vue都有’props’的概念，这是properties的简写。props在组件中是一个特殊的属性，允许父组件往子组件传送数据。在React中，这是必须的，它依赖一个“单一数据源”作为它的“状态”。而在Vue中，props略有不同。它们一样是在组件中被定义，但Vue依赖于模板语法，你可以通过模板的循环函数更高效地展示传入的数据。 构建工具React和Vue都有自己的构建工具，你可以使用它快速搭建开发环境。React可以使用Create React App (CRA)，而Vue对应的则是vue-cli。两个工具都能让你得到一个根据最佳实践设置的项目模板。 配套框架Vue与React最后一个相似但略有不同之处是它们配套框架的处理方法。相同之处在于，两个框架都专注于UI层，其他的功能如路由、状态管理等都交由同伴框架进行处理。· 而不同之处是在于它们如何关联它们各自的配套框架。Vue的核心团队维护着vue-router和vuex，它们都是作为官方推荐的存在。而React的react-router和react-redux则是由社区成员维护，它们都不是官方维护的。 主要区别 模板 vs JSXReact与Vue最大的不同是模板的编写。 状态管理 vs 对象属性如果你对React熟悉，你就会知道应用中的状态是（React）关键的概念。也有一些配套框架被设计为管理一个大的state对象，如Redux。此外，state对象在React应用中是不可变的，意味着它不能被直接改变（这也许不一定正确）。在React中你需要使用setState()方法去更新状态。 在Vue中，state对象并不是必须的，数据由data属性在Vue对象中进行管理。不需要使用如setState()之类的方法去改变它的状态，在Vue对象中，data参数就是应用中数据的保存者。 对于管理大型应用中的状态这一话题而言，Vue.js的作者尤雨溪曾说过，（Vue的）解决方案适用于小型应用，但对于对于大型应用而言不太适合。多数情况下，框架内置的状态管理是不足以支撑大型应用的，Redux或Vuex等状态管理方案是必须使用的。 原文链接：http://caibaojian.com/vue-vs-react.html vue相比react解决了什么问题vue好在哪里思想是前提。“html依赖css，css不要依赖html”，“html依赖js，js不要依赖html”，理解了上面的思想，再回头看vue，你就懂了！vue的效果：html引用 “数据”，html引用js。js是不引用html的。如果js引用html，那么html就不好修改和变化啦。html频繁改动是常态。js对数据操作，html根据数据进行渲染。js不要直接操作html！ 虚拟dom： virtual dom （也被称为vdom），他是由JavaScript模拟出来的具有和真实DOM结构的树形结构 MVVM MVVM是Model-View-ViewModel，是把一个系统分为了模型（model）、视图（view）和view-model三个部分。 vue在MVVM架构下，view和model之间没有直接的联系，但是view和view-model、model和view-model之间时交互的，当view数据发生变化时，可以通过view-model同步到model中，model数据变化也会同步到view中。这样一来，vue的代码量就会少很多，操作也会更加简便。 两者区别React组件是函数，所以写React组件其实就是在写函数，写一个什么样的函数呢？一个接收 props 作为参数的函数，至于 props 这个参数中包含什么那就您随意了，所以js这门语言所拥有的都可以看做是React拥有的，比如高阶组件不就是高阶函数嘛~ Vue的组件也是函数，只不过写Vue组件却不是在写函数，而是在写函数的参数，比如： 1234567export default &#123; name: 'FuckComp', created () &#123; console.log('fuck fuck fuck') &#125;, props: ['a', 'b']&#125; 这不就是一个普通的对象嘛，可以看到 props 只是参数的一部分。 以上是内容说明什么呢？打个比喻，比如实现： debounce(func, [wait=0], [options={}])函数。用React实现就像是你需要完全自己开发： 123function debounce (func, wait, options) &#123; // ... 具体实现你自己去写&#125; 而用Vue实现就像你仅仅需要传递一个配置对象： 123456// 你只需要告诉我你要的是什么，具体我帮你实现&#123; fn: func, wait: 0, options: &#123;&#125;&#125; 从这个角度来看的话我们还可以举一个不严谨的例子：把React比作nodejs，那么Vue就是Koa。 Vue说它简单，理由是：React组件是函数，Vue组件是高度封装的函数。 React说它拥有完全的JavaScript能力，理由也是：React组件是函数，Vue组件是高度封装的函数 所以你看，优点不优点的，最后不都看个人口味吗。 用Vue真的很爽就像在吃糖，但有时候React的灵活真的也能让你有种想要大展才华的快感。 总结 都是响应式框架，开发业务都没有任何问题。Vue适合于响应式框架的初学者，因为API很完全，不会的东西可以很快搜到答案，React适合对设计有所追求的开发者，因为React的API很少，对开发没有过多的约束，可以更大程度发挥前端创造性。另外RN相对于Weex也更加成熟一些。]]></content>
      <categories>
        <category>前端知识点总结</category>
      </categories>
      <tags>
        <tag>前端框架</tag>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端知识点总结——nodes.js]]></title>
    <url>%2F2020%2F06%2F09%2F%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94nodejs%2F</url>
    <content type="text"><![CDATA[koa洋葱圈运行机制1234567891011121314151617181920const Koa = require('koa');const app = new Koa();app.use(async (ctx, next) =&gt; &#123; console.log(1); await next(); console.log(6);&#125;);app.use(async (ctx, next) =&gt; &#123; console.log(2); await next(); console.log(5);&#125;);app.use(async (ctx, next) =&gt; &#123; console.log(3); ctx.body = "hello world"; console.log(4);&#125;);app.listen(3000, () =&gt; &#123; console.log('listenning on 3000');&#125;); 上面的代码执行后会输出123456，就像一个洋葱一样，从外层进去，然后碰到next()就执行下一个中间件，执行完成后再返回回来。先假设我们已经实现了next为下个中间件这段代码，上面的执行逻辑就很清楚了，先输出1，然后进入下一个中间件，去处理2，同理最后后面都处理完成后处理5，5处理完成后第二个中间件结束，然后第一个中间件再处理6。 所以现在就是怎么实现这个代码。通过看Koa的源码我们可以发现它是通过koa-compose这个库实现的，代码很短，如下： 12345678910111213141516171819function compose (middleware) &#123; return function (context, next) &#123; // last called middleware # let index = -1 return dispatch(0) function dispatch (i) &#123; if (i &lt;= index) return Promise.reject(new Error('next() called multiple times')) index = i let fn = middleware[i] if (i === middleware.length) fn = next if (!fn) return Promise.resolve() try &#123; return Promise.resolve(fn(context, dispatch.bind(null, i + 1))); &#125; catch (err) &#123; return Promise.reject(err) &#125; &#125; &#125;&#125; 核心代码就是return Promise.resolve(fn(context, dispatch.bind(null, i + 1)));这里了，每次执行中间件时，会将第二个中间件作为函数的第二个参数传进去。这也就和上面的async (ctx, next) =&gt; {}写法对应上了，所以执行next()就可以执行下一个中间件了。 还是利用闭包和递归的性质，一个个执行，并且每次执行都是返回promise，所以最后得到的打印结果也是如我们所愿。那么路由的中间件是否调用就不是koa2管的，这个工作就交给了koa-router，这样koa2才可以保持精简彪悍的风格。 参考地址：https://www.jianshu.com/p/2639d43b0d9e express和koa区别 提到Node.js开发，不得不提目前炙手可热的2大框架express和koa。Express诞生已有时日，是一个简洁而灵活的web开发框架，使用简单而功能强大。Koa相对更为年轻，是Express框架原班人马基于ES6新特性重新开发的敏捷开发框架，现在可谓风头正劲，大有赶超Express之势。 虽然koa看上去比express少集成了很多功能，但是使用起来其实基本一致，因为中间件非常丰富全面，需要什么require进来就行了（不一定要像express那样先帮你require好），使用起来反而更加灵活。 请求 HTTP Request 服务器端需要进行什么处理，怎么处理以及处理的参数都依赖客户端发送的请求，两个框架都封装了HTTP Request对象，便于对这一部分进行处理。以下主要举例说明下对请求参数的处理，其它例如头信息、Cookie等请参考官方文档。两者除了写法上稍有区别，没太大区别。GET参数都可以直接通过Request对象获取，POST参数都需要引入中间件先parse，再取值。 路由Route 收到客户端的请求，服务需要通过识别请求的方法（HTTP Method: GET, POST, PUT…）和请求的具体路径(path)来进行不同的处理。这部分功能就是路由（Route）需要做的事情，说白了就是请求的分发，分发到不同的回调方法去处理。 这里需要说明2个问题，首先是app.get，在应用生命周期中也有一个app.get方法，用于获取项目配置。Express内部就是公用的一个方法，如果传入的只有1个参数就获取配置，2个参数就作为路由处理。其次是app.use(&#39;*&#39;, cb) 与app.all(&#39;*&#39;, cb) 的区别，前者是中间件方式，调用是有顺序的，不一定会执行到；后者是路由方式，肯定会执行到。 返回 HTTP Response 获取完请求参数、处理好了具体的请求、视图也准备就绪，下面就该返回给客户端了，那就是HTTP Response对象了。这部分也属于框架的基础部分，各种都做了封装实现，显著的区别是koa直接将输出绑定到了ctx.body属性上，另外输出JSON或JSONP需要引入中间件。 中间件 Middleware 对比了主要的几个框架功能方面的使用，其实区别最大，使用方式最不同的地方是在中间件的处理上。==Express由于是在ES6特性之前的，====中间件的基础原理还是callback方式的==；==而koa得益于generator特性和co框架（co会把所有generator的返回封装成为Promise对象），使得中间件的编写更加优雅==。 Nginx原理 反向代理 反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端 反向代理服务器对于客户端而言它就像是原始服务器，并且客户端不需要进行任何特别的设置，代理的是“服务端” 正向代理是一个位于客户端和原始服务器(origin server)之间的服务器，代理的是”客户端“ 负载均衡 客户端发送的、Nginx 反向代理服务器接收到的请求数量，就是我们说的负载量。请求数量按照一定的规则进行分发，到不同的服务器处理的规则，就是一种均衡规则。所以将服务器接收到的请求按照规则分发的过程，称为负载均衡。 工作流程 用户通过域名发出访问Web服务器的请求，该域名被DNS服务器解析为反向代理服务器的IP地址 反向代理服务器接受用户的请求 反向代理服务器在本地缓存中查找请求的内容，找到后直接把内容发送给用户 如果本地缓存里没有用户所请求的信息内容，反向代理服务器会代替用户向源服务器请求同样的信息内容，并把信息内容发给用户，如果信息内容是缓存的还会把它保存到缓存中 优点 保护了真实的web服务器，保证了web服务器的资源安全 节约了有限的IP地址资源 减少WEB服务器压力，提高响应速度 其他：（1）请求的统一控制，包括设置权限、过滤规则等；（2）区分动态和静态可缓存内容；（3）实现负载均衡，内部可以采用多台服务器来组成服务器集群，外部还是可以采用一个地址访问；（4）解决Ajax跨域问题；（5）作为真实服务器的缓冲，解决瞬间负载量大的问题； 原理 Nginx有五大优点：模块化、事件驱动、异步、非阻塞、多进程单线程。由内核和模块组成的，其中内核完成的工作比较简单，仅仅通过查找配置文件将客户端请求映射到一个location block，然后又将这个location block中所配置的每个指令将会启动不同的模块去完成相应的工作。 Nginx本身做的工作实际很少，当它接到一个HTTP请求时，它仅仅是通过查找配置文件将此次请求映射到一个location block，而此location中所配置的各个指令则会启动不同的模块去完成工作，因此模块可以看做Nginx真正的劳动工作者。通常一个location中的指令会涉及一个handler模块和多个filter模块（当然，多个location可以复用同一个模块）。handler模块负责处理请求，完成响应内容的生成，而filter模块对响应内容进行处理。 用户根据自己的需要开发的模块都属于第三方模块。正是有了这么多模块的支撑，Nginx的功能才会如此强大。 参考地址：https://www.jianshu.com/p/6215e5d24553 手写中间件测试请求时间在实战项目中，经常需要记录下服务器的响应时间，也就是从服务器接收到HTTP请求，到最终返回给客户端之间所耗时长。在Koa应用中，利用中间件机制可以很方便的实现这一功能。代码如下所示： 12345678910111213141516171801 const koa = require('koa');02 const app = new koa();03 app.use(async (ctx, next) =&gt; &#123; // 记录服务器响应时间的中间件04 let stime = new Date().getTime(); // 记录当前时间戳05 await next(); // 事件控制权中转06 let etime = new Date().getTime(); // 所有中间件执行完成后记录当前时间07 ctx.response.type = 'text/html';08 ctx.response.body = '&lt;h1&gt;Hello World&lt;/h1&gt;';09 console.log(`请求地址: $&#123;ctx.path&#125;，响应时间：$&#123;etime - stime&#125;ms`);10 &#125;);11 app.use(async (ctx, next) =&gt; &#123;12 console.log('中间件 doSoming');13 await next();14 console.log('中间件执行 over');15 &#125;);16 app.listen(3000, () =&gt; &#123;17 console.log('server is running at http://localhost:3000');18 &#125;);]]></content>
      <categories>
        <category>前端知识点总结</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>node.js框架</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端知识点总结——React]]></title>
    <url>%2F2020%2F06%2F08%2F%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94React%2F</url>
    <content type="text"></content>
      <categories>
        <category>前端知识点总结</category>
      </categories>
      <tags>
        <tag>前端框架</tag>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[位运算]]></title>
    <url>%2F2020%2F06%2F08%2F%E4%BD%8D%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[按位与运算符（&amp;）参加运算的两个数，按二进制位进行“与”运算。运算规则：只有两个数的二进制同时为1，结果才为1，否则为0。（负数按补码形式参加按位与运算）即 0 &amp; 0= 0 ，0 &amp; 1= 0，1 &amp; 0= 0， 1 &amp; 1= 1。 例：3 &amp;5 即 00000011 &amp; 00000101 = 00000001 ，所以 3 &amp; 5的值为1。 按位或运算符（|）参加运算的两个数，按二进制位进行“或”运算。运算规则：参加运算的两个数只要两个数中的一个为1，结果就为1。即 0 | 0= 0 , 1 | 0= 1 ， 0 | 1= 1 , 1 | 1= 1 。 例：2 | 4 即 00000010 | 00000100 = 00000110 ，所以2 | 4的值为 6 。 异或运算符（^）参加运算的两个数，按二进制位进行“异或”运算。运算规则：参加运算的两个数，如果两个相应位为“异”（值不同），则该位结果为1，否则为0。即 0 ^ 0=0 ， 0 ^ 1= 1 ， 1 ^ 0= 1 ， 1 ^ 1= 0 。 例： 2 ^ 4 即 00000010 ^ 00000100 =00000110 ，所以 2 ^ 4 的值为6 。]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用openpyxl处理excel表格]]></title>
    <url>%2F2020%2F06%2F07%2F%E4%BD%BF%E7%94%A8openpyxl%E5%A4%84%E7%90%86excel%E8%A1%A8%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[前言 邹同学是国贸专业的，听她说其他同学处理数据都是手动，真实骇人听闻啊，遂昨晚花了点时间研究了下，跑了个小demo，这里分享给大家，也随便记录下自己的python学习之旅 首先申明笔者并不了解python，代码不规范的地方还请多多理解 需求 给定一个文件夹finance_export，下边的有很多个excel表格，现在需要将excel表格不重要的信息过滤出去，然后合并到一张新表中 第三方库 OpenPYXL 和 os 这个demo只用到了以下两个库（不得不说python是真的好用啊，啥样的库都有，方便又高效） OpenPYXL是一个用于读/写Excel2010 XLSX/XLSM/XLTX/XLTM文件的python库。它的诞生是由于缺少从Python（OfficeOpenXML格式）本地读/写的现有库。 os模块提供了非常丰富的方法用来处理文件和目录。 实现首先找一个目录，准备好这样的几个文件夹 每个文件的目录结构和作用如图，当然你可以去源码中修改 test3.py 定义了一个函数，方便主程序调用。这个函数用于修改单张表数据的，接收一个参数（单张表的地址）,处理完成后保存在指定的文件夹下边，如下所示。 123456789101112131415161718192021222324252627282930313233343536#一个函数，调用是在merge.py下，传过来的是单张表的地址，如C:\Users\LanxiangC2\Desktop\study\tsouling_data\myblog\finance_export\Canada.xlsxef deal_one(url): import openpyxl as xl # 单张列表处理数据并另存为 # 思路如下 # wb2为新文件 wb1为操作的数据 wb2 = xl.Workbook() wb = xl.load_workbook(url) ws = wb.active ws2 = wb2.active # 连个文件我们都取到第一个表单 sheet = wb.worksheets[0] sheet2 = wb2.worksheets[0] # 提取表中的关键元素并保存，作为一会每行的第一个元素 export_country = sheet["C3"].value # 删掉不重要的行 这里是1到9 sheet.delete_rows(1,9) # 删掉第二列 因为不知道是什么鬼 sheet.delete_cols(2) # 插入第一列 此时第一列为空白 sheet.insert_cols(1,1) # 接下来我们先对每行的第一个元素赋值 之前保存的export_country for row_idx in range(1, sheet.max_row): # 第一行第一个元素赋值 sheet["A&#123;&#125;".format(row_idx)] = export_country # 然后拷贝每一个元素到新的表中去 for col_idx in range(1, sheet.max_column): tmp = ws.cell(row =row_idx, column = col_idx).value ws2.cell(row = row_idx, column = col_idx, value = tmp) # 分别保存看结果 wb.save('./newdata1/'+ export_country +'_new.xlsx') wb2.save('./newdata/'+ export_country +'_new.xlsx') print(export_country +'.xlsx操作完成') merge.py 这个程序呢首先获取到原始数据下的所有表的名字，然后循环处理每一个文件，调用上一个程序传入单张表的地址。之后开始合并操作，合并时新建一个表，没合并一个表，记录下当前表的行数，避免下次合并时覆盖，不用说也是用循环，如下所示。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#引入上一个程序test2import test2import openpyxl as xlimport osprint('开始处理每一张表--------------------------------------')#path是你自己的路径path = 'C:/Users/LanxiangC2/Desktop/study/tsouling_data/finance_export/'file_list = os.listdir(path) # 获取这个文件夹下所有的excel文档print(file_list)#循环操作每一张表for file in file_list: test2.deal_one(path + file)print('每一张表处理完毕--------------------------------------')print('现在开始合并操作++++++++++++++++++++++++++++++++++++++')#path2是你自己的路径path2 = 'C:/Users/LanxiangC2/Desktop/study/tsouling_data/newdata/'wb3 = xl.Workbook() #新建一个表，这个表存放的是最终的数据结果ws3 = wb3.active #设置为当前操作空间sheet3 = wb3.worksheets[0] #默认获取的也是第一个表单sheetlist = os.listdir(path2) # 获取这个文件夹下所有的excel文档row_count = 0 #记录下新的表单合并到多少行了,避免重复覆盖掉了#循环记录list下的每一个表的内容for name in list: #读取单张表并拿到表单内容 wb = xl.load_workbook(path2 + name) ws = wb.active sheet = wb.worksheets[0] #print(str(name) + '的列数:' + str(sheet.max_column)) #循环读取这张表的数据，两个循环，行循环一次列循环一次 for row_idx in range(1, sheet.max_row + 1): for col_idx in range(1, sheet.max_column + 1): #记录数值到新的表里 tmp = ws.cell(row =row_idx, column = col_idx).value ws3.cell(row = row_idx + row_count, column = col_idx, value = tmp) #记录下新的表单合并到多少行了,避免重复覆盖掉了 row_count += sheet.max_rowprint(row_count)print('合并操作结束++++++++++++++++++++++++++++++++++++++')#保存到指定路径wb3.save('./final_new/data.xlsx')print('success!所有操作操作完成') 完结撒花！ 等等还是运行一下看看效果吧，希望不会被打脸，文件根目录下python merge.py，回车 没有报错！成功。可以看到几行代码就实现了对n张表的数据处理，并且生成了1847行的一张新表，要是手动的话，emmm。手动@邹同学啊，pyton是个好东西赶快学起来。 总结 openpyxl对Excel表格的创建与写操作例程 以下参考作者卡图卢斯博客地址：https://blog.csdn.net/u014647208/article/details/78684812 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155#encoding: utf8 from openpyxl import Workbook#创建一个工作薄#使用openpyxl没有必要先在系统中新建一个.xlsx，我们需要做的只需要引Workbook这个类，接着开始调用它。#-----------------------------------------------------------------------------------wb = Workbook()#-----------------------------------------------------------------------------------#一个工作簿(workbook)在创建的时候同时至少也新建了一张工作表(worksheet)。你可以通过openpyxl.workbook.Workbook.active()调用得到正在运行的工作表。#-----------------------------------------------------------------------------------ws = wb.active"""注意：该函数调用工作表的索引(_active_sheet_index)，默认是0。除非你修改了这个值，否则你使用该函数一直是在对第一张工作表进行操作。"""#-----------------------------------------------------------------------------------#使用openpyxl.workbook.Workbook.create_sheet()新建一张表#-----------------------------------------------------------------------------------ws1 = wb.create_sheet() #默认插在工作簿末尾ws2 = wb.create_sheet(0) #插入在工作簿的第一个位置#-----------------------------------------------------------------------------------#在创建工作表的时候系统自动命名。他们按照序列依次命名 (Sheet, Sheet1, Sheet2, ...)。你可以通过调用下面的属性修改工作表的名称：#-----------------------------------------------------------------------------------ws.title = "New Title" #系统第一张表默认的名称Sheet#-----------------------------------------------------------------------------------#标签栏的背景色默认为白色。你可以通过提供一个RRGGBB颜色码改变标签栏的字体#-----------------------------------------------------------------------------------#ws.sheet_properties.tabColor = "1072BA"ws.sheet_properties.tabColor = "ff0033" #红色#-----------------------------------------------------------------------------------#一旦你获取工作表的名字，你可以通过workbook的key或者openpyxl.workbook.Workbook.get_sheet_by_name() 方法得到该工作表#-----------------------------------------------------------------------------------ws3 = wb["New Title"]ws4 = wb.get_sheet_by_name("New Title")print(ws is ws3 is ws4)#-----------------------------------------------------------------------------------#你可以通过openpyxl.workbook.Workbook.get_sheet_names() 方法得到工作簿的所有工作表。#-----------------------------------------------------------------------------------print(wb.get_sheet_names())#-----------------------------------------------------------------------------------#你也可以循环得到所有的工作表#-----------------------------------------------------------------------------------for sheet in wb: print(sheet.title)#-----------------------------------------------------------------------------------#单元格可以直接根据他们的索引直接获得#-----------------------------------------------------------------------------------c = ws['A4']print(type(c))print(c)#-----------------------------------------------------------------------------------#通过上述的语句，将返回在A4处的单元格，如果不存在将在A4新建一个。 单元格的#-----------------------------------------------------------------------------------ws['A4'] = 4#------------------------------------------------------------------------------------------------------------------#还提供 openpyxl.worksheet.Worksheet.cell() 方法获取单元格#-----------------------------------------------------------------------------------c = ws.cell("A4")print(c)#-----------------------------------------------------------------------------------#也可以根据行列值获取单元格#-----------------------------------------------------------------------------------d = ws.cell(row = 4, column = 2)print(d)print("d:",type(d))"""注意：当一个工作表被创建是，其中不包含单元格。只有当单元格被获取是才被创建。这种方式我们不会创建我们从不会使用的单元格，从而减少了内存消耗。"""#-----------------------------------------------------------------------------------#警告：由于上述特性，你如果遍历了单元格而非想要使用它们也将会在内存当中创建。比如下面：#-----------------------------------------------------------------------------------for i in range(1,101): for j in range(1,101): ws.cell(row = i, column = j)"""上述代码将会在内存中创建100*100个单元格。当然，这里也有方法来清理这些不想要的单元格，在后续我们将会介绍。""" #-----------------------------------------------------------------------------------#使用切片获取多个单元格#-----------------------------------------------------------------------------------cell_range = ws['A1':'C2']#-----------------------------------------------------------------------------------#使用openpyxl.worksheet.Worksheet.iter_rows() 方法获得多个单元格#-----------------------------------------------------------------------------------tuple(ws.iter_rows('A1:C2'))print(tuple(ws.iter_rows('A1:C2')))list(ws.iter_rows('A1:C2'))print(list(ws.iter_rows('A1:C2')))for row in ws.iter_rows('A1:C2'): for cell in row: print(cell)#-----------------------------------------------------------------------------------#如果你需要迭代文件中所有的行或者列，你可以使用,openpyxl.worksheet.Worksheet.rows()#-----------------------------------------------------------------------------------ws['C9'] = 'hello world'#-----------------------------------------------------------------------------------#一旦我们有一个openpyxl.cell.Cell，我们可以直接为该单元格赋值#-----------------------------------------------------------------------------------c = ws['C8']c.value = "nihao"print(c.value)print(ws['C8'].value)d.value = 3.14print(d.value)#-----------------------------------------------------------------------------------#你也可以使用Python中的其他类型和格式#-----------------------------------------------------------------------------------#wb = Workbook(guess_types=True)c.value = '12%'print(c.value)import datetimed.value = datetime.datetime.now()print (d.value)c.value = '31.50'print(c.value)#-----------------------------------------------------------------------------------#保存工作簿最简单最安全的方式是使用openpyxl.workbook.Workbook的openpyxl.workbook.Workbook.save() 方法#-----------------------------------------------------------------------------------wb.save("TonyDemoExcle.xlsx")"""特别警告：这个操作将会在没有认识提示的情况下用现在写的内容，覆盖掉原文件中的所有内容"""#-----------------------------------------------------------------------------------#你也可以 as_template=True，将文件保存称为一个模板#-----------------------------------------------------------------------------------wb = load_workbook('TonyDemoExcle1.xlsx')wb.save('TonyDemoExcle1.xltx', as_template=True)#-----------------------------------------------------------------------------------#和写入文件的方式相同，你可以引入openpyxl.load_workbook()来打开一个已经存在的工作簿#-----------------------------------------------------------------------------------from openpyxl import load_workbookwb2 = load_workbook('test.xlsx')print(wb2.get_sheet_names())]]></content>
      <categories>
        <category>python学习之旅</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组中的逆序对]]></title>
    <url>%2F2020%2F06%2F05%2F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9%2F</url>
    <content type="text"><![CDATA[题目描述：在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007 参考博客：https://cuijiahua.com/blog/2018/01/basis_35.html javascript实现代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556function InversePairs(data)&#123; // write code here if (data.length === 0 ) &#123; return 0 &#125; let copy = [].concat(data) //归并排序 function mergeCount (data, copy , left, right) &#123; if (left === right) &#123; return 0 &#125; let mid = (left + right) &gt;&gt; 1 let leftCount = mergeCount(data, copy, left, mid) let rightCount = mergeCount(data, copy, mid+1, right) //定义左右数组的指针 从左往右 let pl = left let pr = mid + 1 //定义辅助数组的指针 let idx = left // 定义左右之间的的逆序对 let betweenCount = 0 while (pl &lt;= mid &amp;&amp; pr &lt;= right) &#123; if (data[pl] &gt; data[pr]) &#123; // 计算就在这一步哦 核心关键点 betweenCount += mid - pl + 1 copy[idx++] = data[pr++] &#125;else &#123; copy[idx++] = data[pl++] &#125; &#125; // 把没填入辅助队列的填入 while (pl &lt;= mid) &#123; copy[idx++] = data[pl++] &#125; while (pr &lt;= right) &#123; copy[idx++] = data[pr++] &#125; for (let i = left; i &lt;= right; i++) &#123; data[i] = copy[i] &#125; return (rightCount + leftCount + betweenCount) &#125; let count = mergeCount(data, copy , 0, data.length -1) return count % 1000000007&#125; module.exports = &#123; InversePairs : InversePairs&#125;;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[找第N个丑数]]></title>
    <url>%2F2020%2F06%2F05%2F%E6%89%BE%E7%AC%ACN%E4%B8%AA%E4%B8%91%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 先看看我自己的代码吧 1234567891011121314151617181920212223242526272829303132333435363738394041function GetUglyNumber_Solution(index)&#123; //找一个数的质因子列表 let getPrimes = (num) =&gt; &#123; let recur = (num) =&gt; &#123; let arr = [] //找质因子 for (let i=2, len = num/2 +1 ; i &lt; len; i++)&#123; if (num % i === 0 &amp;&amp; !recur(i).length) &#123; arr.push(i) &#125; &#125; return arr &#125; return recur(num) &#125; let res = [1] let i = 2 while( res.length &lt; index) &#123; let primes = getPrimes(i) //即这个数没有质因数 if (primes.length === 0) &#123; if (i === 2 || i=== 3|| i ===5) &#123; res.push(i) &#125; &#125; else &#123; let valide = true primes.forEach((item) =&gt; &#123; if (item !== 2 &amp;&amp; item !==3 &amp;&amp; item !==5) &#123; valide = false &#125; &#125;) if (valide) &#123; res.push(i) &#125; &#125; i++ &#125; return res[index - 1]&#125; 结果运行超时，嚎嚎大哭有木有。 然后请教了下讨论区的同学，看了下他们的分享 123456789101112131415161718192021class Solution &#123;public: int GetUglyNumber_Solution(int index) &#123; // 0-6的丑数分别为0-6 if(index &lt; 7) return index; //p2，p3，p5分别为三个队列的指针，newNum为从队列头选出来的最小数 int p2 = 0, p3 = 0, p5 = 0, newNum = 1; vector&lt;int&gt; arr; arr.push_back(newNum); while(arr.size() &lt; index) &#123; //选出三个队列头最小的数 newNum = min(arr[p2] * 2, min(arr[p3] * 3, arr[p5] * 5)); //这三个if有可能进入一个或者多个，进入多个是三个队列头最小的数有多个的情况 if(arr[p2] * 2 == newNum) p2++; if(arr[p3] * 3 == newNum) p3++; if(arr[p5] * 5 == newNum) p5++; arr.push_back(newNum); &#125; return newNum; &#125;&#125;; 其思路如下 通俗易懂的解释： 首先从丑数的定义我们知道，一个丑数的因子只有2,3,5，那么丑数p = 2 ^ x * 3 ^ y * 5 ^ z，换句话说一个丑数一定由另一个丑数乘以2或者乘以3或者乘以5得到，那么我们从1开始乘以2,3,5，就得到2,3,5三个丑数，在从这三个丑数出发乘以2,3,5就得到4，6,10,6，9,15,10,15,25九个丑数，我们发现这种方\*得到重复的丑数，而且我们题目要求第N个丑数，这样的方法得到的丑数也是无序的。那么我们可以维护三个队列：** （1）丑数数组： 1 乘以2的队列：2 乘以3的队列：3 乘以5的队列：5 选择三个队列头最小的数2加入丑数数组，同时将该最小的数乘以**2,3,5**放入三个队列； （2）丑数数组：1,2 乘以2的队列：4 乘以3的队列：3，6 乘以5的队列：5，10 选择三个队列头最小的数3加入丑数数组，同时将该最小的数乘以**2,3,5**放入三个队列； （3）丑数数组：1,2,3 乘以2的队列：4,6 乘以3的队列：6,9 乘以5的队列：5,10,15 选择三个队列头里最小的数4加入丑数数组，同时将该最小的数乘以**2,3,5**放入三个队列； （4）丑数数组：1,2,3,4 乘以2的队列：6，8 乘以3的队列：6,9,12 乘以5的队列：5,10,15,20 选择三个队列头里最小的数5加入丑数数组，同时将该最小的数乘以**2,3,5**放入三个队列； （5）丑数数组：1,2,3,4,5 乘以2的队列：6,8,10， 乘以3的队列：6,9,12,15 乘以5的队列：10,15,20,25 选择三个队列头里最小的数6加入丑数数组，但我们发现，有两个队列头都为6，所以我们弹出两个队列头，同时将12,18,30放入三个队列； …………………… 疑问： 1.为什么分三个队列？ 丑数数组里的数一定是有序的，因为我们是从丑数数组里的数乘以2,3,5选出的最小数，一定比以前未乘以2,3,5大，同时对于三个队列内部，按先后顺序乘以2,3,5分别放入，所以同一个队列内部也是有序的； 2.为什么比较三个队列头部最小的数放入丑数数组？ 因为三个队列是有序的，所以取出三个头中最小的，等同于找到了三个队列所有数中最小的。 实现思路： 我们没有必要维护三个队列，只需要记录三个指针显示到达哪一步；“|”表示指针,arr表示丑数数组； （1）1 |2 |3 |5 目前指针指向0,0,0，队列头arr[0] * 2 = 2, arr[0] * 3 = 3, arr[0] * 5 = 5 （2）1 2 2 |4 |3 6 |5 10 目前指针指向1,0,0，队列头arr[1] * 2 = 4, arr[0] * 3 = 3, arr[0] * 5 = 5 （3）1 2 3 2| 4 6 3 |6 9 |5 10 15 目前指针指向1,1,0，队列头arr[1] * 2 = 4, arr[1] * 3 = 6, arr[0] * 5 = 5 ……………… 啊，再次嚎嚎大哭有木有！大佬，大佬！]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[部署静态页面到服务器]]></title>
    <url>%2F2020%2F06%2F04%2F%E9%83%A8%E7%BD%B2%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[秋招将至，一名前端小白无时不刻不在幻想如何才能在众多简历中脱颖而出 想说一句非科班出身的太难了，我搞了好半天才把静态页面部署到服务器上，说个题外话，买服务器的时候我还在纠结买哪个公司的，担心到时候面试官问到会很尴尬呀（哈哈，梦回高考之前在想去北大还是清华啦）。先给自己拟定一个流程图吧（emmmm，不知道能不能行呀）。 WinScp和Xchell WinSCP是一个Windows环境下使用SSH的开源图形化SFTP客户端。同时支持SCP协议。它的主要功能就是在本地与远程计算机间安全的复制文件。winscp也可以链接其他系统,比如linux系统。 没错安装这个软件正是为了和我的win本对接，方便又好用 Xshell是一个强大的安全终端模拟软件，它支持SSH1, SSH2, 以及Microsoft Windows 平台的TELNET 协议。Xshell 通过互联网到远程主机的安全连接以及它创新性的设计和特色帮助用户在复杂的网络环境中享受他们的工作。 Xshell很方便地模拟服务器上的终端，不错的工具，这里我都装上了，接下来就是对服务器进行配置了啦 Nginx安装和配置 Nginx (engine x) 是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务。Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点（俄文：Рамблер）开发的，第一个公开版本0.1.0发布于2004年10月4日。 我的服务器操作系统选用的是ubuntu，其他系统朋友们请自行查阅哦 安装 1sudo apt-get install nginx 配置 1cat /etc/nginx/nginx.conf 以下代码提供 http 服务相关的配置参数，一般默认配置就可以，主要配置在于 http 上下文里的 server 上下文 12345678910111213141516171819http &#123; sendfile on; keepalive_timeout 65; types_hash_max_size 2048; include /etc/nginx/mime.types; default_type application/octet-stream; server &#123; # 监听本机所有 ip 上的 80 端口 listen 80; # 域名, &quot;_&quot; 代表获取匹配所有 server_name localhost; # 站点根目录 root /usr/share/nginx/html default_type text/html; # 可有多个 location 用于配置路由地址 location / &#123; index index.html; &#125;&#125; 这里关注location配置，nginx会根据匹配规则去root根目录下寻找，这里我的根目录地址是/usr/share/nginx/html,存放配置文件的地址是/etc/nginx/nginx.conf 启动 利用配置文件启动nginx 1nginx -c /etc/nginx/nginx.conf 重装载命令 使用 reload 方法不用重启服务，直接重新加载配置文件，客户端感觉不到服务异常，实现平滑切换。当然你也可以重新启动 nginx 服务。 1nginx -s reload 重启 nginx -s reload1sudo service nginx restart 停止 1sudo nginx -s stop 另外，想查看下进程 123456#查看非root启动的程序ps -U root -u root -N#系统中的每个进程ps -A ps -e#top命令提供了运行中系统的动 部署静态页面nginx配置完成后就可以放置我的静态网页到服务器上啦，想想还有点小激动呢，先输入我的域名试下吧，地址栏输入www.lanxiangc2.cn，点击确定，bingo！ 启动成功啦！接下来按照对nginx的设置放置一个静态网页到指定的目录下，输入www.lanxiangc2.cn/homeworkdemo，点击回车，bingo！ 忙活了半天总算是没有瞎忙活啊，接下来就着手好好准备作品和demo吧，加油！！！]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>运维</tag>
        <tag>部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉搜索树转化为双向链表]]></title>
    <url>%2F2020%2F06%2F04%2F%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E5%8C%96%E4%B8%BA%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[昨天遇到一道这样的题，‘输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。’，想了很久才弄明白。 思路就是利用中序遍历，然后根据二叉搜索树的特性去递归。代码如下。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/* function TreeNode(x) &#123; this.val = x; this.left = null; this.right = null;&#125; */function Convert(pRootOfTree)&#123; // write code here//1.将左子树构造成双链表，并返回链表头节点。///2.定位至左子树双链表最后一个节点。//3.如果左子树链表不为空的话，将当前root追加到左子树链表。//4.将右子树构造成双链表，并返回链表头节点。//5.如果右子树链表不为空的话，将该链表追加到root节点之后。//6.根据左子树链表是否为空确定返回的节点。 if(pRootOfTree == null)&#123;return null;&#125; if(pRootOfTree.right == null &amp;&amp; pRootOfTree.left == null) &#123;return pRootOfTree;&#125; // 1.将左子树构造成双链表，并返回链表头节点 var left = Convert(pRootOfTree.left); var p =left; // 2.定位至左子树双链表最后一个节点 while(p!=null &amp;&amp; p.right!=null)&#123;p = p.right;&#125; // 3.如果左子树链表不为空的话，将当前pRootOfTree追加到左子树链表 if(left!=null)&#123; p.right = pRootOfTree; pRootOfTree.left = p; &#125; // 4.将右子树构造成双链表，并返回链表头节点 // 5.如果右子树链表不为空的话，将该链表追加到pRootOfTree节点之后 var right = Convert(pRootOfTree.right); if(right)&#123; right.left = pRootOfTree; pRootOfTree.right = right; &#125; //递归函数的返回值 return left!==null?left:pRootOfTree; &#125; module.exports = &#123; Convert : Convert&#125;;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速判断空数组和空对象]]></title>
    <url>%2F2020%2F06%2F03%2F%E5%BF%AB%E9%80%9F%E5%88%A4%E6%96%AD%E7%A9%BA%E6%95%B0%E7%BB%84%E5%92%8C%E7%A9%BA%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[判断空数组1JSON.stringify(data) == "[]" 1arr != false 1arr == false 判断对象1JSON.stringify(data) == "&#123;&#125;" 12Object.prototype.isPrototypeOf(obj) Object.keys(obj).length === 0 1234// 将json对象转化为json字符串，再判断该字符串是否为"&#123;&#125;"var data = &#123;&#125;;var b = (JSON.stringify(data) == "&#123;&#125;");alert(b);//true 123456789// for in 循环判断var obj = &#123;&#125;;var b = function() &#123; for(var key in obj) &#123; return false; &#125; return true;&#125;alert(b());//true 12345// jquery的isEmptyObject方法// 此方法是jquery将(for in)进行封装，使用时需要依赖jqueryvar data = &#123;&#125;;var b = $.isEmptyObject(data);alert(b);//true 1234//Object.getOwnPropertyNames()方法 此方法是使用Object对象的getOwnPropertyNames方法，获取到对象中的属性名，存到一个数组中，返回数组对象，我们可以通过判断数组的length来判断此对象是否为空var data = &#123;&#125;;var arr = Object.getOwnPropertyNames(data);alert(arr.length == 0);//true 1234//使用ES6的Object.keys()方法 与前方法类似，是ES6的新方法, 返回值也是对象中属性名组成的数组var data = &#123;&#125;;var arr = Object.keys(data);alert(arr.length == 0);//true]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[for循环中的变量保存]]></title>
    <url>%2F2019%2F12%2F27%2Ffor%E5%BE%AA%E7%8E%AF%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%E4%BF%9D%E5%AD%98%2F</url>
    <content type="text"><![CDATA[今天的web前端学习打算用for循环给ul下的li标签绑定DOM0级事件，如下 12345&lt;ul&gt; &lt;li&gt;标题1&lt;/li&gt; &lt;li&gt;标题2&lt;/li&gt; &lt;li&gt;标题3&lt;/li&gt;&lt;/ul&gt; 12345678// 获取元素var items = document.getElementsByTagName('li')// for循环绑定事件for(var i = 0, len = items.length; i &lt; len; i++) &#123; items[i].onclick = function () &#123; alert('这是标题' + i) &#125;&#125; 以上的代码不用我解释了把，想实现的效果是点击哪个标题就弹出我点击了标题几。 可是问题出现了,我点击标题1，这时弹出“这是标题3”，我当时就不乐意了啊这明明就是标题1啊！！！ 本着实事求是的精神，我和这短短的几行程序进行了思想上的博弈，真理上的探究，直到我蓝牙鼠标彻底没电。（开个玩笑，凑个字数，23333） 那就查资料看看为啥把，原来这是因为for循环这段程序啊在脚本生成的时候就会执行，导致的结果虽然给每个li标签都绑定了事件，但是i的值却一直保存为循环的最大值也就是3，所以无论你点击标题几它都会弹出“这是标题3”。 我试了下，果然如此呀，既然这样那就想办法保存下来i的值不就好啦。（所以说现在的程序还是不够智能啊，黑人问号脸(lll￢ω￢)）。 1234567891011// 获取元素var items = document.getElementsByTagName('li')// for循环绑定事件for(var i = 0, len = items.length; i &lt; len; i++) &#123; // 函数自执行的方法 (function (i) &#123; items[i].onclick = function () &#123; alert('这是标题' + i) &#125; &#125;)(i)&#125; 这里我是用的匿名函数自执行的办法，使i变量得到保存，原理的话大家自行查阅了。 试一下效果，点击标题1，居然弹出”这时标题0”。emmm，小白就是小白啊，i是从0开始累加的呀，粗心粗心！！！Whatever问题总算是解决了嘛，还是很开心的呀。 在网上查阅了下另外的办法也是可以解决的哦，比如你自定义属性保存嘛，这时最容易想到的啦；还有通过闭包的方法返回并保存i的值；以及用ES6语法中的let代替var关键字等等。 我就不一一试了，宿舍11点半门禁了，我也不写了，哈哈，溜了溜了~~]]></content>
      <tags>
        <tag>前端学习</tag>
        <tag>问题记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[节点新增模块]]></title>
    <url>%2F2019%2F06%2F26%2F%E8%8A%82%E7%82%B9%E6%96%B0%E5%A2%9E%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[1整体介绍节点新增模块按照功能设计主要分为三个模块，对应的三个功能如下 1.1操作流程图节点新增模块在web前端分为三个区域，每个区域的作用如下 待配置节点区域 检索待配置节点 查看待配置节点 已配置节点区域 查看已配置节点 操作区域 配置新增加的节点 修改已配置的节点 由此得到的操作流程图如下 1.2详细部署图 1.3时序图 1.4设计原型 2检索功能模块对于检索功能模块的泳道流程图如下，前端页面设计请参考上方的原型设计，数据交互是通过STOMP协议与RabbitMQ建立webSocket双向连接来实现的 泳道流程图 相关JS代码 建立连接对象（还未发起连接） 1this.socket = new SockJS('http://cn.cquzxy.top:15674/stomp') 获取 STOMP 子协议的客户端对象 1this.stompClient = Stomp.over(this.socket) 向服务器发起websocket连接并发送CONNECT帧 123456789this.stompClient.connect(&#123;'login': 'cqu', 'passcode': '2201'&#125;, frame =&gt; &#123; this.connected = true this.stompClient.subscribe('/exchange/addnode/response', tick =&gt; &#123; var message = JSON.parse(tick.body) &#125;) &#125;, error =&gt; &#123; this.connected = false &#125;) 以上代码中的message即为web前端所需要的Json格式代码{MAC: &#39;XXX&#39;, IP: &#39;XXX&#39;},另外STOMP 客户端要想接收来自服务器推送的消息，必须先订阅相应的URL，即发送一个 SUBSCRIBE 帧，然后才能不断接收来自服务器的推送消息 连接成功后，客户端可使用 send() 方法向服务器发送信息addnode 123var quote = &#123;type: 'addnode'&#125;this.stompClient.subscribe('/exchange/addnode/request', tick =&gt; &#123;&#125;)this.stompClient.send('/exchange/addnode/request', &#123;&#125;, JSON.stringify(quote)) 要停止接收消息，客户机可以对返回的对象使用unsubscribe()方法 1this.stompClient.unsubscribe() 3配置功能模块配置功能模块的主要功能是对新加入的节点进行参数配置，该部分只涉及VueJS和Django之间的交互 泳道流程图 相关JS代码 定义默认的URL 1axios.defaults.baseURL = 'http://192.168.1.10:8000' 创建方法名为POST的http请求 12345678axios.post('/nodes/') .then(response =&gt; &#123; context.commit('nodesConf', response.data) console.log(response) &#125;) .catch(error =&gt; &#123; console.log(error) &#125;) 得到的response.data即为后端返回的JSON格式的已配置节点 4修改功能模块配置功能模块的主要功能是对已有参数的节点进行参数修改，该部分只涉及VueJS和Django之间的交互 在节点显示到修改共有两两次与Django的交互： 加载已配置节点列表——通过axios.get()方法获取JSON数据 修改节点的配置参数——通过axio.patch()方法提交http请求 泳道流程图 相关JS代码 1.通过axios.get()发送http请求以获取储存在后端的已配置节点列表信息 12345678axios.get('/nodes/') .then(response =&gt; &#123; context.commit('retrieveNodesConf', response.data) console.log(response) &#125;) .catch(error =&gt; &#123; console.log(error) &#125;) 得到的response.data即为所需要的JSON格式数据 2.通过axios.patch()发送http请求以修改单个节点的配置信息，例如 1234567891011axios.patch('/nodes/', &#123; positionx: 5, positiony: 5, &#125;) .then(response =&gt; &#123; context.commit('nodesConf', response.data) console.log(response) &#125;) .catch(error =&gt; &#123; console.log(error) &#125;) 以上代码中{positionx: 5, positiony: 5}为修改信息，得到的response.data为修改后的节点的配置信息]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>节点管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web前端设计]]></title>
    <url>%2F2019%2F06%2F26%2Fweb%E5%89%8D%E7%AB%AF%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[1 项目设计的整体设计框架如下 2 web前端设计框架如下 数据在用户、网络前端和后端之间的信息传输过程如下 就网页前端而言，主要问题有以下三方面 组成元素 功能 VueJs 页面UI设计、数据展示设计 HTTP REST API 前端通过HTTP RSTE API与Django交互数据 RabbitMQ 前端通过WebSocket与节点临时数据进行实时交互 因此，前端设计任务会主要围绕以上三个方面进行模块化设计，以达到与信息在用户、前端和后台之间正常传输的整体测试目的 3 web前端框架及相关技术在项目中的应用本部分主要描述了web前端开发中所应用的一些前端技术和在与Django和RabbitMQ交互过程中的实现方法 3.1VueJs框架的使用Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。 官网地址详情：https://cn.vuejs.org/v2/guide/ 全局安装 1npm install --g vue 全局安装vue-cli 1npm install --global vue-cli 创建一个基于webpack模块的新项目 1vue init webpack hlc-project 进行Vue项目的配置 12345678910111213141516171819202122This will install Vue 2.x version of the template.For Vue 1.x use: vue init webpack#1.0 hlc-project? Project name hlc-project? Project description A Vue.js project? Author runoob &lt;test@runoob.com&gt;? Vue build standalone? Use ESLint to lint your code? Yes? Pick an ESLint preset Standard? Setup unit tests with Karma + Mocha? Yes? Setup e2e tests with Nightwatch? Yes vue-cli · Generated &quot;hlc-project&quot;. To get started: cd my-project npm install npm run dev Documentation can be found at https://vuejs-templates.github.io/webpac 3.2vuetify的使用何为vuetify 一个vue ui库，提供vue组件供使用。根据 Google Material Design 指南实现。Vuetify支持SSR(服务端渲染)，SPA(单页应用程序)，PWA(渐进式web应用程序)和标准HTML页面。 官网学习地址：https://vuetifyjs.com/zh-Hans/ 安装vuetify 1vue add vuetify 使用vuetify 1234import Vue from &apos;vue&apos;import Vuetify from &apos;vuetify&apos;Vue.use(Vuetify) 3.2 与Django REST的交互——axiosDjango REST框架是一个用于构建Web api的强大而灵活的工具包。Web可浏览API对于开发人员来说是一个巨大的可用性胜利，它可用于身份验证策略，包括OAuth1a和OAuth2的包，还支持ORM和非ORM数据源的序列化。 Django REST framework的官网学习地址在这里：https://www.django-rest-framework.org/ 3.2.1何为axiosAxios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中 它的特点如下： 从浏览器中创建 XMLHttpRequests 从 node.js 创建 http 请求 支持 Promise API 拦截请求和响应 转换请求数据和响应数据 取消请求 自动转换 JSON 数据 客户端支持防御 XSRF axios中文官网学习地址：https://www.kancloud.cn/yunye/axios/234845 3.2.2安装和使用axios这里我是用的是npm进行安装 1$ npm install axios 然后在Vue中的vuex（或者是store.js）中引入 1import axios from 'axios' 通过向 axios 传递相关配置来创建请求 axios(config)123456789// 发送 POST 请求axios(&#123; method: 'post', url: '/user/12345', data: &#123; firstName: 'Fred', lastName: 'Flintstone' &#125;&#125;); axios(url[, config]) 12// 发送 GET 请求（默认的方法）axios('/user/12345') 为方便起见，为所有支持的请求方法提供了别名： axios.request(config) axios.get(url[, config]) axios.delete(url[, config]) axios.head(url[, config]) axios.post(url[, data[, config]]) axios.put(url[, data[, config]]) axios.patch(url[, data[, config]]) 在使用别名方法时， url、method、data 这些属性都不必在配置中指定。通过以上方法的使用我们基本可以实现与Django之间的交互，对数据库的数据进行增删查改功能的操作。详情请参考上方的官网进行学习和使用。 3.3与RabbitMQ的交互——SockJS和Stomp3.3.1安装和使用SockJSSockJS是一个浏览器JavaScript库，它提供了一个类似websocket的对象。SockJS提供了一个连贯的、跨浏览器的Javascript API，它在浏览器和web服务器之间创建了一个低延迟、全双工、跨域的通信通道。 SockJS首先尝试使用本地WebSockets。如果失败，它可以使用各种特定于浏览器的传输协议，并通过类似websocket的抽象来表示它们。 SockJS适用于所有现代浏览器和不支持WebSocket协议的环境——例如，在受限的企业代理之后。 SockJS-client 的使用原则： API应该尽可能地遵循HTML5 Websockets API。 所有传输都必须支持开箱即用的跨域连接。这是可能的，并建议在不同于您的主网站的服务器上托管SockJS服务器。 每个主流浏览器至少支持一种流协议。 流传输应该跨域工作，并且应该支持cookie(用于基于cookie的粘性会话)。 轮询传输被用作限制代理背后的旧浏览器和主机的备份。 连接的建立应该是快速和轻量级的。 内部没有Flash(不需要打开端口843 -它不通过代理工作，不需要主机的“crossdomain.xml“，不需要等待3秒来检测问题) 这里我是用的是npm进行安装 1npm install sockjs-client 在然后在Vue中的vuex（或者是store.js）中引入 1import SockJS from 'sockjs-client' 之后就可以在&lt;script&gt;中建立与SockJS服务器之间的连接，例如 1this.socket = new SockJS('http://cn.cquzxy.top:15674/stomp') 详细使用参考：https://www.npmjs.com/package/sockjs-client 3.3.2安装和使用stompjs什么是stomp?STOMP是一个简单的面向文本的消息传递协议。它定义了一个可互操作的线路格式，以便任何可用的STOMP客户机都可以与任何STOMP消息代理通信，以提供简单和语言和平台之间广泛的消息互操作性STOMP web站点有一个STOMP客户机和服务器实现的列表。 什么是WebSocket API?WebSockets是“用于Web的TCP”。 WebSocket API使web应用程序能够以一种直接的方式处理与服务器端进程的双向通信。开发人员一直在使用XMLHttpRequest(“XHR”)来实现这一目的，但是XHR使开发来回与服务器通信的web应用程序变得不必要地复杂。XHR基本上是异步HTTP，由于需要使用诸如长挂GET之类的复杂技术将数据从服务器发送到浏览器，所以简单的任务很快就会变得复杂。与XMLHttpRequest相反，WebSockets在浏览器中提供了一个真正的双向通信通道。获得WebSocket连接后，可以通过调用send()方法将数据从浏览器发送到服务器，并通过onmessage事件处理程序将数据从服务器接收到浏览器。 除了新的WebSocket API之外，还有一个浏览器用来与服务器通信的新协议(“WebSocket协议”)。该协议不是原始TCP，因为它需要提供浏览器的“同源”安全模型。它也不是HTTP，因为WebSocket流量与HTTP的请求-响应模型不同。使用新的WebSocket协议的WebSocket通信应该使用更少的带宽，因为与一系列的XHR和挂起GET不同，一旦建立了单个连接，就不会交换头信息。要使用这个新的API和协议，并利用更简单的编程模型和更高效的网络流量，确实需要一个新的服务器实现来进行通信。 这里我是用的是npm进行安装 1npm install stompjs 在然后在Vue中的vuex（或者是store.js）中引入 1import Stomp from 'stompjs' 使用SockJS项目提供的使用方式如下，它可以使用多种特定于浏览器的传输协议 12var ws = new SockJS(url);var client = Stomp.over(ws); connect()方法接受不同数量的参数，以提供一个在大多数情况下都可以使用的简单API client.connect(login, passcode, connectCallback)client.connect(login, passcode, connectCallback, errorCallback)client.connect(login, passcode, connectCallback, errorCallback, host) 要断开客户机与服务器的连接，可以调用它的disconnect()方法。断开是异步的:要在断开有效时得到通知，断开方法接受一个可选的回调参数。 client.disconnect(function() {alert(&quot;See you next time!&quot;);} 当客户机连接到服务器时，它可以使用send()方法发送STOMP消息。该方法接受与STOMP目的地对应的强制目的地参数。它还接受两个可选参数:header，一个JavaScript对象，包含额外的消息header和一个String对象。 1client.send("/queue/test", &#123;priority: 9&#125;, "Hello, STOMP"); 您可以使用subscribe()方法订阅目的地。该方法接受两个强制参数:destination，一个对应于destination和回调的字符串，一个带有一个消息参数的函数和一个可选参数标头，一个用于附加标头的JavaScript对象。 1var subscription = client.subscribe("/queue/test", callback); 要停止接收消息，客户机可以对subscribe()方法返回的对象使用unsubscribe()方法。例如 123var subscription = client.subscribe(...); ... subscription.unsubscribe(); STOMP消息的主体必须是一个字符串。如果希望发送和接收JSON对象，可以使用JSON.stringify()和JSON.parse()将JSON对象转换为字符串，反之亦然。 1234567var quote = &#123;symbol: 'APPL', value: 195.46&#125;;client.send("/topic/stocks", &#123;&#125;, JSON.stringify(quote));client.subcribe("/topic/stocks", function(message) &#123; var quote = JSON.parse(message.body); alert(quote.symbol + " is at " + quote.value);&#125;; 关于stompjs的详细学习地址：http://jmesnil.net/stomp-websocket/doc/]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>整体设计</tag>
        <tag>主要框架和工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[节点管理模块]]></title>
    <url>%2F2019%2F06%2F14%2F%E8%8A%82%E7%82%B9%E7%AE%A1%E7%90%86%E7%94%A8%E6%88%B7%E9%9C%80%E6%B1%82%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[1用户需求分析1用户对象管理员 2节点管理模块整体流程图 文章参考：用户需求分析整体流程图 2产品原型设计1节点配置1新增节点管理1节点添加授权功能设计 基本目标功能 实现形式 检测新增节点 检测新增节点按钮 了解待检测节点信息 添加待检测节点信息表 节点授权 授权按钮 节点不授权 不授权按钮 查看节点新增信息 添加节点授权新增信息表 2节点新增用例逻辑框图12345678910111213@startumlstartwhile (检测节点是否加入?) is (yes) :浏览节点信息; :选择待加入节点; :添加新节点信息; :增添; while (继续增添节点?) is (no) stop endwhile (yes)endwhile (no)stop@enduml 3节点授权界面原型设计2节点配置信息查看1节点配置信息查看功能设计 基本目标功能 实现形式 查看系统已有的节点 添加已有节点信息列表 查看各个节点对应的详细信息 点击节点弹出详情2. 2节点配置信息查看界面原型设计2节点调试1节点在线可视化1节点在线情况功能设计 基本目标功能 实现形式 查看所有节点的在线情况 节点在线矩阵图 2节点在线情况界面原型设计###3节点信息查看 1节点工作队列查看功能设计 基本实现功能 实现形式 查看节点的工作队列 添加每个节点的对列表 2节点工作队列界面原型设计#### 4节点网络负载1节点网络负载界面功能设计 基本实现功能 实现形式 查看节点网络负载 各个节点的负载图、整个网络的负载图 2节点网络负载界面用例逻辑框图1234567891011121314151617181920@startumlstartif(测试场景是否存在?) then (no) stopelse (yes) :选择测试场景; if(是否查看总的网络负载?) then (yes) :选择数据状态; :查看总的节点工作状态图; elseif(查看节点队列) then (yes) :输入节点编号; :查看节点队列状态和数据速率; elseif(查看单个节点的网络负载) then (yes) :输入节点编号; :查看单个节点工作状态图; else (nothing) endif stop @enduml 3节点网络负载界面原型设计5节点工作状态1节点工作状态界面功能设计 基本实现功能 实现形式 查看节点工作状态 各个节点目前工作状态的信息显示 2节点工作状态用例逻辑框图1234567891011121314151617 @startumlstartif(测试场景是否存在?) then (no) stopelse (yes) : 选择测试场景;while(测试场景下是否有节点 ? ) is (yes) :选择工作节点; :查看工作状态; if(继续查看?) then (no) stop else(yes) endifendwhile (no) stop @enduml 3节点工作状态查看界面原型设计3前端代码的实现]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>节点管理</tag>
        <tag>UI设计</tag>
        <tag>需求分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue和Django之间的数据交互]]></title>
    <url>%2F2019%2F06%2F04%2FDjango%E5%92%8CVue%2F</url>
    <content type="text"><![CDATA[使用 axios 访问 API我们有很多种方式可以从 API 请求信息，但是最好首先确认这些数据看起来长什么样，以便进一步确定如何展示它。为此，我们会调用一次这个 API 并输出结果，以便我们能够看清楚它。比如创建一个 data 里的属性以最终放置信息，然后将会在 mounted 生命周期钩子中获取数据并赋值过去： 12345678910111213new Vue(&#123; el: '#app', data () &#123; return &#123; info: null &#125; &#125;, mounted () &#123; axios .get('https://api.coindesk.com/v1/bpi/currentprice.json') .then(response =&gt; (this.info = response)) &#125;&#125;) 123&lt;div id="app"&gt; &#123;&#123; info &#125;&#125;&lt;/div&gt; 但是我们得到的数据往往是这样的 1&#123; "data": &#123; "time": &#123; "updated": "Jun 4, 2019 13:24:00 UTC", "updatedISO": "2019-06-04T13:24:00+00:00", "updateduk": "Jun 4, 2019 at 14:24 BST" &#125;, "disclaimer": "This data was produced from the CoinDesk Bitcoin Price Index (USD). Non-USD currency data converted using hourly conversion rate from openexchangerates.org", "chartName": "Bitcoin", "bpi": &#123; "USD": &#123; "code": "USD", "symbol": "&amp;#36;", "rate": "7,989.8900", "description": "United States Dollar", "rate_float": 7989.89 &#125;, "GBP": &#123; "code": "GBP", "symbol": "&amp;pound;", "rate": "6,299.7246", "description": "British Pound Sterling", "rate_float": 6299.7246 &#125;, "EUR": &#123; "code": "EUR", "symbol": "&amp;euro;", "rate": "7,111.7452", "description": "Euro", "rate_float": 7111.7452 &#125; &#125; &#125;, "status": 200, "statusText": "", "headers": &#123; "content-type": "application/javascript", "cache-control": "max-age=15", "expires": "Tue, 04 Jun 2019 13:25:07 UTC" &#125;, "config": &#123; "transformRequest": &#123;&#125;, "transformResponse": &#123;&#125;, "timeout": 0, "xsrfCookieName": "XSRF-TOKEN", "xsrfHeaderName": "X-XSRF-TOKEN", "maxContentLength": -1, "headers": &#123; "Accept": "application/json, text/plain, */*" &#125;, "method": "get", "url": "https://api.coindesk.com/v1/bpi/currentprice.json" &#125;, "request": &#123;&#125; &#125; 我们已经得到了一些数据。但是它看起来还比较乱，所以我们会更好的展示它并添加一些错误处理，以防出现异常情况或请求超时。 vue-axios安装vue-axios1npm install --save axios vue-axios 引入12345import Vue from 'vue'import axios from 'axios'import VueAxios from 'vue-axios' Vue.use(VueAxios, axios) 使用我们可以以如下三种方式在项目中引入vue-axios1234567891011Vue.axios.get(api).then((response) =&gt; &#123; console.log(response.data)&#125;) this.axios.get(api).then((response) =&gt; &#123; console.log(response.data)&#125;) this.$http.get(api).then((response) =&gt; &#123; console.log(response.data)&#125;) 错误处理很多时候我们可能并没有从 API 获取想要的数据。这可能是由于很多种因素引起的，比如 axios 调用可能由于多种原因而失败，包括但不限于： API 不工作了； 请求发错了； API 没有按我们预期的格式返回信息。 当发送这个请求的时候，我们应该检查一下这些情况，并在所有情况下都返回相应的信息以便处理这些问题。在 axios 中，我们会通过使用 catch 来做这件事。 1.catch(error =&gt; console.log(error)) 项目应用本项目中的应用示例： 12345678910retrieveNodes (context) &#123; axios.get('/nodes/') .then(response =&gt; &#123; context.commit('retrieveNodes', response.data.results) console.log(response.data.results) &#125;) .catch(error =&gt; &#123; console.log(error) &#125;) &#125; 可以得到如下json格式的数据 123456789101112131415161718192021222324252627282930[ &#123; "node_id": 1, "ip": "127.0.0.1", "mac_addr": "07-16-76-00-02-86", "node_status": "ON", "wk_status": "IDLE" &#125;, &#123; "node_id": 2, "ip": "127.0.0.2", "mac_addr": "07-16-76-00-02-87", "node_status": "ON", "wk_status": "IDLE" &#125;, &#123; "node_id": 3, "ip": "127.0.0.3", "mac_addr": "07-16-76-00-02-88", "node_status": "OFF", "wk_status": "IDLE" &#125;, &#123; "node_id": 4, "ip": "127.0.0.3", "mac_addr": "07-16-76-00-02-88", "node_status": "OFF", "wk_status": "IDLE" &#125;] 参考资料使用axio访问api]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>项目设计</tag>
        <tag>节点管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网页前端基本功能的设计]]></title>
    <url>%2F2019%2F05%2F28%2F%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%E7%9A%84%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[Page 1：场景选择根据测试地区的不同，显示不同的节点布局。 可选场景有：Expressway/Primary Highway/Secondary Road/Tertiary Highway/Four-stage Highway，场景选择用传递到后端，主要用于前端限制参数配置可选范围。 Page 2 （节点管理页面）：节点的实时管理节点管理页面主要功能： 展示节点实时的状态信息 用于选择节点安排任务 节点的选择包括：1）选择任务使用的节点 2）选择节点类型——通信环境节点/测试用例节点，用于限制配置参数 不同状态节点（如，处于接收/发送状态，在线状态）应该用不同的颜色/样式表示 Page 3 （任务配置页面）：节点的配置 节点的选择与配置应该可以单个配置也可以批量配置 12345678910111213141516171819202122232425262728//节点的json格式：(所有50个节点)&#123; &quot;nodes&quot;:[ &#123; &quot;id&quot;:1, &quot;nodeState&quot;:&#123; &quot;node_status&quot;:&quot;offline/online&quot;, &quot;w_status&quot;:&quot;idling/pending/waiting/running/finishing/completed&quot;, &quot;tr_status&quot;: &quot;Tx/Rx&quot;, &quot;node_message&quot;:&quot;This is an example message.&quot;, &#125;, &quot;node_config&quot;:&#123; &quot;tr_status&quot;:&quot;Tx/Rx&quot;， &quot;radio&quot;:&quot;1/2&quot;, &quot;Power&quot;:-127 ～ 128, &quot;dataRate&quot;:&quot;R6Mbps12BPSK&quot;, &quot;channel&quot;:&quot;172/174/176/178/180/182/184&quot;, &quot;destMacAddr&quot;:&quot;(e.g.)00-23-5A-15-99-42&quot;, &quot;psid&quot;:0 ～ 0xFFFFFFFF, &quot;payload&quot;:&quot;(e.g.)This is a test payload.&quot;, &quot;payloadLength&quot;:(e.g.)23, &quot;periodic&quot;:true/false, &quot;repeatTimes&quot;:10, &quot;repeatRate&quot;:100, &#125;, &#125;, ... ]&#125; params 描述 tr_status 收发状态 radio 选择工作的Radio Power 发送/接收功率 dataRate 发送速率 channel 发送/接收信道 destMacAddr 目的MAC地址 psid 标识服务类型 payload 负载内容 payloadLength 负载长度 如果不对节点进行配置，则使用节点的默认配置信息（根据场景&amp;节点类型的选择，前端生成默认配置信息显示在节点配置页面）; 当勾选的场景，节点类型或者收发状态不同，返回的参数默认配置会不同，并且可配置的参数不同（不可配置参数禁选）; 配置完成后即生成了一个任务，若需要配置多个任务，则重复2-3步骤。 Page 4（任务页面）：生成任务配置信息、实时显示画面等 展示任务详情:包括任务实时状态以及任务相馆配置; 在此页面可以对任务进行管理（改变优先级，任务执行时间，删除，中止/暂停/重启等） 任务属性 任务属性描述 url ‘/tasks/‘ method GET data JSON(如下所示) params taskID:任务编号currentState:taskStatus:任务状态tx_statistics:整体发包数量rx_statistics:整体收包数量net_PDL:网络丢包率net_delay:网络平均时延config:(见1.4.2PARAM表) 123456789101112131415Tasks: [ &#123; taskID: 1, scence: &apos;&apos;, currentState: &#123; taskStatus: &apos;pending/waiting/running/finishing/completed&apos;, tx_statistics: 1000, rx_statistics: 800, net_PDL: 0.4, net_delay: &apos;2ms&apos; &#125;, config: &#123; &#125; &#125;]]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>项目设计</tag>
        <tag>流程安排</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VueJs框架]]></title>
    <url>%2F2019%2F05%2F28%2Ffront-end-UI%2F</url>
    <content type="text"><![CDATA[本部分主要利用了HTML、CSS和Javascript等知识，借助Vue2.0热门框架进行Web前后端分离的前端的开发工作。 VueJs框架的使用Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。 官网地址详情：https://cn.vuejs.org/v2/guide/ 全局安装 1npm install --g vue 全局安装vue-cli 1npm install --global vue-cli 创建一个基于webpack模块的新项目 1vue init webpack hlc-project 进行Vue项目的配置 12345678910111213141516171819202122This will install Vue 2.x version of the template.For Vue 1.x use: vue init webpack#1.0 hlc-project? Project name hlc-project? Project description A Vue.js project? Author runoob &lt;test@runoob.com&gt;? Vue build standalone? Use ESLint to lint your code? Yes? Pick an ESLint preset Standard? Setup unit tests with Karma + Mocha? Yes? Setup e2e tests with Nightwatch? Yes vue-cli · Generated &quot;hlc-project&quot;. To get started: cd my-project npm install npm run dev Documentation can be found at https://vuejs-templates.github.io/webpac vuetify的使用何为vuetify 一个vue ui库，提供vue组件供使用。根据 Google Material Design 指南实现。Vuetify支持SSR(服务端渲染)，SPA(单页应用程序)，PWA(渐进式web应用程序)和标准HTML页面。 安装vuetify 1vue add vuetify 使用vuetify 1234import Vue from &apos;vue&apos;import Vuetify from &apos;vuetify&apos;Vue.use(Vuetify)]]></content>
      <categories>
        <category>web前端技术学习</category>
      </categories>
      <tags>
        <tag>web前端工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端设计方案]]></title>
    <url>%2F2019%2F05%2F27%2Ffront-to-end%2F</url>
    <content type="text"><![CDATA[VueJs+WebSocket+HTTP REST API ​ 数据在用户、网络前端和后端之间的信息传输过程如下 就网页前端而言，主要问题有以下三方面 组成元素 功能 VueJs 页面UI设计、数据展示设计 HTTP REST API 前端通过HTTP RSTE API与Django交互数据 RabbitMQ 前端通过WebSocket与节点临时数据进行实时交互 因此，前端设计任务会主要围绕以上三个方面进行模块化设计，以达到与信息在用户、前端和后台之间正常传输的整体测试目的]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>项目设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F05%2F26%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
